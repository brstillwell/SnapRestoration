"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require("./utils");

var _errors = require("./errors");

var _errors2 = _interopRequireDefault(_errors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Enhanced HTTP client for the Kinto protocol.
 * @private
 */
var HTTP = function () {
  _createClass(HTTP, null, [{
    key: "DEFAULT_REQUEST_HEADERS",

    /**
     * Default HTTP request headers applied to each outgoing request.
     *
     * @type {Object}
     */
    get: function get() {
      return {
        Accept: "application/json",
        "Content-Type": "application/json"
      };
    }

    /**
     * Default options.
     *
     * @type {Object}
     */

  }, {
    key: "defaultOptions",
    get: function get() {
      return { timeout: null, requestMode: "cors" };
    }

    /**
     * Constructor.
     *
     * @param {EventEmitter} events                       The event handler.
     * @param {Object}       [options={}}                 The options object.
     * @param {Number}       [options.timeout=null]       The request timeout in ms, if any (default: `null`).
     * @param {String}       [options.requestMode="cors"] The HTTP request mode (default: `"cors"`).
     */

  }]);

  function HTTP(events) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, HTTP);

    // public properties
    /**
     * The event emitter instance.
     * @type {EventEmitter}
     */
    if (!events) {
      throw new Error("No events handler provided");
    }
    this.events = events;

    /**
     * The request mode.
     * @see  https://fetch.spec.whatwg.org/#requestmode
     * @type {String}
     */
    this.requestMode = options.requestMode || HTTP.defaultOptions.requestMode;

    /**
     * The request timeout.
     * @type {Number}
     */
    this.timeout = options.timeout || HTTP.defaultOptions.timeout;
  }

  /**
   * @private
   */


  _createClass(HTTP, [{
    key: "timedFetch",
    value: function timedFetch(url, options) {
      var _this = this;

      var hasTimedout = false;
      return new Promise(function (resolve, reject) {
        // Detect if a request has timed out.
        var _timeoutId = void 0;
        if (_this.timeout) {
          _timeoutId = setTimeout(function () {
            hasTimedout = true;
            reject(new Error("Request timeout."));
          }, _this.timeout);
        }
        function proceedWithHandler(fn) {
          return function (arg) {
            if (!hasTimedout) {
              if (_timeoutId) {
                clearTimeout(_timeoutId);
              }
              fn(arg);
            }
          };
        }
        fetch(url, options).then(proceedWithHandler(resolve)).catch(proceedWithHandler(reject));
      });
    }

    /**
     * @private
     */

  }, {
    key: "processResponse",
    value: function () {
      var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(response) {
        var status, text, error;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                status = response.status;
                _context.next = 3;
                return response.text();

              case 3:
                text = _context.sent;

                if (!(text.length === 0)) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", this.formatResponse(response, null));

              case 6:
                _context.prev = 6;
                return _context.abrupt("return", this.formatResponse(response, JSON.parse(text)));

              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](6);
                error = new Error("HTTP " + (status || 0) + "; " + _context.t0);

                error.response = response;
                error.stack = _context.t0.stack;
                throw error;

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[6, 10]]);
      }));

      function processResponse(_x2) {
        return _ref.apply(this, arguments);
      }

      return processResponse;
    }()

    /**
     * @private
     */

  }, {
    key: "formatResponse",
    value: function formatResponse(response, json) {
      var status = response.status,
          statusText = response.statusText,
          headers = response.headers;

      if (json && status >= 400) {
        var message = "HTTP " + status + " " + (json.error || "") + ": ";
        if (json.errno && json.errno in _errors2.default) {
          var errnoMsg = _errors2.default[json.errno];
          message += errnoMsg;
          if (json.message && json.message !== errnoMsg) {
            message += " (" + json.message + ")";
          }
        } else {
          message += statusText || "";
        }
        var error = new Error(message.trim());
        error.response = response;
        error.data = json;
        throw error;
      }
      return { status: status, json: json, headers: headers };
    }

    /**
     * @private
     */

  }, {
    key: "retry",
    value: function () {
      var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(url, retryAfter, request, options) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return (0, _utils.delay)(retryAfter);

              case 2:
                return _context2.abrupt("return", this.request(url, request, _extends({}, options, { retry: options.retry - 1 })));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function retry(_x3, _x4, _x5, _x6) {
        return _ref2.apply(this, arguments);
      }

      return retry;
    }()

    /**
     * Performs an HTTP request to the Kinto server.
     *
     * Resolves with an objet containing the following HTTP response properties:
     * - `{Number}  status`  The HTTP status code.
     * - `{Object}  json`    The JSON response body.
     * - `{Headers} headers` The response headers object; see the ES6 fetch() spec.
     *
     * @param  {String} url               The URL.
     * @param  {Object} [request={}]      The request object, passed to
     *     fetch() as its options object.
     * @param  {Object} [request.headers] The request headers object (default: {})
     * @param  {Object} [options={}]      Options for making the
     *     request
     * @param  {Number} [options.retry]   Number of retries (default: 0)
     * @return {Promise}
     */

  }, {
    key: "request",
    value: function () {
      var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(url) {
        var _request = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { headers: {} };

        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { retry: 0 };
        var response, status, headers, retryAfter;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // Ensure default request headers are always set
                _request.headers = _extends({}, HTTP.DEFAULT_REQUEST_HEADERS, _request.headers);
                // If a multipart body is provided, remove any custom Content-Type header as
                // the fetch() implementation will add the correct one for us.
                if (_request.body && typeof _request.body.append === "function") {
                  delete _request.headers["Content-Type"];
                }
                _request.mode = this.requestMode;

                _context3.next = 5;
                return this.timedFetch(url, _request);

              case 5:
                response = _context3.sent;
                status = response.status, headers = response.headers;


                this._checkForDeprecationHeader(headers);
                this._checkForBackoffHeader(status, headers);

                // Check if the server summons the client to retry after a while.
                retryAfter = this._checkForRetryAfterHeader(status, headers);
                // If number of allowed of retries is not exhausted, retry the same request.

                if (!(retryAfter && options.retry > 0)) {
                  _context3.next = 14;
                  break;
                }

                return _context3.abrupt("return", this.retry(url, retryAfter, _request, options));

              case 14:
                return _context3.abrupt("return", this.processResponse(response));

              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function request(_x7) {
        return _ref3.apply(this, arguments);
      }

      return request;
    }()
  }, {
    key: "_checkForDeprecationHeader",
    value: function _checkForDeprecationHeader(headers) {
      var alertHeader = headers.get("Alert");
      if (!alertHeader) {
        return;
      }
      var alert = void 0;
      try {
        alert = JSON.parse(alertHeader);
      } catch (err) {
        console.warn("Unable to parse Alert header message", alertHeader);
        return;
      }
      console.warn(alert.message, alert.url);
      this.events.emit("deprecated", alert);
    }
  }, {
    key: "_checkForBackoffHeader",
    value: function _checkForBackoffHeader(status, headers) {
      var backoffMs = void 0;
      var backoffSeconds = parseInt(headers.get("Backoff"), 10);
      if (backoffSeconds > 0) {
        backoffMs = new Date().getTime() + backoffSeconds * 1000;
      } else {
        backoffMs = 0;
      }
      this.events.emit("backoff", backoffMs);
    }
  }, {
    key: "_checkForRetryAfterHeader",
    value: function _checkForRetryAfterHeader(status, headers) {
      var retryAfter = headers.get("Retry-After");
      if (!retryAfter) {
        return;
      }
      var delay = parseInt(retryAfter, 10) * 1000;
      retryAfter = new Date().getTime() + delay;
      this.events.emit("retry-after", retryAfter);
      return delay;
    }
  }]);

  return HTTP;
}();

exports.default = HTTP;