"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _extendableBuiltin5(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

function _extendableBuiltin3(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

/**
 * Kinto server error code descriptors.
 * @type {Object}
 */
var ERROR_CODES = {
  104: "Missing Authorization Token",
  105: "Invalid Authorization Token",
  106: "Request body was not valid JSON",
  107: "Invalid request parameter",
  108: "Missing request parameter",
  109: "Invalid posted data",
  110: "Invalid Token / id",
  111: "Missing Token / id",
  112: "Content-Length header was not provided",
  113: "Request body too large",
  114: "Resource was created, updated or deleted meanwhile",
  115: "Method not allowed on this end point (hint: server may be readonly)",
  116: "Requested version not available on this server",
  117: "Client has sent too many requests",
  121: "Resource access is forbidden for this user",
  122: "Another resource violates constraint",
  201: "Service Temporary unavailable due to high load",
  202: "Service deprecated",
  999: "Internal Server Error"
};

exports.default = ERROR_CODES;

var NetworkTimeoutError = function (_extendableBuiltin2) {
  _inherits(NetworkTimeoutError, _extendableBuiltin2);

  function NetworkTimeoutError(url, options) {
    _classCallCheck(this, NetworkTimeoutError);

    var _this = _possibleConstructorReturn(this, (NetworkTimeoutError.__proto__ || Object.getPrototypeOf(NetworkTimeoutError)).call(this, "Timeout while trying to access " + url + " with " + JSON.stringify(options)));

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_this, NetworkTimeoutError);
    }

    _this.url = url;
    _this.options = options;
    return _this;
  }

  return NetworkTimeoutError;
}(_extendableBuiltin(Error));

var UnparseableResponseError = function (_extendableBuiltin4) {
  _inherits(UnparseableResponseError, _extendableBuiltin4);

  function UnparseableResponseError(response, body, error) {
    _classCallCheck(this, UnparseableResponseError);

    var status = response.status;

    var _this2 = _possibleConstructorReturn(this, (UnparseableResponseError.__proto__ || Object.getPrototypeOf(UnparseableResponseError)).call(this, "Response from server unparseable (HTTP " + (status || 0) + "; " + error + "): " + body));

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_this2, UnparseableResponseError);
    }

    _this2.status = status;
    _this2.response = response;
    _this2.stack = error.stack;
    _this2.error = error;
    return _this2;
  }

  return UnparseableResponseError;
}(_extendableBuiltin3(Error));

/**
 * "Error" subclass representing a >=400 response from the server.
 *
 * Whether or not this is an error depends on your application.
 *
 * The `json` field can be undefined if the server responded with an
 * empty response body. This shouldn't generally happen. Most "bad"
 * responses come with a JSON error description, or (if they're
 * fronted by a CDN or nginx or something) occasionally non-JSON
 * responses (which become UnparseableResponseErrors, above).
 */


var ServerResponse = function (_extendableBuiltin6) {
  _inherits(ServerResponse, _extendableBuiltin6);

  function ServerResponse(response, json) {
    _classCallCheck(this, ServerResponse);

    var status = response.status;
    var statusText = response.statusText;

    var errnoMsg = void 0;

    if (json) {
      // Try to fill in information from the JSON error.
      statusText = json.error || statusText;

      // Take errnoMsg from either ERROR_CODES or json.message.
      if (json.errno && json.errno in ERROR_CODES) {
        errnoMsg = ERROR_CODES[json.errno];
      } else if (json.message) {
        errnoMsg = json.message;
      }

      // If we had both ERROR_CODES and json.message, and they differ,
      // combine them.
      if (errnoMsg && json.message && json.message !== errnoMsg) {
        errnoMsg += " (" + json.message + ")";
      }
    }

    var message = "HTTP " + status + " " + statusText;
    if (errnoMsg) {
      message += ": " + errnoMsg;
    }

    var _this3 = _possibleConstructorReturn(this, (ServerResponse.__proto__ || Object.getPrototypeOf(ServerResponse)).call(this, message.trim()));

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_this3, ServerResponse);
    }

    _this3.response = response;
    _this3.data = json;
    return _this3;
  }

  return ServerResponse;
}(_extendableBuiltin5(Error));

exports.NetworkTimeoutError = NetworkTimeoutError;
exports.ServerResponse = ServerResponse;
exports.UnparseableResponseError = UnparseableResponseError;