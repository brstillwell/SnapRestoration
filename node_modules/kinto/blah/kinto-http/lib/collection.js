"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require("./utils");

var _requests = require("./requests");

var requests = _interopRequireWildcard(_requests);

var _endpoint = require("./endpoint");

var _endpoint2 = _interopRequireDefault(_endpoint);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Abstract representation of a selected collection.
 *
 */

var Collection = function () {
  /**
   * Constructor.
   *
   * @param  {KintoClient}  client            The client instance.
   * @param  {Bucket}       bucket            The bucket instance.
   * @param  {String}       name              The collection name.
   * @param  {Object}       [options={}]      The options object.
   * @param  {Object}       [options.headers] The headers object option.
   * @param  {Boolean}      [options.safe]    The safe option.
   */

  function Collection(client, bucket, name) {
    var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

    _classCallCheck(this, Collection);

    /**
     * @ignore
     */
    this.client = client;
    /**
     * @ignore
     */
    this.bucket = bucket;
    /**
     * The collection name.
     * @type {String}
     */
    this.name = name;

    /**
     * The default collection options object, embedding the default bucket ones.
     * @ignore
     * @type {Object}
     */
    this.options = _extends({}, this.bucket.options, options, {
      headers: _extends({}, this.bucket.options && this.bucket.options.headers, options.headers)
    });
    /**
     * @ignore
     */
    this._isBatch = !!options.batch;
  }

  /**
   * Merges passed request options with default bucket and collection ones, if
   * any.
   *
   * @private
   * @param  {Object} [options={}] The options to merge.
   * @return {Object}              The merged options.
   */


  _createClass(Collection, [{
    key: "_collOptions",
    value: function _collOptions() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var headers = _extends({}, this.options && this.options.headers, options.headers);
      return _extends({}, this.options, options, {
        headers: headers
      });
    }

    /**
     * Retrieves collection data.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getData",
    value: function getData() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var _collOptions2 = this._collOptions(options);

      var headers = _collOptions2.headers;

      return this.client.execute({
        path: (0, _endpoint2.default)("collection", this.bucket.name, this.name),
        headers: headers
      }).then(function (res) {
        return res.data;
      });
    }

    /**
     * Set collection data.
     * @param  {Object}   data                    The collection data object.
     * @param  {Object}   [options={}]            The options object.
     * @param  {Object}   [options.headers]       The headers object option.
     * @param  {Boolean}  [options.safe]          The safe option.
     * @param  {Boolean}  [options.patch]         The patch option.
     * @param  {Number}   [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(data)) {
        throw new Error("A collection object is required.");
      }
      var reqOptions = this._collOptions(options);
      var permissions = reqOptions.permissions;


      var path = (0, _endpoint2.default)("collection", this.bucket.name, this.name);
      var request = requests.updateRequest(path, { data: data, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Retrieves the list of permissions for this collection.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getPermissions",
    value: function getPermissions() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var _collOptions3 = this._collOptions(options);

      var headers = _collOptions3.headers;

      return this.client.execute({
        path: (0, _endpoint2.default)("collection", this.bucket.name, this.name),
        headers: headers
      }).then(function (res) {
        return res.permissions;
      });
    }

    /**
     * Replaces all existing collection permissions with the ones provided.
     *
     * @param  {Object}   permissions             The permissions object.
     * @param  {Object}   [options={}]            The options object
     * @param  {Object}   [options.headers]       The headers object option.
     * @param  {Boolean}  [options.safe]          The safe option.
     * @param  {Number}   [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "setPermissions",
    value: function setPermissions(permissions) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(permissions)) {
        throw new Error("A permissions object is required.");
      }
      var reqOptions = this._collOptions(options);
      var path = (0, _endpoint2.default)("collection", this.bucket.name, this.name);
      var data = { last_modified: options.last_modified };
      var request = requests.updateRequest(path, { data: data, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Creates a record in current collection.
     *
     * @param  {Object}  record            The record to create.
     * @param  {Object}  [options={}]      The options object.
     * @param  {Object}  [options.headers] The headers object option.
     * @param  {Boolean} [options.safe]    The safe option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "createRecord",
    value: function createRecord(record) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var reqOptions = this._collOptions(options);
      var permissions = reqOptions.permissions;

      var path = (0, _endpoint2.default)("record", this.bucket.name, this.name, record.id);
      var request = requests.createRequest(path, { data: record, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Updates a record in current collection.
     *
     * @param  {Object}  record                  The record to update.
     * @param  {Object}  [options={}]            The options object.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Number}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "updateRecord",
    value: function updateRecord(record) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(record)) {
        throw new Error("A record object is required.");
      }
      if (!record.id) {
        throw new Error("A record id is required.");
      }
      var reqOptions = this._collOptions(options);
      var permissions = reqOptions.permissions;

      var path = (0, _endpoint2.default)("record", this.bucket.name, this.name, record.id);
      var request = requests.updateRequest(path, { data: record, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Deletes a record from the current collection.
     *
     * @param  {Object|String} record                  The record to delete.
     * @param  {Object}        [options={}]            The options object.
     * @param  {Object}        [options.headers]       The headers object option.
     * @param  {Boolean}       [options.safe]          The safe option.
     * @param  {Number}        [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteRecord",
    value: function deleteRecord(record) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var recordObj = (0, _utils.toDataBody)(record);
      if (!recordObj.id) {
        throw new Error("A record id is required.");
      }
      var id = recordObj.id;
      var last_modified = recordObj.last_modified;

      var reqOptions = this._collOptions(_extends({ last_modified: last_modified }, options));
      var path = (0, _endpoint2.default)("record", this.bucket.name, this.name, id);
      var request = requests.deleteRequest(path, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Retrieves a record from the current collection.
     *
     * @param  {String} id                The record id to retrieve.
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getRecord",
    value: function getRecord(id) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      return this.client.execute(_extends({
        path: (0, _endpoint2.default)("record", this.bucket.name, this.name, id)
      }, this._collOptions(options)));
    }

    /**
     * Lists records from the current collection.
     *
     * Sorting is done by passing a `sort` string option:
     *
     * - The field to order the results by, prefixed with `-` for descending.
     * Default: `-last_modified`.
     *
     * @see http://kinto.readthedocs.io/en/stable/core/api/resource.html#sorting
     *
     * Filtering is done by passing a `filters` option object:
     *
     * - `{fieldname: "value"}`
     * - `{min_fieldname: 4000}`
     * - `{in_fieldname: "1,2,3"}`
     * - `{not_fieldname: 0}`
     * - `{exclude_fieldname: "0,1"}`
     *
     * @see http://kinto.readthedocs.io/en/stable/core/api/resource.html#filtering
     *
     * Paginating is done by passing a `limit` option, then calling the `next()`
     * method from the resolved result object to fetch the next page, if any.
     *
     * @param  {Object}   [options={}]                    The options object.
     * @param  {Object}   [options.headers]               The headers object option.
     * @param  {Object}   [options.filters=[]]            The filters object.
     * @param  {String}   [options.sort="-last_modified"] The sort field.
     * @param  {String}   [options.limit=null]            The limit field.
     * @param  {String}   [options.pages=1]               The number of result pages to aggregate.
     * @param  {Number}   [options.since=null]            Only retrieve records modified since the provided timestamp.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "listRecords",
    value: function listRecords() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var http = this.client.http;

      var _sort$options = _extends({
        sort: "-last_modified"
      }, options);

      var sort = _sort$options.sort;
      var filters = _sort$options.filters;
      var limit = _sort$options.limit;
      var pages = _sort$options.pages;
      var since = _sort$options.since;
      // Safety/Consistency check on ETag value.

      if (since && typeof since !== "string") {
        throw new Error("Invalid value for since (" + since + "), should be ETag value.");
      }
      var collHeaders = this.options.headers;
      var path = (0, _endpoint2.default)("record", this.bucket.name, this.name);
      var querystring = (0, _utils.qsify)(_extends({}, filters, {
        _sort: sort,
        _limit: limit,
        _since: since
      }));
      var results = [],
          current = 0;

      var next = function next(nextPage) {
        if (!nextPage) {
          throw new Error("Pagination exhausted.");
        }
        return processNextPage(nextPage);
      };

      var processNextPage = function processNextPage(nextPage) {
        return http.request(nextPage, { headers: collHeaders }).then(handleResponse);
      };

      var pageResults = function pageResults(results, nextPage, etag) {
        // ETag string is supposed to be opaque and stored «as-is».
        // ETag header values are quoted (because of * and W/"foo").
        return {
          last_modified: etag ? etag.replace(/"/g, "") : etag,
          data: results,
          next: next.bind(null, nextPage)
        };
      };

      var handleResponse = function handleResponse(_ref) {
        var headers = _ref.headers;
        var json = _ref.json;

        var nextPage = headers.get("Next-Page");
        var etag = headers.get("ETag");
        if (!pages) {
          return pageResults(json.data, nextPage, etag);
        }
        // Aggregate new results with previous ones
        results = results.concat(json.data);
        current += 1;
        if (current >= pages || !nextPage) {
          // Pagination exhausted
          return pageResults(results, nextPage, etag);
        }
        // Follow next page
        return processNextPage(nextPage);
      };

      return this.client.execute(_extends({
        path: path + "?" + querystring
      }, this._collOptions(options)), { raw: true }).then(handleResponse);
    }

    /**
     * Performs batch operations at the current collection level.
     *
     * @param  {Function} fn                   The batch operation function.
     * @param  {Object}   [options={}]         The options object.
     * @param  {Object}   [options.headers]    The headers object option.
     * @param  {Boolean}  [options.safe]       The safe option.
     * @param  {Boolean}  [options.aggregate]  Produces a grouped result object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "batch",
    value: function batch(fn) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var reqOptions = this._collOptions(options);
      return this.client.batch(fn, _extends({}, reqOptions, {
        bucket: this.bucket.name,
        collection: this.name
      }));
    }
  }]);

  return Collection;
}();

exports.default = Collection;