(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.KintoClient = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.
require('whatwg-fetch');
module.exports = self.fetch.bind(self);

},{"whatwg-fetch":3}],3:[function(require,module,exports){
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    reader.readAsText(blob)
    return fileReaderReady(reader)
  }

  var support = {
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  function Body() {
    this.bodyUsed = false


    this._initBody = function(body) {
      this._bodyInit = body
      if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (!body) {
        this._bodyText = ''
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }

      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      }
    } else {
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = input
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = xhr.getAllResponseHeaders().trim().split('\n')
    pairs.forEach(function(header) {
      var split = header.trim().split(':')
      var key = split.shift().trim()
      var value = split.join(':').trim()
      head.append(key, value)
    })
    return head
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = options.status
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = options.statusText
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input
      } else {
        request = new Request(input, init)
      }

      var xhr = new XMLHttpRequest()

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL')
        }

        return;
      }

      xhr.onload = function() {
        var status = (xhr.status === 1223) ? 204 : xhr.status
        if (status < 100 || status > 599) {
          reject(new TypeError('Network request failed'))
          return
        }
        var options = {
          status: status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SUPPORTED_PROTOCOL_VERSION = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _desc, _value, _class;

var _utils = require("./utils");

var _http = require("./http");

var _http2 = _interopRequireDefault(_http);

var _endpoint = require("./endpoint");

var _endpoint2 = _interopRequireDefault(_endpoint);

var _requests = require("./requests");

var requests = _interopRequireWildcard(_requests);

var _batch = require("./batch");

var _bucket = require("./bucket");

var _bucket2 = _interopRequireDefault(_bucket);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * Currently supported protocol version.
 * @type {String}
 */
var SUPPORTED_PROTOCOL_VERSION = exports.SUPPORTED_PROTOCOL_VERSION = "v1";

/**
 * High level HTTP client for the Kinto API.
 *
 * @example
 * const client = new KintoClient("https://kinto.dev.mozaws.net/v1");
 * client.bucket("default")
*    .collection("my-blog")
*    .createRecord({title: "First article"})
 *   .then(console.log.bind(console))
 *   .catch(console.error.bind(console));
 */
var KintoClientBase = (_dec = (0, _utils.nobatch)("This operation is not supported within a batch operation."), _dec2 = (0, _utils.nobatch)("This operation is not supported within a batch operation."), _dec3 = (0, _utils.nobatch)("This operation is not supported within a batch operation."), _dec4 = (0, _utils.nobatch)("This operation is not supported within a batch operation."), _dec5 = (0, _utils.nobatch)("Can't use batch within a batch!"), _dec6 = (0, _utils.support)("1.4", "2.0"), (_class = function () {
  /**
   * Constructor.
   *
   * @param  {String}       remote  The remote URL.
   * @param  {Object}       [options={}]                  The options object.
   * @param  {Boolean}      [options.safe=true]           Adds concurrency headers to every requests.
   * @param  {EventEmitter} [options.events=EventEmitter] The events handler instance.
   * @param  {Object}       [options.headers={}]          The key-value headers to pass to each request.
   * @param  {String}       [options.bucket="default"]    The default bucket to use.
   * @param  {String}       [options.requestMode="cors"]  The HTTP request mode (from ES6 fetch spec).
   * @param  {Number}       [options.timeout=5000]        The requests timeout in ms.
   */

  function KintoClientBase(remote) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, KintoClientBase);

    if (typeof remote !== "string" || !remote.length) {
      throw new Error("Invalid remote URL: " + remote);
    }
    if (remote[remote.length - 1] === "/") {
      remote = remote.slice(0, -1);
    }
    this._backoffReleaseTime = null;

    /**
     * Default request options container.
     * @private
     * @type {Object}
     */
    this.defaultReqOptions = {
      bucket: options.bucket || "default",
      headers: options.headers || {},
      safe: !!options.safe
    };

    this._options = options;
    this._requests = [];
    this._isBatch = !!options.batch;

    // public properties
    /**
     * The remote server base URL.
     * @type {String}
     */
    this.remote = remote;
    /**
     * Current server information.
     * @ignore
     * @type {Object|null}
     */
    this.serverInfo = null;
    /**
     * The event emitter instance. Should comply with the `EventEmitter`
     * interface.
     * @ignore
     * @type {Class}
     */
    this.events = options.events;

    var requestMode = options.requestMode;
    var timeout = options.timeout;
    /**
     * The HTTP instance.
     * @ignore
     * @type {HTTP}
     */

    this.http = new _http2.default(this.events, { requestMode: requestMode, timeout: timeout });
    this._registerHTTPEvents();
  }

  /**
   * The remote endpoint base URL. Setting the value will also extract and
   * validate the version.
   * @type {String}
   */


  _createClass(KintoClientBase, [{
    key: "_registerHTTPEvents",


    /**
     * Registers HTTP events.
     * @private
     */
    value: function _registerHTTPEvents() {
      var _this = this;

      // Prevent registering event from a batch client instance
      if (!this._isBatch) {
        this.events.on("backoff", function (backoffMs) {
          _this._backoffReleaseTime = backoffMs;
        });
      }
    }

    /**
     * Retrieve a bucket object to perform operations on it.
     *
     * @param  {String}  name              The bucket name.
     * @param  {Object}  [options={}]      The request options.
     * @param  {Boolean} [options.safe]    The resulting safe option.
     * @param  {String}  [options.bucket]  The resulting bucket name option.
     * @param  {Object}  [options.headers] The extended headers object option.
     * @return {Bucket}
     */

  }, {
    key: "bucket",
    value: function bucket(name) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var bucketOptions = (0, _utils.omit)(this._getRequestOptions(options), "bucket");
      return new _bucket2.default(this, name, bucketOptions);
    }

    /**
     * Generates a request options object, deeply merging the client configured
     * defaults with the ones provided as argument.
     *
     * Note: Headers won't be overriden but merged with instance default ones.
     *
     * @private
     * @param    {Object}  [options={}]      The request options.
     * @property {Boolean} [options.safe]    The resulting safe option.
     * @property {String}  [options.bucket]  The resulting bucket name option.
     * @property {Object}  [options.headers] The extended headers object option.
     * @return   {Object}
     */

  }, {
    key: "_getRequestOptions",
    value: function _getRequestOptions() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return _extends({}, this.defaultReqOptions, options, {
        batch: this._isBatch,
        // Note: headers should never be overriden but extended
        headers: _extends({}, this.defaultReqOptions.headers, options.headers)
      });
    }

    /**
     * Retrieves server information and persist them locally. This operation is
     * usually performed a single time during the instance lifecycle.
     *
     * @param  {Object}  [options={}] The request options.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchServerInfo",
    value: function fetchServerInfo() {
      var _this2 = this;

      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      if (this.serverInfo) {
        return Promise.resolve(this.serverInfo);
      }
      return this.http.request(this.remote + (0, _endpoint2.default)("root"), {
        headers: _extends({}, this.defaultReqOptions.headers, options.headers)
      }).then(function (_ref) {
        var json = _ref.json;

        _this2.serverInfo = json;
        return _this2.serverInfo;
      });
    }

    /**
     * Retrieves Kinto server settings.
     *
     * @param  {Object}  [options={}] The request options.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchServerSettings",
    value: function fetchServerSettings() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.fetchServerInfo(options).then(function (_ref2) {
        var settings = _ref2.settings;
        return settings;
      });
    }

    /**
     * Retrieve server capabilities information.
     *
     * @param  {Object}  [options={}] The request options.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchServerCapabilities",
    value: function fetchServerCapabilities() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.fetchServerInfo(options).then(function (_ref3) {
        var capabilities = _ref3.capabilities;
        return capabilities;
      });
    }

    /**
     * Retrieve authenticated user information.
     *
     * @param  {Object}  [options={}] The request options.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchUser",
    value: function fetchUser() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.fetchServerInfo(options).then(function (_ref4) {
        var user = _ref4.user;
        return user;
      });
    }

    /**
     * Retrieve authenticated user information.
     *
     * @param  {Object}  [options={}] The request options.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchHTTPApiVersion",
    value: function fetchHTTPApiVersion() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.fetchServerInfo(options).then(function (_ref5) {
        var http_api_version = _ref5.http_api_version;

        return http_api_version;
      });
    }

    /**
     * Process batch requests, chunking them according to the batch_max_requests
     * server setting when needed.
     *
     * @param  {Array}  requests     The list of batch subrequests to perform.
     * @param  {Object} [options={}] The options object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "_batchRequests",
    value: function _batchRequests(requests) {
      var _this3 = this;

      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var headers = _extends({}, this.defaultReqOptions.headers, options.headers);
      if (!requests.length) {
        return Promise.resolve([]);
      }
      return this.fetchServerSettings().then(function (serverSettings) {
        var maxRequests = serverSettings["batch_max_requests"];
        if (maxRequests && requests.length > maxRequests) {
          var chunks = (0, _utils.partition)(requests, maxRequests);
          return (0, _utils.pMap)(chunks, function (chunk) {
            return _this3._batchRequests(chunk, options);
          });
        }
        return _this3.execute({
          path: (0, _endpoint2.default)("batch"),
          method: "POST",
          headers: headers,
          body: {
            defaults: { headers: headers },
            requests: requests
          }
        })
        // we only care about the responses
        .then(function (_ref6) {
          var responses = _ref6.responses;
          return responses;
        });
      });
    }

    /**
     * Sends batch requests to the remote server.
     *
     * Note: Reserved for internal use only.
     *
     * @ignore
     * @param  {Function} fn                        The function to use for describing batch ops.
     * @param  {Object}   [options={}]              The options object.
     * @param  {Boolean}  [options.safe]            The safe option.
     * @param  {String}   [options.bucket]          The bucket name option.
     * @param  {Object}   [options.headers]         The headers object option.
     * @param  {Boolean}  [options.aggregate=false] Produces an aggregated result object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "batch",
    value: function batch(fn) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var rootBatch = new KintoClientBase(this.remote, _extends({}, this._options, this._getRequestOptions(options), {
        batch: true
      }));
      var bucketBatch = void 0,
          collBatch = void 0;
      if (options.bucket) {
        bucketBatch = rootBatch.bucket(options.bucket);
        if (options.collection) {
          collBatch = bucketBatch.collection(options.collection);
        }
      }
      var batchClient = collBatch || bucketBatch || rootBatch;
      try {
        fn(batchClient);
      } catch (err) {
        return Promise.reject(err);
      }
      return this._batchRequests(rootBatch._requests, options).then(function (responses) {
        if (options.aggregate) {
          return (0, _batch.aggregate)(responses, rootBatch._requests);
        }
        return responses;
      });
    }

    /**
     * Executes an atomic HTTP request.
     *
     * @private
     * @param  {Object}  request             The request object.
     * @param  {Object}  [options={}]        The options object.
     * @param  {Boolean} [options.raw=false] If true, resolve with full response object, including json body and headers instead of just json.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "execute",
    value: function execute(request) {
      var _this4 = this;

      var options = arguments.length <= 1 || arguments[1] === undefined ? { raw: false } : arguments[1];

      // If we're within a batch, add the request to the stack to send at once.
      if (this._isBatch) {
        this._requests.push(request);
        // Resolve with a message in case people attempt at consuming the result
        // from within a batch operation.
        var msg = "This result is generated from within a batch " + "operation and should not be consumed.";
        return Promise.resolve(options.raw ? { json: msg } : msg);
      }
      var promise = this.fetchServerSettings().then(function (_) {
        return _this4.http.request(_this4.remote + request.path, _extends({}, request, {
          body: JSON.stringify(request.body)
        }));
      });
      return options.raw ? promise : promise.then(function (_ref7) {
        var json = _ref7.json;
        return json;
      });
    }

    /**
     * Retrieves the list of buckets.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @return {Promise<Object[], Error>}
     */

  }, {
    key: "listBuckets",
    value: function listBuckets() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.execute({
        path: (0, _endpoint2.default)("bucket"),
        headers: _extends({}, this.defaultReqOptions.headers, options.headers)
      });
    }

    /**
     * Creates a new bucket on the server.
     *
     * @param  {String}   id                The bucket name.
     * @param  {Object}   [options={}]      The options object.
     * @param  {Boolean}  [options.data]    The bucket data option.
     * @param  {Boolean}  [options.safe]    The safe option.
     * @param  {Object}   [options.headers] The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "createBucket",
    value: function createBucket(id) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!id) {
        throw new Error("A bucket id is required.");
      }
      // Note that we simply ignore any "bucket" option passed here, as the one
      // we're interested in is the one provided as a required argument.
      var reqOptions = this._getRequestOptions(options);
      var _reqOptions$data = reqOptions.data;
      var data = _reqOptions$data === undefined ? {} : _reqOptions$data;
      var permissions = reqOptions.permissions;

      data.id = id;
      var path = (0, _endpoint2.default)("bucket", id);
      return this.execute(requests.createRequest(path, { data: data, permissions: permissions }, reqOptions));
    }

    /**
     * Deletes a bucket from the server.
     *
     * @ignore
     * @param  {Object|String} bucket                  The bucket to delete.
     * @param  {Object}        [options={}]            The options object.
     * @param  {Boolean}       [options.safe]          The safe option.
     * @param  {Object}        [options.headers]       The headers object option.
     * @param  {Number}        [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteBucket",
    value: function deleteBucket(bucket) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var bucketObj = (0, _utils.toDataBody)(bucket);
      if (!bucketObj.id) {
        throw new Error("A bucket id is required.");
      }
      var path = (0, _endpoint2.default)("bucket", bucketObj.id);
      var _bucketObj = { bucketObj: bucketObj };
      var last_modified = _bucketObj.last_modified;

      var reqOptions = this._getRequestOptions(_extends({ last_modified: last_modified }, options));
      return this.execute(requests.deleteRequest(path, reqOptions));
    }

    /**
     * Deletes all buckets on the server.
     *
     * @ignore
     * @param  {Object}  [options={}]            The options object.
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Number}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteBuckets",
    value: function deleteBuckets() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var reqOptions = this._getRequestOptions(options);
      var path = (0, _endpoint2.default)("bucket");
      return this.execute(requests.deleteRequest(path, reqOptions));
    }
  }, {
    key: "remote",
    get: function get() {
      return this._remote;
    }

    /**
     * @ignore
     */
    ,
    set: function set(url) {
      var version = void 0;
      try {
        version = url.match(/\/(v\d+)\/?$/)[1];
      } catch (err) {
        throw new Error("The remote URL must contain the version: " + url);
      }
      if (version !== SUPPORTED_PROTOCOL_VERSION) {
        throw new Error("Unsupported protocol version: " + version);
      }
      this._remote = url;
      this._version = version;
    }

    /**
     * The current server protocol version, eg. `v1`.
     * @type {String}
     */

  }, {
    key: "version",
    get: function get() {
      return this._version;
    }

    /**
     * Backoff remaining time, in milliseconds. Defaults to zero if no backoff is
     * ongoing.
     *
     * @type {Number}
     */

  }, {
    key: "backoff",
    get: function get() {
      var currentTime = new Date().getTime();
      if (this._backoffReleaseTime && currentTime < this._backoffReleaseTime) {
        return this._backoffReleaseTime - currentTime;
      }
      return 0;
    }
  }]);

  return KintoClientBase;
}(), (_applyDecoratedDescriptor(_class.prototype, "fetchServerSettings", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "fetchServerSettings"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "fetchServerCapabilities", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, "fetchServerCapabilities"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "fetchUser", [_dec3], Object.getOwnPropertyDescriptor(_class.prototype, "fetchUser"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "fetchHTTPApiVersion", [_dec4], Object.getOwnPropertyDescriptor(_class.prototype, "fetchHTTPApiVersion"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "batch", [_dec5], Object.getOwnPropertyDescriptor(_class.prototype, "batch"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "deleteBuckets", [_dec6], Object.getOwnPropertyDescriptor(_class.prototype, "deleteBuckets"), _class.prototype)), _class));
exports.default = KintoClientBase;

},{"./batch":5,"./bucket":6,"./endpoint":8,"./http":10,"./requests":12,"./utils":13}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.aggregate = aggregate;
/**
 * Exports batch responses as a result object.
 *
 * @private
 * @param  {Array} responses The batch subrequest responses.
 * @param  {Array} requests  The initial issued requests.
 * @return {Object}
 */
function aggregate() {
  var responses = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
  var requests = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

  if (responses.length !== requests.length) {
    throw new Error("Responses length should match requests one.");
  }
  var results = {
    errors: [],
    published: [],
    conflicts: [],
    skipped: []
  };
  return responses.reduce(function (acc, response, index) {
    var status = response.status;

    if (status >= 200 && status < 400) {
      acc.published.push(response.body);
    } else if (status === 404) {
      acc.skipped.push(response.body);
    } else if (status === 412) {
      acc.conflicts.push({
        // XXX: specifying the type is probably superfluous
        type: "outgoing",
        local: requests[index].body,
        remote: response.body.details && response.body.details.existing || null
      });
    } else {
      acc.errors.push({
        path: response.path,
        sent: requests[index],
        error: response.body
      });
    }
    return acc;
  }, results);
}

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require("./utils");

var _collection = require("./collection");

var _collection2 = _interopRequireDefault(_collection);

var _requests = require("./requests");

var requests = _interopRequireWildcard(_requests);

var _endpoint = require("./endpoint");

var _endpoint2 = _interopRequireDefault(_endpoint);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Abstract representation of a selected bucket.
 *
 */

var Bucket = function () {
  /**
   * Constructor.
   *
   * @param  {KintoClient} client            The client instance.
   * @param  {String}      name              The bucket name.
   * @param  {Object}      [options={}]      The headers object option.
   * @param  {Object}      [options.headers] The headers object option.
   * @param  {Boolean}     [options.safe]    The safe option.
   */

  function Bucket(client, name) {
    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, Bucket);

    /**
     * @ignore
     */
    this.client = client;
    /**
     * The bucket name.
     * @type {String}
     */
    this.name = name;
    /**
     * The default options object.
     * @ignore
     * @type {Object}
     */
    this.options = options;
    /**
     * @ignore
     */
    this._isBatch = !!options.batch;
  }

  /**
   * Merges passed request options with default bucket ones, if any.
   *
   * @private
   * @param  {Object} [options={}] The options to merge.
   * @return {Object}              The merged options.
   */


  _createClass(Bucket, [{
    key: "_bucketOptions",
    value: function _bucketOptions() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var headers = _extends({}, this.options && this.options.headers, options.headers);
      return _extends({}, this.options, options, {
        headers: headers,
        bucket: this.name,
        batch: this._isBatch
      });
    }

    /**
     * Selects a collection.
     *
     * @param  {String}  name              The collection name.
     * @param  {Object}  [options={}]      The options object.
     * @param  {Object}  [options.headers] The headers object option.
     * @param  {Boolean} [options.safe]    The safe option.
     * @return {Collection}
     */

  }, {
    key: "collection",
    value: function collection(name) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      return new _collection2.default(this.client, this, name, this._bucketOptions(options));
    }

    /**
     * Retrieves bucket data.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getData",
    value: function getData() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.client.execute({
        path: (0, _endpoint2.default)("bucket", this.name),
        headers: _extends({}, this.options.headers, options.headers)
      }).then(function (res) {
        return res.data;
      });
    }

    /**
     * Set bucket data.
     * @param  {Object}  data                    The bucket data object.
     * @param  {Object}  [options={}]            The options object.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Boolean} [options.patch]         The patch option.
     * @param  {Number}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(data)) {
        throw new Error("A bucket object is required.");
      }

      var bucket = _extends({}, data, { id: this.name });

      // For default bucket, we need to drop the id from the data object.
      // Bug in Kinto < 3.1.1
      var bucketId = bucket.id;
      if (bucket.id === "default") {
        delete bucket.id;
      }

      var path = (0, _endpoint2.default)("bucket", bucketId);
      var permissions = options.permissions;

      var reqOptions = _extends({}, this._bucketOptions(options));
      var request = requests.updateRequest(path, { data: bucket, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Retrieves the list of collections in the current bucket.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @return {Promise<Array<Object>, Error>}
     */

  }, {
    key: "listCollections",
    value: function listCollections() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.client.execute({
        path: (0, _endpoint2.default)("collection", this.name),
        headers: _extends({}, this.options.headers, options.headers)
      });
    }

    /**
     * Creates a new collection in current bucket.
     *
     * @param  {String|undefined}  id          The collection id.
     * @param  {Object}  [options={}]          The options object.
     * @param  {Boolean} [options.safe]        The safe option.
     * @param  {Object}  [options.headers]     The headers object option.
     * @param  {Object}  [options.permissions] The permissions object.
     * @param  {Object}  [options.data]        The data object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "createCollection",
    value: function createCollection(id) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var reqOptions = this._bucketOptions(options);
      var permissions = reqOptions.permissions;
      var _reqOptions$data = reqOptions.data;
      var data = _reqOptions$data === undefined ? {} : _reqOptions$data;

      data.id = id;
      var path = (0, _endpoint2.default)("collection", this.name, id);
      var request = requests.createRequest(path, { data: data, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Deletes a collection from the current bucket.
     *
     * @param  {Object|String} collection              The collection to delete.
     * @param  {Object}        [options={}]            The options object.
     * @param  {Object}        [options.headers]       The headers object option.
     * @param  {Boolean}       [options.safe]          The safe option.
     * @param  {Number}        [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteCollection",
    value: function deleteCollection(collection) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var collectionObj = (0, _utils.toDataBody)(collection);
      if (!collectionObj.id) {
        throw new Error("A collection id is required.");
      }
      var id = collectionObj.id;
      var last_modified = collectionObj.last_modified;

      var reqOptions = this._bucketOptions(_extends({ last_modified: last_modified }, options));
      var path = (0, _endpoint2.default)("collection", this.name, id);
      var request = requests.deleteRequest(path, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Retrieves the list of groups in the current bucket.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @return {Promise<Array<Object>, Error>}
     */

  }, {
    key: "listGroups",
    value: function listGroups() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.client.execute({
        path: (0, _endpoint2.default)("group", this.name),
        headers: _extends({}, this.options.headers, options.headers)
      });
    }

    /**
     * Creates a new group in current bucket.
     *
     * @param  {String} id                The group id.
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getGroup",
    value: function getGroup(id) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      return this.client.execute({
        path: (0, _endpoint2.default)("group", this.name, id),
        headers: _extends({}, this.options.headers, options.headers)
      });
    }

    /**
     * Creates a new group in current bucket.
     *
     * @param  {String|undefined}  id                    The group id.
     * @param  {Array<String>}     [members=[]]          The list of principals.
     * @param  {Object}            [options={}]          The options object.
     * @param  {Object}            [options.data]        The data object.
     * @param  {Object}            [options.permissions] The permissions object.
     * @param  {Boolean}           [options.safe]        The safe option.
     * @param  {Object}            [options.headers]     The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "createGroup",
    value: function createGroup(id) {
      var members = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      var reqOptions = this._bucketOptions(options);
      var data = _extends({}, options.data, {
        id: id,
        members: members
      });
      var path = (0, _endpoint2.default)("group", this.name, id);
      var permissions = options.permissions;

      var request = requests.createRequest(path, { data: data, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Updates an existing group in current bucket.
     *
     * @param  {Object}  group                   The group object.
     * @param  {Object}  [options={}]            The options object.
     * @param  {Object}  [options.data]          The data object.
     * @param  {Object}  [options.permissions]   The permissions object.
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Number}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "updateGroup",
    value: function updateGroup(group) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(group)) {
        throw new Error("A group object is required.");
      }
      if (!group.id) {
        throw new Error("A group id is required.");
      }
      var reqOptions = this._bucketOptions(options);
      var data = _extends({}, options.data, group);
      var path = (0, _endpoint2.default)("group", this.name, group.id);
      var permissions = options.permissions;

      var request = requests.updateRequest(path, { data: data, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Deletes a group from the current bucket.
     *
     * @param  {Object|String} group                   The group to delete.
     * @param  {Object}        [options={}]            The options object.
     * @param  {Object}        [options.headers]       The headers object option.
     * @param  {Boolean}       [options.safe]          The safe option.
     * @param  {Number}        [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteGroup",
    value: function deleteGroup(group) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var groupObj = (0, _utils.toDataBody)(group);
      var id = groupObj.id;
      var last_modified = groupObj.last_modified;

      var reqOptions = this._bucketOptions(_extends({ last_modified: last_modified }, options));
      var path = (0, _endpoint2.default)("group", this.name, id);
      var request = requests.deleteRequest(path, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Retrieves the list of permissions for this bucket.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getPermissions",
    value: function getPermissions() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.client.execute({
        path: (0, _endpoint2.default)("bucket", this.name),
        headers: _extends({}, this.options.headers, options.headers)
      }).then(function (res) {
        return res.permissions;
      });
    }

    /**
     * Replaces all existing bucket permissions with the ones provided.
     *
     * @param  {Object}  permissions             The permissions object.
     * @param  {Object}  [options={}]            The options object
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Object}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "setPermissions",
    value: function setPermissions(permissions) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(permissions)) {
        throw new Error("A permissions object is required.");
      }
      var path = (0, _endpoint2.default)("bucket", this.name);
      var reqOptions = _extends({}, this._bucketOptions(options));
      var last_modified = options.last_modified;

      var data = { last_modified: last_modified };
      var request = requests.updateRequest(path, { data: data, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Performs batch operations at the current bucket level.
     *
     * @param  {Function} fn                   The batch operation function.
     * @param  {Object}   [options={}]         The options object.
     * @param  {Object}   [options.headers]    The headers object option.
     * @param  {Boolean}  [options.safe]       The safe option.
     * @param  {Boolean}  [options.aggregate]  Produces a grouped result object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "batch",
    value: function batch(fn) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      return this.client.batch(fn, this._bucketOptions(options));
    }
  }]);

  return Bucket;
}();

exports.default = Bucket;

},{"./collection":7,"./endpoint":8,"./requests":12,"./utils":13}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require("./utils");

var _requests = require("./requests");

var requests = _interopRequireWildcard(_requests);

var _endpoint = require("./endpoint");

var _endpoint2 = _interopRequireDefault(_endpoint);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Abstract representation of a selected collection.
 *
 */

var Collection = function () {
  /**
   * Constructor.
   *
   * @param  {KintoClient}  client            The client instance.
   * @param  {Bucket}       bucket            The bucket instance.
   * @param  {String}       name              The collection name.
   * @param  {Object}       [options={}]      The options object.
   * @param  {Object}       [options.headers] The headers object option.
   * @param  {Boolean}      [options.safe]    The safe option.
   */

  function Collection(client, bucket, name) {
    var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

    _classCallCheck(this, Collection);

    /**
     * @ignore
     */
    this.client = client;
    /**
     * @ignore
     */
    this.bucket = bucket;
    /**
     * The collection name.
     * @type {String}
     */
    this.name = name;

    /**
     * The default collection options object, embedding the default bucket ones.
     * @ignore
     * @type {Object}
     */
    this.options = _extends({}, this.bucket.options, options, {
      headers: _extends({}, this.bucket.options && this.bucket.options.headers, options.headers)
    });
    /**
     * @ignore
     */
    this._isBatch = !!options.batch;
  }

  /**
   * Merges passed request options with default bucket and collection ones, if
   * any.
   *
   * @private
   * @param  {Object} [options={}] The options to merge.
   * @return {Object}              The merged options.
   */


  _createClass(Collection, [{
    key: "_collOptions",
    value: function _collOptions() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var headers = _extends({}, this.options && this.options.headers, options.headers);
      return _extends({}, this.options, options, {
        headers: headers
      });
    }

    /**
     * Retrieves collection data.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getData",
    value: function getData() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var _collOptions2 = this._collOptions(options);

      var headers = _collOptions2.headers;

      return this.client.execute({
        path: (0, _endpoint2.default)("collection", this.bucket.name, this.name),
        headers: headers
      }).then(function (res) {
        return res.data;
      });
    }

    /**
     * Set collection data.
     * @param  {Object}   data                    The collection data object.
     * @param  {Object}   [options={}]            The options object.
     * @param  {Object}   [options.headers]       The headers object option.
     * @param  {Boolean}  [options.safe]          The safe option.
     * @param  {Boolean}  [options.patch]         The patch option.
     * @param  {Number}   [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(data)) {
        throw new Error("A collection object is required.");
      }
      var reqOptions = this._collOptions(options);
      var permissions = reqOptions.permissions;


      var path = (0, _endpoint2.default)("collection", this.bucket.name, this.name);
      var request = requests.updateRequest(path, { data: data, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Retrieves the list of permissions for this collection.
     *
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getPermissions",
    value: function getPermissions() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var _collOptions3 = this._collOptions(options);

      var headers = _collOptions3.headers;

      return this.client.execute({
        path: (0, _endpoint2.default)("collection", this.bucket.name, this.name),
        headers: headers
      }).then(function (res) {
        return res.permissions;
      });
    }

    /**
     * Replaces all existing collection permissions with the ones provided.
     *
     * @param  {Object}   permissions             The permissions object.
     * @param  {Object}   [options={}]            The options object
     * @param  {Object}   [options.headers]       The headers object option.
     * @param  {Boolean}  [options.safe]          The safe option.
     * @param  {Number}   [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "setPermissions",
    value: function setPermissions(permissions) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(permissions)) {
        throw new Error("A permissions object is required.");
      }
      var reqOptions = this._collOptions(options);
      var path = (0, _endpoint2.default)("collection", this.bucket.name, this.name);
      var data = { last_modified: options.last_modified };
      var request = requests.updateRequest(path, { data: data, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Creates a record in current collection.
     *
     * @param  {Object}  record            The record to create.
     * @param  {Object}  [options={}]      The options object.
     * @param  {Object}  [options.headers] The headers object option.
     * @param  {Boolean} [options.safe]    The safe option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "createRecord",
    value: function createRecord(record) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var reqOptions = this._collOptions(options);
      var permissions = reqOptions.permissions;

      var path = (0, _endpoint2.default)("record", this.bucket.name, this.name, record.id);
      var request = requests.createRequest(path, { data: record, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Updates a record in current collection.
     *
     * @param  {Object}  record                  The record to update.
     * @param  {Object}  [options={}]            The options object.
     * @param  {Object}  [options.headers]       The headers object option.
     * @param  {Boolean} [options.safe]          The safe option.
     * @param  {Number}  [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "updateRecord",
    value: function updateRecord(record) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(record)) {
        throw new Error("A record object is required.");
      }
      if (!record.id) {
        throw new Error("A record id is required.");
      }
      var reqOptions = this._collOptions(options);
      var permissions = reqOptions.permissions;

      var path = (0, _endpoint2.default)("record", this.bucket.name, this.name, record.id);
      var request = requests.updateRequest(path, { data: record, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Deletes a record from the current collection.
     *
     * @param  {Object|String} record                  The record to delete.
     * @param  {Object}        [options={}]            The options object.
     * @param  {Object}        [options.headers]       The headers object option.
     * @param  {Boolean}       [options.safe]          The safe option.
     * @param  {Number}        [options.last_modified] The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteRecord",
    value: function deleteRecord(record) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var recordObj = (0, _utils.toDataBody)(record);
      if (!recordObj.id) {
        throw new Error("A record id is required.");
      }
      var id = recordObj.id;
      var last_modified = recordObj.last_modified;

      var reqOptions = this._collOptions(_extends({ last_modified: last_modified }, options));
      var path = (0, _endpoint2.default)("record", this.bucket.name, this.name, id);
      var request = requests.deleteRequest(path, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Retrieves a record from the current collection.
     *
     * @param  {String} id                The record id to retrieve.
     * @param  {Object} [options={}]      The options object.
     * @param  {Object} [options.headers] The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getRecord",
    value: function getRecord(id) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      return this.client.execute(_extends({
        path: (0, _endpoint2.default)("record", this.bucket.name, this.name, id)
      }, this._collOptions(options)));
    }

    /**
     * Lists records from the current collection.
     *
     * Sorting is done by passing a `sort` string option:
     *
     * - The field to order the results by, prefixed with `-` for descending.
     * Default: `-last_modified`.
     *
     * @see http://kinto.readthedocs.io/en/stable/core/api/resource.html#sorting
     *
     * Filtering is done by passing a `filters` option object:
     *
     * - `{fieldname: "value"}`
     * - `{min_fieldname: 4000}`
     * - `{in_fieldname: "1,2,3"}`
     * - `{not_fieldname: 0}`
     * - `{exclude_fieldname: "0,1"}`
     *
     * @see http://kinto.readthedocs.io/en/stable/core/api/resource.html#filtering
     *
     * Paginating is done by passing a `limit` option, then calling the `next()`
     * method from the resolved result object to fetch the next page, if any.
     *
     * @param  {Object}   [options={}]                    The options object.
     * @param  {Object}   [options.headers]               The headers object option.
     * @param  {Object}   [options.filters=[]]            The filters object.
     * @param  {String}   [options.sort="-last_modified"] The sort field.
     * @param  {String}   [options.limit=null]            The limit field.
     * @param  {String}   [options.pages=1]               The number of result pages to aggregate.
     * @param  {Number}   [options.since=null]            Only retrieve records modified since the provided timestamp.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "listRecords",
    value: function listRecords() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var http = this.client.http;

      var _sort$options = _extends({
        sort: "-last_modified"
      }, options);

      var sort = _sort$options.sort;
      var filters = _sort$options.filters;
      var limit = _sort$options.limit;
      var pages = _sort$options.pages;
      var since = _sort$options.since;
      // Safety/Consistency check on ETag value.

      if (since && typeof since !== "string") {
        throw new Error("Invalid value for since (" + since + "), should be ETag value.");
      }
      var collHeaders = this.options.headers;
      var path = (0, _endpoint2.default)("record", this.bucket.name, this.name);
      var querystring = (0, _utils.qsify)(_extends({}, filters, {
        _sort: sort,
        _limit: limit,
        _since: since
      }));
      var results = [],
          current = 0;

      var next = function next(nextPage) {
        if (!nextPage) {
          throw new Error("Pagination exhausted.");
        }
        return processNextPage(nextPage);
      };

      var processNextPage = function processNextPage(nextPage) {
        return http.request(nextPage, { headers: collHeaders }).then(handleResponse);
      };

      var pageResults = function pageResults(results, nextPage, etag) {
        // ETag string is supposed to be opaque and stored «as-is».
        // ETag header values are quoted (because of * and W/"foo").
        return {
          last_modified: etag ? etag.replace(/"/g, "") : etag,
          data: results,
          next: next.bind(null, nextPage)
        };
      };

      var handleResponse = function handleResponse(_ref) {
        var headers = _ref.headers;
        var json = _ref.json;

        var nextPage = headers.get("Next-Page");
        var etag = headers.get("ETag");
        if (!pages) {
          return pageResults(json.data, nextPage, etag);
        }
        // Aggregate new results with previous ones
        results = results.concat(json.data);
        current += 1;
        if (current >= pages || !nextPage) {
          // Pagination exhausted
          return pageResults(results, nextPage, etag);
        }
        // Follow next page
        return processNextPage(nextPage);
      };

      return this.client.execute(_extends({
        path: path + "?" + querystring
      }, this._collOptions(options)), { raw: true }).then(handleResponse);
    }

    /**
     * Performs batch operations at the current collection level.
     *
     * @param  {Function} fn                   The batch operation function.
     * @param  {Object}   [options={}]         The options object.
     * @param  {Object}   [options.headers]    The headers object option.
     * @param  {Boolean}  [options.safe]       The safe option.
     * @param  {Boolean}  [options.aggregate]  Produces a grouped result object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "batch",
    value: function batch(fn) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var reqOptions = this._collOptions(options);
      return this.client.batch(fn, _extends({}, reqOptions, {
        bucket: this.bucket.name,
        collection: this.name
      }));
    }
  }]);

  return Collection;
}();

exports.default = Collection;

},{"./endpoint":8,"./requests":12,"./utils":13}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = endpoint;
/**
 * Endpoints templates.
 * @type {Object}
 */
var ENDPOINTS = {
  root: function root() {
    return "/";
  },
  batch: function batch() {
    return "/batch";
  },
  bucket: function bucket(_bucket) {
    return "/buckets" + (_bucket ? "/" + _bucket : "");
  },
  collection: function collection(bucket, coll) {
    return ENDPOINTS.bucket(bucket) + "/collections" + (coll ? "/" + coll : "");
  },
  group: function group(bucket, _group) {
    return ENDPOINTS.bucket(bucket) + "/groups" + (_group ? "/" + _group : "");
  },
  record: function record(bucket, coll, id) {
    return ENDPOINTS.collection(bucket, coll) + "/records" + (id ? "/" + id : "");
  }
};

/**
 * Retrieves a server enpoint by its name.
 *
 * @private
 * @param  {String}    name The endpoint name.
 * @param  {...string} args The endpoint parameters.
 * @return {String}
 */
function endpoint(name) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return ENDPOINTS[name].apply(ENDPOINTS, args);
}

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Kinto server error code descriptors.
 * @type {Object}
 */
exports.default = {
  104: "Missing Authorization Token",
  105: "Invalid Authorization Token",
  106: "Request body was not valid JSON",
  107: "Invalid request parameter",
  108: "Missing request parameter",
  109: "Invalid posted data",
  110: "Invalid Token / id",
  111: "Missing Token / id",
  112: "Content-Length header was not provided",
  113: "Request body too large",
  114: "Resource was modified meanwhile",
  115: "Method not allowed on this end point (hint: server may be readonly)",
  116: "Requested version not available on this server",
  117: "Client has sent too many requests",
  121: "Resource access is forbidden for this user",
  122: "Another resource violates constraint",
  201: "Service Temporary unavailable due to high load",
  202: "Service deprecated",
  999: "Internal Server Error"
};

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _errors = require("./errors");

var _errors2 = _interopRequireDefault(_errors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Enhanced HTTP client for the Kinto protocol.
 * @private
 */

var HTTP = function () {
  _createClass(HTTP, null, [{
    key: "DEFAULT_REQUEST_HEADERS",

    /**
     * Default HTTP request headers applied to each outgoing request.
     *
     * @type {Object}
     */
    get: function get() {
      return {
        "Accept": "application/json",
        "Content-Type": "application/json"
      };
    }

    /**
     * Default options.
     *
     * @type {Object}
     */

  }, {
    key: "defaultOptions",
    get: function get() {
      return { timeout: 5000, requestMode: "cors" };
    }

    /**
     * Constructor.
     *
     * @param {EventEmitter} events                       The event handler.
     * @param {Object}       [options={}}                 The options object.
     * @param {Number}       [options.timeout=5000]       The request timeout in ms (default: `5000`).
     * @param {String}       [options.requestMode="cors"] The HTTP request mode (default: `"cors"`).
     */

  }]);

  function HTTP(events) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, HTTP);

    // public properties
    /**
     * The event emitter instance.
     * @type {EventEmitter}
     */
    if (!events) {
      throw new Error("No events handler provided");
    }
    this.events = events;

    /**
     * The request mode.
     * @see  https://fetch.spec.whatwg.org/#requestmode
     * @type {String}
     */
    this.requestMode = options.requestMode || HTTP.defaultOptions.requestMode;

    /**
     * The request timeout.
     * @type {Number}
     */
    this.timeout = options.timeout || HTTP.defaultOptions.timeout;
  }

  /**
   * Performs an HTTP request to the Kinto server.
   *
   * Resolves with an objet containing the following HTTP response properties:
   * - `{Number}  status`  The HTTP status code.
   * - `{Object}  json`    The JSON response body.
   * - `{Headers} headers` The response headers object; see the ES6 fetch() spec.
   *
   * @param  {String} url               The URL.
   * @param  {Object} [options={}]      The fetch() options object.
   * @param  {Object} [options.headers] The request headers object (default: {})
   * @return {Promise}
   */


  _createClass(HTTP, [{
    key: "request",
    value: function request(url) {
      var _this = this;

      var options = arguments.length <= 1 || arguments[1] === undefined ? { headers: {} } : arguments[1];

      var response = void 0,
          status = void 0,
          statusText = void 0,
          headers = void 0,
          hasTimedout = void 0;
      // Ensure default request headers are always set
      options.headers = Object.assign({}, HTTP.DEFAULT_REQUEST_HEADERS, options.headers);
      options.mode = this.requestMode;
      return new Promise(function (resolve, reject) {
        var _timeoutId = setTimeout(function () {
          hasTimedout = true;
          reject(new Error("Request timeout."));
        }, _this.timeout);
        fetch(url, options).then(function (res) {
          if (!hasTimedout) {
            clearTimeout(_timeoutId);
            resolve(res);
          }
        }).catch(function (err) {
          if (!hasTimedout) {
            clearTimeout(_timeoutId);
            reject(err);
          }
        });
      }).then(function (res) {
        response = res;
        headers = res.headers;
        status = res.status;
        statusText = res.statusText;
        _this._checkForDeprecationHeader(headers);
        _this._checkForBackoffHeader(status, headers);
        _this._checkForRetryAfterHeader(status, headers);
        return res.text();
      })
      // Check if we have a body; if so parse it as JSON.
      .then(function (text) {
        if (text.length === 0) {
          return null;
        }
        // Note: we can't consume the response body twice.
        return JSON.parse(text);
      }).catch(function (err) {
        var error = new Error("HTTP " + (status || 0) + "; " + err);
        error.response = response;
        error.stack = err.stack;
        throw error;
      }).then(function (json) {
        if (json && status >= 400) {
          var message = "HTTP " + status + " " + (json.error || "") + ": ";
          if (json.errno && json.errno in _errors2.default) {
            var errnoMsg = _errors2.default[json.errno];
            message += errnoMsg;
            if (json.message && json.message !== errnoMsg) {
              message += " (" + json.message + ")";
            }
          } else {
            message += statusText || "";
          }
          var error = new Error(message.trim());
          error.response = response;
          error.data = json;
          throw error;
        }
        return { status: status, json: json, headers: headers };
      });
    }
  }, {
    key: "_checkForDeprecationHeader",
    value: function _checkForDeprecationHeader(headers) {
      var alertHeader = headers.get("Alert");
      if (!alertHeader) {
        return;
      }
      var alert = void 0;
      try {
        alert = JSON.parse(alertHeader);
      } catch (err) {
        console.warn("Unable to parse Alert header message", alertHeader);
        return;
      }
      console.warn(alert.message, alert.url);
      this.events.emit("deprecated", alert);
    }
  }, {
    key: "_checkForBackoffHeader",
    value: function _checkForBackoffHeader(status, headers) {
      var backoffMs = void 0;
      var backoffSeconds = parseInt(headers.get("Backoff"), 10);
      if (backoffSeconds > 0) {
        backoffMs = new Date().getTime() + backoffSeconds * 1000;
      } else {
        backoffMs = 0;
      }
      this.events.emit("backoff", backoffMs);
    }
  }, {
    key: "_checkForRetryAfterHeader",
    value: function _checkForRetryAfterHeader(status, headers) {
      var retryAfter = headers.get("Retry-After");
      if (!retryAfter) {
        return;
      }
      retryAfter = new Date().getTime() + parseInt(retryAfter, 10) * 1000;
      this.events.emit("retry-after", retryAfter);
    }
  }]);

  return HTTP;
}();

exports.default = HTTP;

},{"./errors":9}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

require("isomorphic-fetch");

var _events = require("events");

var _base = require("./base");

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KintoClient = function (_KintoClientBase) {
  _inherits(KintoClient, _KintoClientBase);

  function KintoClient(remote) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, KintoClient);

    var events = options.events || new _events.EventEmitter();

    return _possibleConstructorReturn(this, Object.getPrototypeOf(KintoClient).call(this, remote, Object.assign({ events: events }, options)));
  }

  return KintoClient;
}(_base2.default);

// This is a hack to avoid Browserify to expose the above class
// at `new KintoClient()` instead of `new KintoClient.default()`.
// See https://github.com/Kinto/kinto-http.js/issues/77


exports.default = KintoClient;
if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === "object") {
  module.exports = KintoClient;
}

},{"./base":4,"events":1,"isomorphic-fetch":2}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.createRequest = createRequest;
exports.updateRequest = updateRequest;
exports.deleteRequest = deleteRequest;

var _utils = require("./utils");

var requestDefaults = {
  safe: false,
  // check if we should set default content type here
  headers: {},
  permissions: undefined,
  data: undefined,
  patch: false
};

/**
 * @private
 */
function safeHeader(safe, last_modified) {
  if (!safe) {
    return {};
  }
  if (last_modified) {
    return { "If-Match": "\"" + last_modified + "\"" };
  }
  return { "If-None-Match": "*" };
}

/**
 * @private
 */
function createRequest(path, _ref) {
  var data = _ref.data;
  var permissions = _ref.permissions;
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var _requestDefaults$opti = _extends({}, requestDefaults, options);

  var headers = _requestDefaults$opti.headers;
  var safe = _requestDefaults$opti.safe;

  return {
    method: data && data.id ? "PUT" : "POST",
    path: path,
    headers: _extends({}, headers, safeHeader(safe)),
    body: {
      data: data,
      permissions: permissions
    }
  };
}

/**
 * @private
 */
function updateRequest(path, _ref2) {
  var data = _ref2.data;
  var permissions = _ref2.permissions;
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var _requestDefaults$opti2 = _extends({}, requestDefaults, options);

  var headers = _requestDefaults$opti2.headers;
  var safe = _requestDefaults$opti2.safe;
  var patch = _requestDefaults$opti2.patch;

  var _data$options = _extends({}, data, options);

  var last_modified = _data$options.last_modified;


  if (Object.keys((0, _utils.omit)(data, "id", "last_modified")).length === 0) {
    data = undefined;
  }

  return {
    method: patch ? "PATCH" : "PUT",
    path: path,
    headers: _extends({}, headers, safeHeader(safe, last_modified)),
    body: {
      data: data,
      permissions: permissions
    }
  };
}

/**
 * @private
 */
function deleteRequest(path) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var _requestDefaults$opti3 = _extends({}, requestDefaults, options);

  var headers = _requestDefaults$opti3.headers;
  var safe = _requestDefaults$opti3.safe;
  var last_modified = _requestDefaults$opti3.last_modified;

  if (safe && !last_modified) {
    throw new Error("Safe concurrency check requires a last_modified value.");
  }
  return {
    method: "DELETE",
    path: path,
    headers: _extends({}, headers, safeHeader(safe, last_modified))
  };
}

},{"./utils":13}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.partition = partition;
exports.pMap = pMap;
exports.omit = omit;
exports.toDataBody = toDataBody;
exports.qsify = qsify;
exports.checkVersion = checkVersion;
exports.support = support;
exports.capable = capable;
exports.nobatch = nobatch;
exports.isObject = isObject;
/**
 * Chunks an array into n pieces.
 *
 * @private
 * @param  {Array}  array
 * @param  {Number} n
 * @return {Array}
 */
function partition(array, n) {
  if (n <= 0) {
    return array;
  }
  return array.reduce(function (acc, x, i) {
    if (i === 0 || i % n === 0) {
      acc.push([x]);
    } else {
      acc[acc.length - 1].push(x);
    }
    return acc;
  }, []);
}

/**
 * Maps a list to promises using the provided mapping function, executes them
 * sequentially then returns a Promise resolving with ordered results obtained.
 * Think of this as a sequential Promise.all.
 *
 * @private
 * @param  {Array}    list The list to map.
 * @param  {Function} fn   The mapping function.
 * @return {Promise}
 */
function pMap(list, fn) {
  var results = [];
  return list.reduce(function (promise, entry) {
    return promise.then(function () {
      return Promise.resolve(fn(entry)).then(function (result) {
        return results = results.concat(result);
      });
    });
  }, Promise.resolve()).then(function () {
    return results;
  });
}

/**
 * Takes an object and returns a copy of it with the provided keys omitted.
 *
 * @private
 * @param  {Object}    obj  The source object.
 * @param  {...String} keys The keys to omit.
 * @return {Object}
 */
function omit(obj) {
  for (var _len = arguments.length, keys = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }

  return Object.keys(obj).reduce(function (acc, key) {
    if (keys.indexOf(key) === -1) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}

/**
 * Always returns a resource data object from the provided argument.
 *
 * @private
 * @param  {Object|String} resource
 * @return {Object}
 */
function toDataBody(resource) {
  if (isObject(resource)) {
    return resource;
  }
  if (typeof resource === "string") {
    return { id: resource };
  }
  throw new Error("Invalid argument.");
}

/**
 * Transforms an object into an URL query string, stripping out any undefined
 * values.
 *
 * @param  {Object} obj
 * @return {String}
 */
function qsify(obj) {
  var sep = "&";
  var encode = function encode(v) {
    return encodeURIComponent(typeof v === "boolean" ? String(v) : v);
  };
  var stripUndefined = function stripUndefined(o) {
    return JSON.parse(JSON.stringify(o));
  };
  var stripped = stripUndefined(obj);
  return Object.keys(stripped).map(function (k) {
    var ks = encode(k) + "=";
    if (Array.isArray(stripped[k])) {
      return stripped[k].map(function (v) {
        return ks + encode(v);
      }).join(sep);
    } else {
      return ks + encode(stripped[k]);
    }
  }).join(sep);
}

/**
 * Checks if a version is within the provided range.
 *
 * @param  {String} version    The version to check.
 * @param  {String} minVersion The minimum supported version (inclusive).
 * @param  {String} maxVersion The minimum supported version (exclusive).
 * @throws {Error} If the version is outside of the provided range.
 */
function checkVersion(version, minVersion, maxVersion) {
  var extract = function extract(str) {
    return str.split(".").map(function (x) {
      return parseInt(x, 10);
    });
  };

  var _extract = extract(version);

  var _extract2 = _slicedToArray(_extract, 2);

  var verMajor = _extract2[0];
  var verMinor = _extract2[1];

  var _extract3 = extract(minVersion);

  var _extract4 = _slicedToArray(_extract3, 2);

  var minMajor = _extract4[0];
  var minMinor = _extract4[1];

  var _extract5 = extract(maxVersion);

  var _extract6 = _slicedToArray(_extract5, 2);

  var maxMajor = _extract6[0];
  var maxMinor = _extract6[1];

  var checks = [verMajor < minMajor, verMajor === minMajor && verMinor < minMinor, verMajor > maxMajor, verMajor === maxMajor && verMinor >= maxMinor];
  if (checks.some(function (x) {
    return x;
  })) {
    throw new Error("Version " + version + " doesn't satisfy " + (minVersion + " <= x < " + maxVersion));
  }
}

/**
 * Generates a decorator function ensuring a version check is performed against
 * the provided requirements before executing it.
 *
 * @param  {String} min The required min version (inclusive).
 * @param  {String} max The required max version (inclusive).
 * @return {Function}
 */
function support(min, max) {
  return function (target, key, descriptor) {
    var fn = descriptor.value;
    return {
      configurable: true,
      get: function get() {
        var _this = this;

        var wrappedMethod = function wrappedMethod() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          // "this" is the current instance which its method is decorated.
          var client = "client" in _this ? _this.client : _this;
          return client.fetchHTTPApiVersion().then(function (version) {
            return checkVersion(version, min, max);
          }).then(Promise.resolve(fn.apply(_this, args)));
        };
        Object.defineProperty(this, key, {
          value: wrappedMethod,
          configurable: true,
          writable: true
        });
        return wrappedMethod;
      }
    };
  };
}

/**
 * Generates a decorator function ensuring that the specified capabilities are
 * available on the server before executing it.
 *
 * @param  {Array<String>} capabilities The required capabilities.
 * @return {Function}
 */
function capable(capabilities) {
  return function (target, key, descriptor) {
    var fn = descriptor.value;
    return {
      configurable: true,
      get: function get() {
        var _this2 = this;

        var wrappedMethod = function wrappedMethod() {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          // "this" is the current instance which its method is decorated.
          var client = "client" in _this2 ? _this2.client : _this2;
          return client.fetchServerCapabilities().then(function (available) {
            var missing = capabilities.filter(function (c) {
              return available.indexOf(c) < 0;
            });
            if (missing.length > 0) {
              throw new Error("Required capabilities " + missing.join(", ") + " " + "not present on server");
            }
          }).then(Promise.resolve(fn.apply(_this2, args)));
        };
        Object.defineProperty(this, key, {
          value: wrappedMethod,
          configurable: true,
          writable: true
        });
        return wrappedMethod;
      }
    };
  };
}

/**
 * Generates a decorator function ensuring an operation is not performed from
 * within a batch request.
 *
 * @param  {String} message The error message to throw.
 * @return {Function}
 */
function nobatch(message) {
  return function (target, key, descriptor) {
    var fn = descriptor.value;
    return {
      configurable: true,
      get: function get() {
        var _this3 = this;

        var wrappedMethod = function wrappedMethod() {
          for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          // "this" is the current instance which its method is decorated.
          if (_this3._isBatch) {
            throw new Error(message);
          }
          return fn.apply(_this3, args);
        };
        Object.defineProperty(this, key, {
          value: wrappedMethod,
          configurable: true,
          writable: true
        });
        return wrappedMethod;
      }
    };
  };
}

/**
 * Returns true if the specified value is an object (i.e. not an array nor null).
 * @param  {Object} thing The value to inspect.
 * @return {bool}
 */
function isObject(thing) {
  return (typeof thing === "undefined" ? "undefined" : _typeof(thing)) === "object" && thing !== null && !Array.isArray(thing);
}

},{}]},{},[11])(11)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9pc29tb3JwaGljLWZldGNoL2ZldGNoLW5wbS1icm93c2VyaWZ5LmpzIiwibm9kZV9tb2R1bGVzL2lzb21vcnBoaWMtZmV0Y2gvbm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcyIsInNyYy9iYXNlLmpzIiwic3JjL2JhdGNoLmpzIiwic3JjL2J1Y2tldC5qcyIsInNyYy9jb2xsZWN0aW9uLmpzIiwic3JjL2VuZHBvaW50LmpzIiwic3JjL2Vycm9ycy5qcyIsInNyYy9odHRwLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL3JlcXVlc3RzLmpzIiwic3JjL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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R0FBNUIsRUFBaUM7QUFDL0IsaUJBQU8sYUFBUDtBQUNBLHdCQUFjLElBQWQ7QUFDQSxvQkFBVSxJQUFWO1NBSEYsRUFkSTtBQW1CSixlQUFPLGFBQVAsQ0FuQkk7T0FGRDtLQUFQLENBRnVDO0dBQWxDLENBRDZCO0NBQS9COzs7Ozs7Ozs7QUFxQ0EsU0FBUyxPQUFULENBQWlCLE9BQWpCLEVBQTBCO0FBQy9CLFNBQU8sVUFBUyxNQUFULEVBQWlCLEdBQWpCLEVBQXNCLFVBQXRCLEVBQWtDO0FBQ3ZDLFFBQU0sS0FBSyxXQUFXLEtBQVgsQ0FENEI7QUFFdkMsV0FBTztBQUNMLG9CQUFjLElBQWQ7QUFDQSwwQkFBTTs7O0FBQ0osWUFBTSxnQkFBZ0IsU0FBaEIsYUFBZ0IsR0FBYTs2Q0FBVDs7V0FBUzs7O0FBRWpDLGNBQUksT0FBSyxRQUFMLEVBQWU7QUFDakIsa0JBQU0sSUFBSSxLQUFKLENBQVUsT0FBVixDQUFOLENBRGlCO1dBQW5CO0FBR0EsaUJBQU8sR0FBRyxLQUFILFNBQWUsSUFBZixDQUFQLENBTGlDO1NBQWIsQ0FEbEI7QUFRSixlQUFPLGNBQVAsQ0FBc0IsSUFBdEIsRUFBNEIsR0FBNUIsRUFBaUM7QUFDL0IsaUJBQU8sYUFBUDtBQUNBLHdCQUFjLElBQWQ7QUFDQSxvQkFBVSxJQUFWO1NBSEYsRUFSSTtBQWFKLGVBQU8sYUFBUCxDQWJJO09BRkQ7S0FBUCxDQUZ1QztHQUFsQyxDQUR3QjtDQUExQjs7Ozs7OztBQTZCQSxTQUFTLFFBQVQsQ0FBa0IsS0FBbEIsRUFBeUI7QUFDOUIsU0FBTyxRQUFPLHFEQUFQLEtBQWlCLFFBQWpCLElBQTZCLFVBQVUsSUFBVixJQUFrQixDQUFDLE1BQU0sT0FBTixDQUFjLEtBQWQsQ0FBRCxDQUR4QjtDQUF6QiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIvLyB0aGUgd2hhdHdnLWZldGNoIHBvbHlmaWxsIGluc3RhbGxzIHRoZSBmZXRjaCgpIGZ1bmN0aW9uXG4vLyBvbiB0aGUgZ2xvYmFsIG9iamVjdCAod2luZG93IG9yIHNlbGYpXG4vL1xuLy8gUmV0dXJuIHRoYXQgYXMgdGhlIGV4cG9ydCBmb3IgdXNlIGluIFdlYnBhY2ssIEJyb3dzZXJpZnkgZXRjLlxucmVxdWlyZSgnd2hhdHdnLWZldGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHNlbGYuZmV0Y2guYmluZChzZWxmKTtcbiIsIihmdW5jdGlvbihzZWxmKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoc2VsZi5mZXRjaCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKVxuICAgIH1cbiAgICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5cXF5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5tYXAgPSB7fVxuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICB9LCB0aGlzKVxuXG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gICAgdmFyIGxpc3QgPSB0aGlzLm1hcFtuYW1lXVxuICAgIGlmICghbGlzdCkge1xuICAgICAgbGlzdCA9IFtdXG4gICAgICB0aGlzLm1hcFtuYW1lXSA9IGxpc3RcbiAgICB9XG4gICAgbGlzdC5wdXNoKHZhbHVlKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICAgIHJldHVybiB2YWx1ZXMgPyB2YWx1ZXNbMF0gOiBudWxsXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldIHx8IFtdXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gW25vcm1hbGl6ZVZhbHVlKHZhbHVlKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMubWFwKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHRoaXMubWFwW25hbWVdLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgbmFtZSwgdGhpcylcbiAgICAgIH0sIHRoaXMpXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICAgIH1cbiAgICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KVxuICAgICAgfVxuICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICAgIHJldHVybiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYilcbiAgICByZXR1cm4gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgfVxuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIGJsb2I6ICdGaWxlUmVhZGVyJyBpbiBzZWxmICYmICdCbG9iJyBpbiBzZWxmICYmIChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBCbG9iKCk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAvLyBPbmx5IHN1cHBvcnQgQXJyYXlCdWZmZXJzIGZvciBQT1NUIG1ldGhvZC5cbiAgICAgICAgLy8gUmVjZWl2aW5nIEFycmF5QnVmZmVycyBoYXBwZW5zIHZpYSBCbG9icywgaW5zdGVhZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZScpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZCA6IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ11cblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgIHJldHVybiAobWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEpID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHlcbiAgICBpZiAoUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmxcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsc1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycylcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlXG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdFxuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBpbnB1dFxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBoZWFkZXJzKHhocikge1xuICAgIHZhciBoZWFkID0gbmV3IEhlYWRlcnMoKVxuICAgIHZhciBwYWlycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS50cmltKCkuc3BsaXQoJ1xcbicpXG4gICAgcGFpcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHZhciBzcGxpdCA9IGhlYWRlci50cmltKCkuc3BsaXQoJzonKVxuICAgICAgdmFyIGtleSA9IHNwbGl0LnNoaWZ0KCkudHJpbSgpXG4gICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc6JykudHJpbSgpXG4gICAgICBoZWFkLmFwcGVuZChrZXksIHZhbHVlKVxuICAgIH0pXG4gICAgcmV0dXJuIGhlYWRcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1c1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDBcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBvcHRpb25zLnN0YXR1c1RleHRcbiAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzID8gb3B0aW9ucy5oZWFkZXJzIDogbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfVxuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfVxuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnM7XG4gIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdFxuICAgICAgaWYgKFJlcXVlc3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoaW5wdXQpICYmICFpbml0KSB7XG4gICAgICAgIHJlcXVlc3QgPSBpbnB1dFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgICAgZnVuY3Rpb24gcmVzcG9uc2VVUkwoKSB7XG4gICAgICAgIGlmICgncmVzcG9uc2VVUkwnIGluIHhocikge1xuICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VVUkxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF2b2lkIHNlY3VyaXR5IHdhcm5pbmdzIG9uIGdldFJlc3BvbnNlSGVhZGVyIHdoZW4gbm90IGFsbG93ZWQgYnkgQ09SU1xuICAgICAgICBpZiAoL15YLVJlcXVlc3QtVVJMOi9tLnRlc3QoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgICAgIHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSAoeGhyLnN0YXR1cyA9PT0gMTIyMykgPyAyMDQgOiB4aHIuc3RhdHVzXG4gICAgICAgIGlmIChzdGF0dXMgPCAxMDAgfHwgc3RhdHVzID4gNTk5KSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzKHhociksXG4gICAgICAgICAgdXJsOiByZXNwb25zZVVSTCgpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfVxuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgfSlcbiAgfVxuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IHBhcnRpdGlvbiwgcE1hcCwgb21pdCwgc3VwcG9ydCwgbm9iYXRjaCwgdG9EYXRhQm9keSB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgSFRUUCBmcm9tIFwiLi9odHRwXCI7XG5pbXBvcnQgZW5kcG9pbnQgZnJvbSBcIi4vZW5kcG9pbnRcIjtcbmltcG9ydCAqIGFzIHJlcXVlc3RzIGZyb20gXCIuL3JlcXVlc3RzXCI7XG5pbXBvcnQgeyBhZ2dyZWdhdGUgfSBmcm9tIFwiLi9iYXRjaFwiO1xuaW1wb3J0IEJ1Y2tldCBmcm9tIFwiLi9idWNrZXRcIjtcblxuXG4vKipcbiAqIEN1cnJlbnRseSBzdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBTVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTiA9IFwidjFcIjtcblxuLyoqXG4gKiBIaWdoIGxldmVsIEhUVFAgY2xpZW50IGZvciB0aGUgS2ludG8gQVBJLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBjbGllbnQgPSBuZXcgS2ludG9DbGllbnQoXCJodHRwczovL2tpbnRvLmRldi5tb3phd3MubmV0L3YxXCIpO1xuICogY2xpZW50LmJ1Y2tldChcImRlZmF1bHRcIilcbiogICAgLmNvbGxlY3Rpb24oXCJteS1ibG9nXCIpXG4qICAgIC5jcmVhdGVSZWNvcmQoe3RpdGxlOiBcIkZpcnN0IGFydGljbGVcIn0pXG4gKiAgIC50aGVuKGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkpXG4gKiAgIC5jYXRjaChjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSkpO1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW50b0NsaWVudEJhc2Uge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgcmVtb3RlICBUaGUgcmVtb3RlIFVSTC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBbb3B0aW9ucz17fV0gICAgICAgICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgW29wdGlvbnMuc2FmZT10cnVlXSAgICAgICAgICAgQWRkcyBjb25jdXJyZW5jeSBoZWFkZXJzIHRvIGV2ZXJ5IHJlcXVlc3RzLlxuICAgKiBAcGFyYW0gIHtFdmVudEVtaXR0ZXJ9IFtvcHRpb25zLmV2ZW50cz1FdmVudEVtaXR0ZXJdIFRoZSBldmVudHMgaGFuZGxlciBpbnN0YW5jZS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBbb3B0aW9ucy5oZWFkZXJzPXt9XSAgICAgICAgICBUaGUga2V5LXZhbHVlIGhlYWRlcnMgdG8gcGFzcyB0byBlYWNoIHJlcXVlc3QuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgW29wdGlvbnMuYnVja2V0PVwiZGVmYXVsdFwiXSAgICBUaGUgZGVmYXVsdCBidWNrZXQgdG8gdXNlLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIFtvcHRpb25zLnJlcXVlc3RNb2RlPVwiY29yc1wiXSAgVGhlIEhUVFAgcmVxdWVzdCBtb2RlIChmcm9tIEVTNiBmZXRjaCBzcGVjKS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgICBbb3B0aW9ucy50aW1lb3V0PTUwMDBdICAgICAgICBUaGUgcmVxdWVzdHMgdGltZW91dCBpbiBtcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbW90ZSwgb3B0aW9ucz17fSkge1xuICAgIGlmICh0eXBlb2YocmVtb3RlKSAhPT0gXCJzdHJpbmdcIiB8fCAhcmVtb3RlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZW1vdGUgVVJMOiBcIiArIHJlbW90ZSk7XG4gICAgfVxuICAgIGlmIChyZW1vdGVbcmVtb3RlLmxlbmd0aC0xXSA9PT0gXCIvXCIpIHtcbiAgICAgIHJlbW90ZSA9IHJlbW90ZS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHRoaXMuX2JhY2tvZmZSZWxlYXNlVGltZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHJlcXVlc3Qgb3B0aW9ucyBjb250YWluZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZGVmYXVsdFJlcU9wdGlvbnMgPSB7XG4gICAgICBidWNrZXQ6ICBvcHRpb25zLmJ1Y2tldCAgfHwgXCJkZWZhdWx0XCIsXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMgfHwge30sXG4gICAgICBzYWZlOiAgICAhIW9wdGlvbnMuc2FmZSxcbiAgICB9O1xuXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9pc0JhdGNoID0gISFvcHRpb25zLmJhdGNoO1xuXG4gICAgLy8gcHVibGljIHByb3BlcnRpZXNcbiAgICAvKipcbiAgICAgKiBUaGUgcmVtb3RlIHNlcnZlciBiYXNlIFVSTC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVtb3RlID0gcmVtb3RlO1xuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc2VydmVyIGluZm9ybWF0aW9uLlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zZXJ2ZXJJbmZvID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgZW1pdHRlciBpbnN0YW5jZS4gU2hvdWxkIGNvbXBseSB3aXRoIHRoZSBgRXZlbnRFbWl0dGVyYFxuICAgICAqIGludGVyZmFjZS5cbiAgICAgKiBAaWdub3JlXG4gICAgICogQHR5cGUge0NsYXNzfVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRzID0gb3B0aW9ucy5ldmVudHM7XG5cbiAgICBjb25zdCB7cmVxdWVzdE1vZGUsIHRpbWVvdXR9ID0gb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiBUaGUgSFRUUCBpbnN0YW5jZS5cbiAgICAgKiBAaWdub3JlXG4gICAgICogQHR5cGUge0hUVFB9XG4gICAgICovXG4gICAgdGhpcy5odHRwID0gbmV3IEhUVFAodGhpcy5ldmVudHMsIHtyZXF1ZXN0TW9kZSwgdGltZW91dH0pO1xuICAgIHRoaXMuX3JlZ2lzdGVySFRUUEV2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByZW1vdGUgZW5kcG9pbnQgYmFzZSBVUkwuIFNldHRpbmcgdGhlIHZhbHVlIHdpbGwgYWxzbyBleHRyYWN0IGFuZFxuICAgKiB2YWxpZGF0ZSB0aGUgdmVyc2lvbi5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCByZW1vdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbW90ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzZXQgcmVtb3RlKHVybCkge1xuICAgIGxldCB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICB2ZXJzaW9uID0gdXJsLm1hdGNoKC9cXC8odlxcZCspXFwvPyQvKVsxXTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZW1vdGUgVVJMIG11c3QgY29udGFpbiB0aGUgdmVyc2lvbjogXCIgKyB1cmwpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiAhPT0gU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT04pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHt2ZXJzaW9ufWApO1xuICAgIH1cbiAgICB0aGlzLl9yZW1vdGUgPSB1cmw7XG4gICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gIH1cblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc2VydmVyIHByb3RvY29sIHZlcnNpb24sIGVnLiBgdjFgLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcnNpb247XG4gIH1cblxuICAvKipcbiAgICogQmFja29mZiByZW1haW5pbmcgdGltZSwgaW4gbWlsbGlzZWNvbmRzLiBEZWZhdWx0cyB0byB6ZXJvIGlmIG5vIGJhY2tvZmYgaXNcbiAgICogb25nb2luZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBiYWNrb2ZmKCkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgaWYgKHRoaXMuX2JhY2tvZmZSZWxlYXNlVGltZSAmJiBjdXJyZW50VGltZSA8IHRoaXMuX2JhY2tvZmZSZWxlYXNlVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2JhY2tvZmZSZWxlYXNlVGltZSAtIGN1cnJlbnRUaW1lO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgSFRUUCBldmVudHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVnaXN0ZXJIVFRQRXZlbnRzKCkge1xuICAgIC8vIFByZXZlbnQgcmVnaXN0ZXJpbmcgZXZlbnQgZnJvbSBhIGJhdGNoIGNsaWVudCBpbnN0YW5jZVxuICAgIGlmICghdGhpcy5faXNCYXRjaCkge1xuICAgICAgdGhpcy5ldmVudHMub24oXCJiYWNrb2ZmXCIsIGJhY2tvZmZNcyA9PiB7XG4gICAgICAgIHRoaXMuX2JhY2tvZmZSZWxlYXNlVGltZSA9IGJhY2tvZmZNcztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhIGJ1Y2tldCBvYmplY3QgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lICAgICAgICAgICAgICBUaGUgYnVja2V0IG5hbWUuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSAgICAgIFRoZSByZXF1ZXN0IG9wdGlvbnMuXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnNhZmVdICAgIFRoZSByZXN1bHRpbmcgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIFtvcHRpb25zLmJ1Y2tldF0gIFRoZSByZXN1bHRpbmcgYnVja2V0IG5hbWUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5oZWFkZXJzXSBUaGUgZXh0ZW5kZWQgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtCdWNrZXR9XG4gICAqL1xuICBidWNrZXQobmFtZSwgb3B0aW9ucz17fSkge1xuICAgIGNvbnN0IGJ1Y2tldE9wdGlvbnMgPSBvbWl0KHRoaXMuX2dldFJlcXVlc3RPcHRpb25zKG9wdGlvbnMpLCBcImJ1Y2tldFwiKTtcbiAgICByZXR1cm4gbmV3IEJ1Y2tldCh0aGlzLCBuYW1lLCBidWNrZXRPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSByZXF1ZXN0IG9wdGlvbnMgb2JqZWN0LCBkZWVwbHkgbWVyZ2luZyB0aGUgY2xpZW50IGNvbmZpZ3VyZWRcbiAgICogZGVmYXVsdHMgd2l0aCB0aGUgb25lcyBwcm92aWRlZCBhcyBhcmd1bWVudC5cbiAgICpcbiAgICogTm90ZTogSGVhZGVycyB3b24ndCBiZSBvdmVycmlkZW4gYnV0IG1lcmdlZCB3aXRoIGluc3RhbmNlIGRlZmF1bHQgb25lcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICAgIHtPYmplY3R9ICBbb3B0aW9ucz17fV0gICAgICBUaGUgcmVxdWVzdCBvcHRpb25zLlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtvcHRpb25zLnNhZmVdICAgIFRoZSByZXN1bHRpbmcgc2FmZSBvcHRpb24uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAgW29wdGlvbnMuYnVja2V0XSAgVGhlIHJlc3VsdGluZyBidWNrZXQgbmFtZSBvcHRpb24uXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAgW29wdGlvbnMuaGVhZGVyc10gVGhlIGV4dGVuZGVkIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiAgIHtPYmplY3R9XG4gICAqL1xuICBfZ2V0UmVxdWVzdE9wdGlvbnMob3B0aW9ucz17fSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLmRlZmF1bHRSZXFPcHRpb25zLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGJhdGNoOiB0aGlzLl9pc0JhdGNoLFxuICAgICAgLy8gTm90ZTogaGVhZGVycyBzaG91bGQgbmV2ZXIgYmUgb3ZlcnJpZGVuIGJ1dCBleHRlbmRlZFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi50aGlzLmRlZmF1bHRSZXFPcHRpb25zLmhlYWRlcnMsXG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBzZXJ2ZXIgaW5mb3JtYXRpb24gYW5kIHBlcnNpc3QgdGhlbSBsb2NhbGx5LiBUaGlzIG9wZXJhdGlvbiBpc1xuICAgKiB1c3VhbGx5IHBlcmZvcm1lZCBhIHNpbmdsZSB0aW1lIGR1cmluZyB0aGUgaW5zdGFuY2UgbGlmZWN5Y2xlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucz17fV0gVGhlIHJlcXVlc3Qgb3B0aW9ucy5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGZldGNoU2VydmVySW5mbyhvcHRpb25zPXt9KSB7XG4gICAgaWYgKHRoaXMuc2VydmVySW5mbykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnNlcnZlckluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5odHRwLnJlcXVlc3QodGhpcy5yZW1vdGUgKyBlbmRwb2ludChcInJvb3RcIiksIHtcbiAgICAgIGhlYWRlcnM6IHsuLi50aGlzLmRlZmF1bHRSZXFPcHRpb25zLmhlYWRlcnMsIC4uLm9wdGlvbnMuaGVhZGVyc31cbiAgICB9KVxuICAgICAgLnRoZW4oKHtqc29ufSkgPT4ge1xuICAgICAgICB0aGlzLnNlcnZlckluZm8gPSBqc29uO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJJbmZvO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIEtpbnRvIHNlcnZlciBzZXR0aW5ncy5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnM9e31dIFRoZSByZXF1ZXN0IG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBAbm9iYXRjaChcIlRoaXMgb3BlcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aGluIGEgYmF0Y2ggb3BlcmF0aW9uLlwiKVxuICBmZXRjaFNlcnZlclNldHRpbmdzKG9wdGlvbnM9e30pIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaFNlcnZlckluZm8ob3B0aW9ucykudGhlbigoe3NldHRpbmdzfSkgPT4gc2V0dGluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHNlcnZlciBjYXBhYmlsaXRpZXMgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSBUaGUgcmVxdWVzdCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgQG5vYmF0Y2goXCJUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhpbiBhIGJhdGNoIG9wZXJhdGlvbi5cIilcbiAgZmV0Y2hTZXJ2ZXJDYXBhYmlsaXRpZXMob3B0aW9ucz17fSkge1xuICAgIHJldHVybiB0aGlzLmZldGNoU2VydmVySW5mbyhvcHRpb25zKS50aGVuKCh7Y2FwYWJpbGl0aWVzfSkgPT4gY2FwYWJpbGl0aWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhdXRoZW50aWNhdGVkIHVzZXIgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSBUaGUgcmVxdWVzdCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgQG5vYmF0Y2goXCJUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhpbiBhIGJhdGNoIG9wZXJhdGlvbi5cIilcbiAgZmV0Y2hVc2VyKG9wdGlvbnM9e30pIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaFNlcnZlckluZm8ob3B0aW9ucykudGhlbigoe3VzZXJ9KSA9PiB1c2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhdXRoZW50aWNhdGVkIHVzZXIgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSBUaGUgcmVxdWVzdCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgQG5vYmF0Y2goXCJUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhpbiBhIGJhdGNoIG9wZXJhdGlvbi5cIilcbiAgZmV0Y2hIVFRQQXBpVmVyc2lvbihvcHRpb25zPXt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hTZXJ2ZXJJbmZvKG9wdGlvbnMpLnRoZW4oKHtodHRwX2FwaV92ZXJzaW9ufSkgPT4ge1xuICAgICAgcmV0dXJuIGh0dHBfYXBpX3ZlcnNpb247XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBiYXRjaCByZXF1ZXN0cywgY2h1bmtpbmcgdGhlbSBhY2NvcmRpbmcgdG8gdGhlIGJhdGNoX21heF9yZXF1ZXN0c1xuICAgKiBzZXJ2ZXIgc2V0dGluZyB3aGVuIG5lZWRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXl9ICByZXF1ZXN0cyAgICAgVGhlIGxpc3Qgb2YgYmF0Y2ggc3VicmVxdWVzdHMgdG8gcGVyZm9ybS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgX2JhdGNoUmVxdWVzdHMocmVxdWVzdHMsIG9wdGlvbnM9e30pIHtcbiAgICBjb25zdCBoZWFkZXJzID0gey4uLnRoaXMuZGVmYXVsdFJlcU9wdGlvbnMuaGVhZGVycywgLi4ub3B0aW9ucy5oZWFkZXJzfTtcbiAgICBpZiAoIXJlcXVlc3RzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZldGNoU2VydmVyU2V0dGluZ3MoKVxuICAgICAgLnRoZW4oc2VydmVyU2V0dGluZ3MgPT4ge1xuICAgICAgICBjb25zdCBtYXhSZXF1ZXN0cyA9IHNlcnZlclNldHRpbmdzW1wiYmF0Y2hfbWF4X3JlcXVlc3RzXCJdO1xuICAgICAgICBpZiAobWF4UmVxdWVzdHMgJiYgcmVxdWVzdHMubGVuZ3RoID4gbWF4UmVxdWVzdHMpIHtcbiAgICAgICAgICBjb25zdCBjaHVua3MgPSBwYXJ0aXRpb24ocmVxdWVzdHMsIG1heFJlcXVlc3RzKTtcbiAgICAgICAgICByZXR1cm4gcE1hcChjaHVua3MsIGNodW5rID0+IHRoaXMuX2JhdGNoUmVxdWVzdHMoY2h1bmssIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlKHtcbiAgICAgICAgICBwYXRoOiBlbmRwb2ludChcImJhdGNoXCIpLFxuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBkZWZhdWx0czoge2hlYWRlcnN9LFxuICAgICAgICAgICAgcmVxdWVzdHM6IHJlcXVlc3RzXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgIC8vIHdlIG9ubHkgY2FyZSBhYm91dCB0aGUgcmVzcG9uc2VzXG4gICAgICAgICAgLnRoZW4oKHtyZXNwb25zZXN9KSA9PiByZXNwb25zZXMpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYmF0Y2ggcmVxdWVzdHMgdG8gdGhlIHJlbW90ZSBzZXJ2ZXIuXG4gICAqXG4gICAqIE5vdGU6IFJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICpcbiAgICogQGlnbm9yZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgICAgICAgICAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gdG8gdXNlIGZvciBkZXNjcmliaW5nIGJhdGNoIG9wcy5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIFtvcHRpb25zPXt9XSAgICAgICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgW29wdGlvbnMuc2FmZV0gICAgICAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICBbb3B0aW9ucy5idWNrZXRdICAgICAgICAgIFRoZSBidWNrZXQgbmFtZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBbb3B0aW9ucy5oZWFkZXJzXSAgICAgICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBbb3B0aW9ucy5hZ2dyZWdhdGU9ZmFsc2VdIFByb2R1Y2VzIGFuIGFnZ3JlZ2F0ZWQgcmVzdWx0IG9iamVjdC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIEBub2JhdGNoKFwiQ2FuJ3QgdXNlIGJhdGNoIHdpdGhpbiBhIGJhdGNoIVwiKVxuICBiYXRjaChmbiwgb3B0aW9ucz17fSkge1xuICAgIGNvbnN0IHJvb3RCYXRjaCA9IG5ldyBLaW50b0NsaWVudEJhc2UodGhpcy5yZW1vdGUsIHtcbiAgICAgIC4uLnRoaXMuX29wdGlvbnMsXG4gICAgICAuLi50aGlzLl9nZXRSZXF1ZXN0T3B0aW9ucyhvcHRpb25zKSxcbiAgICAgIGJhdGNoOiB0cnVlXG4gICAgfSk7XG4gICAgbGV0IGJ1Y2tldEJhdGNoLCBjb2xsQmF0Y2g7XG4gICAgaWYgKG9wdGlvbnMuYnVja2V0KSB7XG4gICAgICBidWNrZXRCYXRjaCA9IHJvb3RCYXRjaC5idWNrZXQob3B0aW9ucy5idWNrZXQpO1xuICAgICAgaWYgKG9wdGlvbnMuY29sbGVjdGlvbikge1xuICAgICAgICBjb2xsQmF0Y2ggPSBidWNrZXRCYXRjaC5jb2xsZWN0aW9uKG9wdGlvbnMuY29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJhdGNoQ2xpZW50ID0gY29sbEJhdGNoIHx8IGJ1Y2tldEJhdGNoIHx8IHJvb3RCYXRjaDtcbiAgICB0cnkge1xuICAgICAgZm4oYmF0Y2hDbGllbnQpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2JhdGNoUmVxdWVzdHMocm9vdEJhdGNoLl9yZXF1ZXN0cywgb3B0aW9ucylcbiAgICAgIC50aGVuKChyZXNwb25zZXMpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWdncmVnYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0ZShyZXNwb25zZXMsIHJvb3RCYXRjaC5fcmVxdWVzdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZXM7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhbiBhdG9taWMgSFRUUCByZXF1ZXN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICByZXF1ZXN0ICAgICAgICAgICAgIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnM9e31dICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnJhdz1mYWxzZV0gSWYgdHJ1ZSwgcmVzb2x2ZSB3aXRoIGZ1bGwgcmVzcG9uc2Ugb2JqZWN0LCBpbmNsdWRpbmcganNvbiBib2R5IGFuZCBoZWFkZXJzIGluc3RlYWQgb2YganVzdCBqc29uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgZXhlY3V0ZShyZXF1ZXN0LCBvcHRpb25zPXtyYXc6IGZhbHNlfSkge1xuICAgIC8vIElmIHdlJ3JlIHdpdGhpbiBhIGJhdGNoLCBhZGQgdGhlIHJlcXVlc3QgdG8gdGhlIHN0YWNrIHRvIHNlbmQgYXQgb25jZS5cbiAgICBpZiAodGhpcy5faXNCYXRjaCkge1xuICAgICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICAgIC8vIFJlc29sdmUgd2l0aCBhIG1lc3NhZ2UgaW4gY2FzZSBwZW9wbGUgYXR0ZW1wdCBhdCBjb25zdW1pbmcgdGhlIHJlc3VsdFxuICAgICAgLy8gZnJvbSB3aXRoaW4gYSBiYXRjaCBvcGVyYXRpb24uXG4gICAgICBjb25zdCBtc2cgPSBcIlRoaXMgcmVzdWx0IGlzIGdlbmVyYXRlZCBmcm9tIHdpdGhpbiBhIGJhdGNoIFwiICtcbiAgICAgICAgICAgICAgICAgIFwib3BlcmF0aW9uIGFuZCBzaG91bGQgbm90IGJlIGNvbnN1bWVkLlwiO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvcHRpb25zLnJhdyA/IHtqc29uOiBtc2d9IDogbXNnKTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuZmV0Y2hTZXJ2ZXJTZXR0aW5ncygpXG4gICAgICAudGhlbihfID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5yZXF1ZXN0KHRoaXMucmVtb3RlICsgcmVxdWVzdC5wYXRoLCB7XG4gICAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LmJvZHkpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIG9wdGlvbnMucmF3ID8gcHJvbWlzZSA6IHByb21pc2UudGhlbigoe2pzb259KSA9PiBqc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgYnVja2V0cy5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3RbXSwgRXJyb3I+fVxuICAgKi9cbiAgbGlzdEJ1Y2tldHMob3B0aW9ucz17fSkge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGUoe1xuICAgICAgcGF0aDogZW5kcG9pbnQoXCJidWNrZXRcIiksXG4gICAgICBoZWFkZXJzOiB7Li4udGhpcy5kZWZhdWx0UmVxT3B0aW9ucy5oZWFkZXJzLCAuLi5vcHRpb25zLmhlYWRlcnN9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBidWNrZXQgb24gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIGlkICAgICAgICAgICAgICAgIFRoZSBidWNrZXQgbmFtZS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIFtvcHRpb25zPXt9XSAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gIFtvcHRpb25zLmRhdGFdICAgIFRoZSBidWNrZXQgZGF0YSBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBbb3B0aW9ucy5zYWZlXSAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBbb3B0aW9ucy5oZWFkZXJzXSBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgY3JlYXRlQnVja2V0KGlkLCBvcHRpb25zPXt9KSB7XG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBidWNrZXQgaWQgaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICAvLyBOb3RlIHRoYXQgd2Ugc2ltcGx5IGlnbm9yZSBhbnkgXCJidWNrZXRcIiBvcHRpb24gcGFzc2VkIGhlcmUsIGFzIHRoZSBvbmVcbiAgICAvLyB3ZSdyZSBpbnRlcmVzdGVkIGluIGlzIHRoZSBvbmUgcHJvdmlkZWQgYXMgYSByZXF1aXJlZCBhcmd1bWVudC5cbiAgICBjb25zdCByZXFPcHRpb25zID0gdGhpcy5fZ2V0UmVxdWVzdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgeyBkYXRhPXt9LCBwZXJtaXNzaW9ucyB9ID0gcmVxT3B0aW9ucztcbiAgICBkYXRhLmlkID0gaWQ7XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiYnVja2V0XCIsIGlkKTtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKHJlcXVlc3RzLmNyZWF0ZVJlcXVlc3QocGF0aCwgeyBkYXRhLCBwZXJtaXNzaW9ucyB9LCByZXFPcHRpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIGJ1Y2tldCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBpZ25vcmVcbiAgICogQHBhcmFtICB7T2JqZWN0fFN0cmluZ30gYnVja2V0ICAgICAgICAgICAgICAgICAgVGhlIGJ1Y2tldCB0byBkZWxldGUuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgIFtvcHRpb25zPXt9XSAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuc2FmZV0gICAgICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICBbb3B0aW9ucy5oZWFkZXJzXSAgICAgICBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICBbb3B0aW9ucy5sYXN0X21vZGlmaWVkXSBUaGUgbGFzdF9tb2RpZmllZCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBkZWxldGVCdWNrZXQoYnVja2V0LCBvcHRpb25zPXt9KSB7XG4gICAgY29uc3QgYnVja2V0T2JqID0gdG9EYXRhQm9keShidWNrZXQpO1xuICAgIGlmICghYnVja2V0T2JqLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGJ1Y2tldCBpZCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImJ1Y2tldFwiLCBidWNrZXRPYmouaWQpO1xuICAgIGNvbnN0IHsgbGFzdF9tb2RpZmllZCB9ID0geyBidWNrZXRPYmogfTtcbiAgICBjb25zdCByZXFPcHRpb25zID0gdGhpcy5fZ2V0UmVxdWVzdE9wdGlvbnMoeyBsYXN0X21vZGlmaWVkLCAuLi5vcHRpb25zIH0pO1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGUocmVxdWVzdHMuZGVsZXRlUmVxdWVzdChwYXRoLCByZXFPcHRpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgYnVja2V0cyBvbiB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAaWdub3JlXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuc2FmZV0gICAgICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5oZWFkZXJzXSAgICAgICBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBbb3B0aW9ucy5sYXN0X21vZGlmaWVkXSBUaGUgbGFzdF9tb2RpZmllZCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBAc3VwcG9ydChcIjEuNFwiLCBcIjIuMFwiKVxuICBkZWxldGVCdWNrZXRzKG9wdGlvbnM9e30pIHtcbiAgICBjb25zdCByZXFPcHRpb25zID0gdGhpcy5fZ2V0UmVxdWVzdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiYnVja2V0XCIpO1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGUocmVxdWVzdHMuZGVsZXRlUmVxdWVzdChwYXRoLCByZXFPcHRpb25zKSk7XG4gIH1cbn1cbiIsIi8qKlxuICogRXhwb3J0cyBiYXRjaCByZXNwb25zZXMgYXMgYSByZXN1bHQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzcG9uc2VzIFRoZSBiYXRjaCBzdWJyZXF1ZXN0IHJlc3BvbnNlcy5cbiAqIEBwYXJhbSAge0FycmF5fSByZXF1ZXN0cyAgVGhlIGluaXRpYWwgaXNzdWVkIHJlcXVlc3RzLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWdncmVnYXRlKHJlc3BvbnNlcz1bXSwgcmVxdWVzdHM9W10pIHtcbiAgaWYgKHJlc3BvbnNlcy5sZW5ndGggIT09IHJlcXVlc3RzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlcyBsZW5ndGggc2hvdWxkIG1hdGNoIHJlcXVlc3RzIG9uZS5cIik7XG4gIH1cbiAgY29uc3QgcmVzdWx0cyA9IHtcbiAgICBlcnJvcnM6ICAgIFtdLFxuICAgIHB1Ymxpc2hlZDogW10sXG4gICAgY29uZmxpY3RzOiBbXSxcbiAgICBza2lwcGVkOiAgIFtdLFxuICB9O1xuICByZXR1cm4gcmVzcG9uc2VzLnJlZHVjZSgoYWNjLCByZXNwb25zZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCB7c3RhdHVzfSA9IHJlc3BvbnNlO1xuICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDQwMCkge1xuICAgICAgYWNjLnB1Ymxpc2hlZC5wdXNoKHJlc3BvbnNlLmJvZHkpO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIGFjYy5za2lwcGVkLnB1c2gocmVzcG9uc2UuYm9keSk7XG4gICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQxMikge1xuICAgICAgYWNjLmNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgLy8gWFhYOiBzcGVjaWZ5aW5nIHRoZSB0eXBlIGlzIHByb2JhYmx5IHN1cGVyZmx1b3VzXG4gICAgICAgIHR5cGU6IFwib3V0Z29pbmdcIixcbiAgICAgICAgbG9jYWw6IHJlcXVlc3RzW2luZGV4XS5ib2R5LFxuICAgICAgICByZW1vdGU6IHJlc3BvbnNlLmJvZHkuZGV0YWlscyAmJlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkuZGV0YWlscy5leGlzdGluZyB8fCBudWxsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjLmVycm9ycy5wdXNoKHtcbiAgICAgICAgcGF0aDogcmVzcG9uc2UucGF0aCxcbiAgICAgICAgc2VudDogcmVxdWVzdHNbaW5kZXhdLFxuICAgICAgICBlcnJvcjogcmVzcG9uc2UuYm9keVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHJlc3VsdHMpO1xufVxuIiwiaW1wb3J0IHsgdG9EYXRhQm9keSwgaXNPYmplY3QgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSBcIi4vY29sbGVjdGlvblwiO1xuaW1wb3J0ICogYXMgcmVxdWVzdHMgZnJvbSBcIi4vcmVxdWVzdHNcIjtcbmltcG9ydCBlbmRwb2ludCBmcm9tIFwiLi9lbmRwb2ludFwiO1xuXG5cbi8qKlxuICogQWJzdHJhY3QgcmVwcmVzZW50YXRpb24gb2YgYSBzZWxlY3RlZCBidWNrZXQuXG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWNrZXQge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSAge0tpbnRvQ2xpZW50fSBjbGllbnQgICAgICAgICAgICBUaGUgY2xpZW50IGluc3RhbmNlLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgbmFtZSAgICAgICAgICAgICAgVGhlIGJ1Y2tldCBuYW1lLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgW29wdGlvbnM9e31dICAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgIFtvcHRpb25zLmhlYWRlcnNdIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICBbb3B0aW9ucy5zYWZlXSAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIG5hbWUsIG9wdGlvbnM9e30pIHtcbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgLyoqXG4gICAgICogVGhlIGJ1Y2tldCBuYW1lLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAaWdub3JlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9pc0JhdGNoID0gISFvcHRpb25zLmJhdGNoO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlcyBwYXNzZWQgcmVxdWVzdCBvcHRpb25zIHdpdGggZGVmYXVsdCBidWNrZXQgb25lcywgaWYgYW55LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyB0byBtZXJnZS5cbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgVGhlIG1lcmdlZCBvcHRpb25zLlxuICAgKi9cbiAgX2J1Y2tldE9wdGlvbnMob3B0aW9ucz17fSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJ1Y2tldDogdGhpcy5uYW1lLFxuICAgICAgYmF0Y2g6IHRoaXMuX2lzQmF0Y2hcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgYSBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lICAgICAgICAgICAgICBUaGUgY29sbGVjdGlvbiBuYW1lLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zLmhlYWRlcnNdIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnNhZmVdICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbn1cbiAgICovXG4gIGNvbGxlY3Rpb24obmFtZSwgb3B0aW9ucz17fSkge1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLmNsaWVudCwgdGhpcywgbmFtZSwgdGhpcy5fYnVja2V0T3B0aW9ucyhvcHRpb25zKSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYnVja2V0IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnM9e31dICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBnZXREYXRhKG9wdGlvbnM9e30pIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZSh7XG4gICAgICBwYXRoOiBlbmRwb2ludChcImJ1Y2tldFwiLCB0aGlzLm5hbWUpLFxuICAgICAgaGVhZGVyczogey4uLnRoaXMub3B0aW9ucy5oZWFkZXJzLCAuLi5vcHRpb25zLmhlYWRlcnN9XG4gICAgfSlcbiAgICAudGhlbigocmVzKSA9PiByZXMuZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGJ1Y2tldCBkYXRhLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBkYXRhICAgICAgICAgICAgICAgICAgICBUaGUgYnVja2V0IGRhdGEgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucz17fV0gICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zLmhlYWRlcnNdICAgICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnNhZmVdICAgICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMucGF0Y2hdICAgICAgICAgVGhlIHBhdGNoIG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgW29wdGlvbnMubGFzdF9tb2RpZmllZF0gVGhlIGxhc3RfbW9kaWZpZWQgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgc2V0RGF0YShkYXRhLCBvcHRpb25zPXt9KSB7XG4gICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBidWNrZXQgb2JqZWN0IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBidWNrZXQgPSB7Li4uZGF0YSwgaWQ6IHRoaXMubmFtZX07XG5cbiAgICAvLyBGb3IgZGVmYXVsdCBidWNrZXQsIHdlIG5lZWQgdG8gZHJvcCB0aGUgaWQgZnJvbSB0aGUgZGF0YSBvYmplY3QuXG4gICAgLy8gQnVnIGluIEtpbnRvIDwgMy4xLjFcbiAgICBjb25zdCBidWNrZXRJZCA9IGJ1Y2tldC5pZDtcbiAgICBpZiAoYnVja2V0LmlkID09PSBcImRlZmF1bHRcIikge1xuICAgICAgZGVsZXRlIGJ1Y2tldC5pZDtcbiAgICB9XG5cbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJidWNrZXRcIiwgYnVja2V0SWQpO1xuICAgIGNvbnN0IHsgcGVybWlzc2lvbnMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVxT3B0aW9ucyA9IHsuLi50aGlzLl9idWNrZXRPcHRpb25zKG9wdGlvbnMpfTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMudXBkYXRlUmVxdWVzdChwYXRoLCB7ZGF0YTogYnVja2V0LCBwZXJtaXNzaW9uc30sIHJlcU9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHJlcXVlc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiBjb2xsZWN0aW9ucyBpbiB0aGUgY3VycmVudCBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnM9e31dICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8T2JqZWN0PiwgRXJyb3I+fVxuICAgKi9cbiAgbGlzdENvbGxlY3Rpb25zKG9wdGlvbnM9e30pIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZSh7XG4gICAgICBwYXRoOiBlbmRwb2ludChcImNvbGxlY3Rpb25cIiwgdGhpcy5uYW1lKSxcbiAgICAgIGhlYWRlcnM6IHsuLi50aGlzLm9wdGlvbnMuaGVhZGVycywgLi4ub3B0aW9ucy5oZWFkZXJzfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29sbGVjdGlvbiBpbiBjdXJyZW50IGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfHVuZGVmaW5lZH0gIGlkICAgICAgICAgIFRoZSBjb2xsZWN0aW9uIGlkLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucz17fV0gICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5zYWZlXSAgICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5oZWFkZXJzXSAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnMucGVybWlzc2lvbnNdIFRoZSBwZXJtaXNzaW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zLmRhdGFdICAgICAgICBUaGUgZGF0YSBvYmplY3QuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBjcmVhdGVDb2xsZWN0aW9uKGlkLCBvcHRpb25zPXt9KSB7XG4gICAgY29uc3QgcmVxT3B0aW9ucyA9IHRoaXMuX2J1Y2tldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgeyBwZXJtaXNzaW9ucywgZGF0YT17fSB9ID0gcmVxT3B0aW9ucztcbiAgICBkYXRhLmlkID0gaWQ7XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiY29sbGVjdGlvblwiLCB0aGlzLm5hbWUsIGlkKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMuY3JlYXRlUmVxdWVzdChwYXRoLCB7ZGF0YSwgcGVybWlzc2lvbnN9LCByZXFPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgY29sbGVjdGlvbiBmcm9tIHRoZSBjdXJyZW50IGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiAgICAgICAgICAgICAgVGhlIGNvbGxlY3Rpb24gdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICBbb3B0aW9ucz17fV0gICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgIFtvcHRpb25zLmhlYWRlcnNdICAgICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLnNhZmVdICAgICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgW29wdGlvbnMubGFzdF9tb2RpZmllZF0gVGhlIGxhc3RfbW9kaWZpZWQgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgZGVsZXRlQ29sbGVjdGlvbihjb2xsZWN0aW9uLCBvcHRpb25zPXt9KSB7XG4gICAgY29uc3QgY29sbGVjdGlvbk9iaiA9IHRvRGF0YUJvZHkoY29sbGVjdGlvbik7XG4gICAgaWYgKCFjb2xsZWN0aW9uT2JqLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGNvbGxlY3Rpb24gaWQgaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7aWQsIGxhc3RfbW9kaWZpZWR9ID0gY29sbGVjdGlvbk9iajtcbiAgICBjb25zdCByZXFPcHRpb25zID0gdGhpcy5fYnVja2V0T3B0aW9ucyh7IGxhc3RfbW9kaWZpZWQsIC4uLm9wdGlvbnMgfSk7XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiY29sbGVjdGlvblwiLCB0aGlzLm5hbWUsIGlkKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMuZGVsZXRlUmVxdWVzdChwYXRoLCByZXFPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgZ3JvdXBzIGluIHRoZSBjdXJyZW50IGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxPYmplY3Q+LCBFcnJvcj59XG4gICAqL1xuICBsaXN0R3JvdXBzKG9wdGlvbnM9e30pIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZSh7XG4gICAgICBwYXRoOiBlbmRwb2ludChcImdyb3VwXCIsIHRoaXMubmFtZSksXG4gICAgICBoZWFkZXJzOiB7Li4udGhpcy5vcHRpb25zLmhlYWRlcnMsIC4uLm9wdGlvbnMuaGVhZGVyc31cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGdyb3VwIGluIGN1cnJlbnQgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGlkICAgICAgICAgICAgICAgIFRoZSBncm91cCBpZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGdldEdyb3VwKGlkLCBvcHRpb25zPXt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUoe1xuICAgICAgcGF0aDogZW5kcG9pbnQoXCJncm91cFwiLCB0aGlzLm5hbWUsIGlkKSxcbiAgICAgIGhlYWRlcnM6IHsuLi50aGlzLm9wdGlvbnMuaGVhZGVycywgLi4ub3B0aW9ucy5oZWFkZXJzfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgZ3JvdXAgaW4gY3VycmVudCBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ3x1bmRlZmluZWR9ICBpZCAgICAgICAgICAgICAgICAgICAgVGhlIGdyb3VwIGlkLlxuICAgKiBAcGFyYW0gIHtBcnJheTxTdHJpbmc+fSAgICAgW21lbWJlcnM9W11dICAgICAgICAgIFRoZSBsaXN0IG9mIHByaW5jaXBhbHMuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgICAgICBbb3B0aW9ucz17fV0gICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICAgICAgW29wdGlvbnMuZGF0YV0gICAgICAgIFRoZSBkYXRhIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgICAgIFtvcHRpb25zLnBlcm1pc3Npb25zXSBUaGUgcGVybWlzc2lvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICAgICAgW29wdGlvbnMuc2FmZV0gICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgICAgIFtvcHRpb25zLmhlYWRlcnNdICAgICBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgY3JlYXRlR3JvdXAoaWQsIG1lbWJlcnM9W10sIG9wdGlvbnM9e30pIHtcbiAgICBjb25zdCByZXFPcHRpb25zID0gdGhpcy5fYnVja2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgLi4ub3B0aW9ucy5kYXRhLFxuICAgICAgaWQsXG4gICAgICBtZW1iZXJzXG4gICAgfTtcbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJncm91cFwiLCB0aGlzLm5hbWUsIGlkKTtcbiAgICBjb25zdCB7cGVybWlzc2lvbnN9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMuY3JlYXRlUmVxdWVzdChwYXRoLCB7ZGF0YSwgcGVybWlzc2lvbnN9LCByZXFPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIGdyb3VwIGluIGN1cnJlbnQgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBncm91cCAgICAgICAgICAgICAgICAgICBUaGUgZ3JvdXAgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucz17fV0gICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zLmRhdGFdICAgICAgICAgIFRoZSBkYXRhIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnMucGVybWlzc2lvbnNdICAgVGhlIHBlcm1pc3Npb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuc2FmZV0gICAgICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5oZWFkZXJzXSAgICAgICBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBbb3B0aW9ucy5sYXN0X21vZGlmaWVkXSBUaGUgbGFzdF9tb2RpZmllZCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICB1cGRhdGVHcm91cChncm91cCwgb3B0aW9ucz17fSkge1xuICAgIGlmICghaXNPYmplY3QoZ3JvdXApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGdyb3VwIG9iamVjdCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGlmICghZ3JvdXAuaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgZ3JvdXAgaWQgaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXFPcHRpb25zID0gdGhpcy5fYnVja2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgLi4ub3B0aW9ucy5kYXRhLFxuICAgICAgLi4uZ3JvdXBcbiAgICB9O1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImdyb3VwXCIsIHRoaXMubmFtZSwgZ3JvdXAuaWQpO1xuICAgIGNvbnN0IHtwZXJtaXNzaW9uc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0cy51cGRhdGVSZXF1ZXN0KHBhdGgsIHtkYXRhLCBwZXJtaXNzaW9uc30sIHJlcU9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHJlcXVlc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBncm91cCBmcm9tIHRoZSBjdXJyZW50IGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fFN0cmluZ30gZ3JvdXAgICAgICAgICAgICAgICAgICAgVGhlIGdyb3VwIHRvIGRlbGV0ZS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgW29wdGlvbnM9e31dICAgICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICBbb3B0aW9ucy5oZWFkZXJzXSAgICAgICBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5zYWZlXSAgICAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0gICAgICAgIFtvcHRpb25zLmxhc3RfbW9kaWZpZWRdIFRoZSBsYXN0X21vZGlmaWVkIG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGRlbGV0ZUdyb3VwKGdyb3VwLCBvcHRpb25zPXt9KSB7XG4gICAgY29uc3QgZ3JvdXBPYmogPSB0b0RhdGFCb2R5KGdyb3VwKTtcbiAgICBjb25zdCB7aWQsIGxhc3RfbW9kaWZpZWR9ID0gZ3JvdXBPYmo7XG4gICAgY29uc3QgcmVxT3B0aW9ucyA9IHRoaXMuX2J1Y2tldE9wdGlvbnMoe2xhc3RfbW9kaWZpZWQsIC4uLm9wdGlvbnN9KTtcbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJncm91cFwiLCB0aGlzLm5hbWUsIGlkKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMuZGVsZXRlUmVxdWVzdChwYXRoLCByZXFPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgcGVybWlzc2lvbnMgZm9yIHRoaXMgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zPXt9XSAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgZ2V0UGVybWlzc2lvbnMob3B0aW9ucz17fSkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHtcbiAgICAgIHBhdGg6IGVuZHBvaW50KFwiYnVja2V0XCIsIHRoaXMubmFtZSksXG4gICAgICBoZWFkZXJzOiB7Li4udGhpcy5vcHRpb25zLmhlYWRlcnMsIC4uLm9wdGlvbnMuaGVhZGVyc31cbiAgICB9KVxuICAgIC50aGVuKChyZXMpID0+IHJlcy5wZXJtaXNzaW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIGV4aXN0aW5nIGJ1Y2tldCBwZXJtaXNzaW9ucyB3aXRoIHRoZSBvbmVzIHByb3ZpZGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBwZXJtaXNzaW9ucyAgICAgICAgICAgICBUaGUgcGVybWlzc2lvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucz17fV0gICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuc2FmZV0gICAgICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5oZWFkZXJzXSAgICAgICBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9ucy5sYXN0X21vZGlmaWVkXSBUaGUgbGFzdF9tb2RpZmllZCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBzZXRQZXJtaXNzaW9ucyhwZXJtaXNzaW9ucywgb3B0aW9ucz17fSkge1xuICAgIGlmICghaXNPYmplY3QocGVybWlzc2lvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIHBlcm1pc3Npb25zIG9iamVjdCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImJ1Y2tldFwiLCB0aGlzLm5hbWUpO1xuICAgIGNvbnN0IHJlcU9wdGlvbnMgPSB7Li4udGhpcy5fYnVja2V0T3B0aW9ucyhvcHRpb25zKX07XG4gICAgY29uc3Qge2xhc3RfbW9kaWZpZWR9ID0gb3B0aW9ucztcbiAgICBjb25zdCBkYXRhID0ge2xhc3RfbW9kaWZpZWR9O1xuICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0cy51cGRhdGVSZXF1ZXN0KHBhdGgsIHtkYXRhLCBwZXJtaXNzaW9uc30sIHJlcU9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHJlcXVlc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGJhdGNoIG9wZXJhdGlvbnMgYXQgdGhlIGN1cnJlbnQgYnVja2V0IGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgICAgICAgICAgICAgICAgVGhlIGJhdGNoIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIFtvcHRpb25zPXt9XSAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIFtvcHRpb25zLmhlYWRlcnNdICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBbb3B0aW9ucy5zYWZlXSAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBbb3B0aW9ucy5hZ2dyZWdhdGVdICBQcm9kdWNlcyBhIGdyb3VwZWQgcmVzdWx0IG9iamVjdC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGJhdGNoKGZuLCBvcHRpb25zPXt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmJhdGNoKGZuLCB0aGlzLl9idWNrZXRPcHRpb25zKG9wdGlvbnMpKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgdG9EYXRhQm9keSwgcXNpZnksIGlzT2JqZWN0IH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCAqIGFzIHJlcXVlc3RzIGZyb20gXCIuL3JlcXVlc3RzXCI7XG5pbXBvcnQgZW5kcG9pbnQgZnJvbSBcIi4vZW5kcG9pbnRcIjtcblxuXG4vKipcbiAqIEFic3RyYWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgc2VsZWN0ZWQgY29sbGVjdGlvbi5cbiAqXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbGxlY3Rpb24ge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSAge0tpbnRvQ2xpZW50fSAgY2xpZW50ICAgICAgICAgICAgVGhlIGNsaWVudCBpbnN0YW5jZS5cbiAgICogQHBhcmFtICB7QnVja2V0fSAgICAgICBidWNrZXQgICAgICAgICAgICBUaGUgYnVja2V0IGluc3RhbmNlLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIG5hbWUgICAgICAgICAgICAgIFRoZSBjb2xsZWN0aW9uIG5hbWUuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgW29wdGlvbnM9e31dICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIFtvcHRpb25zLmhlYWRlcnNdIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgW29wdGlvbnMuc2FmZV0gICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50LCBidWNrZXQsIG5hbWUsIG9wdGlvbnM9e30pIHtcbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuYnVja2V0ID0gYnVja2V0O1xuICAgIC8qKlxuICAgICAqIFRoZSBjb2xsZWN0aW9uIG5hbWUuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY29sbGVjdGlvbiBvcHRpb25zIG9iamVjdCwgZW1iZWRkaW5nIHRoZSBkZWZhdWx0IGJ1Y2tldCBvbmVzLlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMuYnVja2V0Lm9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi50aGlzLmJ1Y2tldC5vcHRpb25zICYmIHRoaXMuYnVja2V0Lm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5faXNCYXRjaCA9ICEhb3B0aW9ucy5iYXRjaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZXMgcGFzc2VkIHJlcXVlc3Qgb3B0aW9ucyB3aXRoIGRlZmF1bHQgYnVja2V0IGFuZCBjb2xsZWN0aW9uIG9uZXMsIGlmXG4gICAqIGFueS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgdG8gbWVyZ2UuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgIFRoZSBtZXJnZWQgb3B0aW9ucy5cbiAgICovXG4gIF9jb2xsT3B0aW9ucyhvcHRpb25zPXt9KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGNvbGxlY3Rpb24gZGF0YS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGdldERhdGEob3B0aW9ucz17fSkge1xuICAgIGNvbnN0IHsgaGVhZGVycyB9ID0gdGhpcy5fY29sbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUoe1xuICAgICAgcGF0aDogZW5kcG9pbnQoXCJjb2xsZWN0aW9uXCIsIHRoaXMuYnVja2V0Lm5hbWUsIHRoaXMubmFtZSksXG4gICAgICBoZWFkZXJzXG4gICAgfSlcbiAgICAudGhlbihyZXMgPT4gcmVzLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjb2xsZWN0aW9uIGRhdGEuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBkYXRhICAgICAgICAgICAgICAgICAgICBUaGUgY29sbGVjdGlvbiBkYXRhIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIFtvcHRpb25zPXt9XSAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIFtvcHRpb25zLmhlYWRlcnNdICAgICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBbb3B0aW9ucy5zYWZlXSAgICAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBbb3B0aW9ucy5wYXRjaF0gICAgICAgICBUaGUgcGF0Y2ggb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgW29wdGlvbnMubGFzdF9tb2RpZmllZF0gVGhlIGxhc3RfbW9kaWZpZWQgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgc2V0RGF0YShkYXRhLCBvcHRpb25zPXt9KSB7XG4gICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBjb2xsZWN0aW9uIG9iamVjdCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHJlcU9wdGlvbnMgPSB0aGlzLl9jb2xsT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB7IHBlcm1pc3Npb25zIH0gPSByZXFPcHRpb25zO1xuXG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiY29sbGVjdGlvblwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0cy51cGRhdGVSZXF1ZXN0KHBhdGgsIHtkYXRhLCBwZXJtaXNzaW9uc30sIHJlcU9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHJlcXVlc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiBwZXJtaXNzaW9ucyBmb3IgdGhpcyBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zPXt9XSAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzXSBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgZ2V0UGVybWlzc2lvbnMob3B0aW9ucz17fSkge1xuICAgIGNvbnN0IHsgaGVhZGVycyB9ID0gdGhpcy5fY29sbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUoe1xuICAgICAgcGF0aDogZW5kcG9pbnQoXCJjb2xsZWN0aW9uXCIsIHRoaXMuYnVja2V0Lm5hbWUsIHRoaXMubmFtZSksXG4gICAgICBoZWFkZXJzXG4gICAgfSlcbiAgICAudGhlbihyZXMgPT4gcmVzLnBlcm1pc3Npb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgZXhpc3RpbmcgY29sbGVjdGlvbiBwZXJtaXNzaW9ucyB3aXRoIHRoZSBvbmVzIHByb3ZpZGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgcGVybWlzc2lvbnMgICAgICAgICAgICAgVGhlIHBlcm1pc3Npb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIFtvcHRpb25zPXt9XSAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgW29wdGlvbnMuaGVhZGVyc10gICAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gIFtvcHRpb25zLnNhZmVdICAgICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgIFtvcHRpb25zLmxhc3RfbW9kaWZpZWRdIFRoZSBsYXN0X21vZGlmaWVkIG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIHNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zLCBvcHRpb25zPXt9KSB7XG4gICAgaWYgKCFpc09iamVjdChwZXJtaXNzaW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgcGVybWlzc2lvbnMgb2JqZWN0IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVxT3B0aW9ucyA9IHRoaXMuX2NvbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImNvbGxlY3Rpb25cIiwgdGhpcy5idWNrZXQubmFtZSwgdGhpcy5uYW1lKTtcbiAgICBjb25zdCBkYXRhID0geyBsYXN0X21vZGlmaWVkOiBvcHRpb25zLmxhc3RfbW9kaWZpZWQgfTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMudXBkYXRlUmVxdWVzdChwYXRoLCB7ZGF0YSwgcGVybWlzc2lvbnN9LCByZXFPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVjb3JkIGluIGN1cnJlbnQgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgcmVjb3JkICAgICAgICAgICAgVGhlIHJlY29yZCB0byBjcmVhdGUuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnMuaGVhZGVyc10gVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuc2FmZV0gICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgY3JlYXRlUmVjb3JkKHJlY29yZCwgb3B0aW9ucz17fSkge1xuICAgIGNvbnN0IHJlcU9wdGlvbnMgPSB0aGlzLl9jb2xsT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB7IHBlcm1pc3Npb25zIH0gPSByZXFPcHRpb25zO1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcInJlY29yZFwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUsIHJlY29yZC5pZCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzLmNyZWF0ZVJlcXVlc3QocGF0aCwge2RhdGE6IHJlY29yZCwgcGVybWlzc2lvbnN9LCByZXFPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgcmVjb3JkIGluIGN1cnJlbnQgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgcmVjb3JkICAgICAgICAgICAgICAgICAgVGhlIHJlY29yZCB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zPXt9XSAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW29wdGlvbnMuaGVhZGVyc10gICAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuc2FmZV0gICAgICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBbb3B0aW9ucy5sYXN0X21vZGlmaWVkXSBUaGUgbGFzdF9tb2RpZmllZCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICB1cGRhdGVSZWNvcmQocmVjb3JkLCBvcHRpb25zPXt9KSB7XG4gICAgaWYgKCFpc09iamVjdChyZWNvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIHJlY29yZCBvYmplY3QgaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXJlY29yZC5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSByZWNvcmQgaWQgaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXFPcHRpb25zID0gdGhpcy5fY29sbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgeyBwZXJtaXNzaW9ucyB9ID0gcmVxT3B0aW9ucztcbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJyZWNvcmRcIiwgdGhpcy5idWNrZXQubmFtZSwgdGhpcy5uYW1lLCByZWNvcmQuaWQpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0cy51cGRhdGVSZXF1ZXN0KHBhdGgsIHtkYXRhOiByZWNvcmQsIHBlcm1pc3Npb25zfSwgcmVxT3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIHJlY29yZCBmcm9tIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdHxTdHJpbmd9IHJlY29yZCAgICAgICAgICAgICAgICAgIFRoZSByZWNvcmQgdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICBbb3B0aW9ucz17fV0gICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgIFtvcHRpb25zLmhlYWRlcnNdICAgICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLnNhZmVdICAgICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgW29wdGlvbnMubGFzdF9tb2RpZmllZF0gVGhlIGxhc3RfbW9kaWZpZWQgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgZGVsZXRlUmVjb3JkKHJlY29yZCwgb3B0aW9ucz17fSkge1xuICAgIGNvbnN0IHJlY29yZE9iaiA9IHRvRGF0YUJvZHkocmVjb3JkKTtcbiAgICBpZiAoIXJlY29yZE9iai5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSByZWNvcmQgaWQgaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7aWQsIGxhc3RfbW9kaWZpZWR9ID0gcmVjb3JkT2JqO1xuICAgIGNvbnN0IHJlcU9wdGlvbnMgPSB0aGlzLl9jb2xsT3B0aW9ucyh7IGxhc3RfbW9kaWZpZWQsIC4uLm9wdGlvbnMgfSk7XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwicmVjb3JkXCIsIHRoaXMuYnVja2V0Lm5hbWUsIHRoaXMubmFtZSwgaWQpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0cy5kZWxldGVSZXF1ZXN0KHBhdGgsIHJlcU9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHJlcXVlc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHJlY29yZCBmcm9tIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gaWQgICAgICAgICAgICAgICAgVGhlIHJlY29yZCBpZCB0byByZXRyaWV2ZS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV0gICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGdldFJlY29yZChpZCwgb3B0aW9ucz17fSkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHtcbiAgICAgIHBhdGg6IGVuZHBvaW50KFwicmVjb3JkXCIsIHRoaXMuYnVja2V0Lm5hbWUsIHRoaXMubmFtZSwgaWQpLFxuICAgICAgLi4udGhpcy5fY29sbE9wdGlvbnMob3B0aW9ucyksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdHMgcmVjb3JkcyBmcm9tIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIFNvcnRpbmcgaXMgZG9uZSBieSBwYXNzaW5nIGEgYHNvcnRgIHN0cmluZyBvcHRpb246XG4gICAqXG4gICAqIC0gVGhlIGZpZWxkIHRvIG9yZGVyIHRoZSByZXN1bHRzIGJ5LCBwcmVmaXhlZCB3aXRoIGAtYCBmb3IgZGVzY2VuZGluZy5cbiAgICogRGVmYXVsdDogYC1sYXN0X21vZGlmaWVkYC5cbiAgICpcbiAgICogQHNlZSBodHRwOi8va2ludG8ucmVhZHRoZWRvY3MuaW8vZW4vc3RhYmxlL2NvcmUvYXBpL3Jlc291cmNlLmh0bWwjc29ydGluZ1xuICAgKlxuICAgKiBGaWx0ZXJpbmcgaXMgZG9uZSBieSBwYXNzaW5nIGEgYGZpbHRlcnNgIG9wdGlvbiBvYmplY3Q6XG4gICAqXG4gICAqIC0gYHtmaWVsZG5hbWU6IFwidmFsdWVcIn1gXG4gICAqIC0gYHttaW5fZmllbGRuYW1lOiA0MDAwfWBcbiAgICogLSBge2luX2ZpZWxkbmFtZTogXCIxLDIsM1wifWBcbiAgICogLSBge25vdF9maWVsZG5hbWU6IDB9YFxuICAgKiAtIGB7ZXhjbHVkZV9maWVsZG5hbWU6IFwiMCwxXCJ9YFxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly9raW50by5yZWFkdGhlZG9jcy5pby9lbi9zdGFibGUvY29yZS9hcGkvcmVzb3VyY2UuaHRtbCNmaWx0ZXJpbmdcbiAgICpcbiAgICogUGFnaW5hdGluZyBpcyBkb25lIGJ5IHBhc3NpbmcgYSBgbGltaXRgIG9wdGlvbiwgdGhlbiBjYWxsaW5nIHRoZSBgbmV4dCgpYFxuICAgKiBtZXRob2QgZnJvbSB0aGUgcmVzb2x2ZWQgcmVzdWx0IG9iamVjdCB0byBmZXRjaCB0aGUgbmV4dCBwYWdlLCBpZiBhbnkuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBbb3B0aW9ucz17fV0gICAgICAgICAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIFtvcHRpb25zLmhlYWRlcnNdICAgICAgICAgICAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIFtvcHRpb25zLmZpbHRlcnM9W11dICAgICAgICAgICAgVGhlIGZpbHRlcnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgW29wdGlvbnMuc29ydD1cIi1sYXN0X21vZGlmaWVkXCJdIFRoZSBzb3J0IGZpZWxkLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgW29wdGlvbnMubGltaXQ9bnVsbF0gICAgICAgICAgICBUaGUgbGltaXQgZmllbGQuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICBbb3B0aW9ucy5wYWdlcz0xXSAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2YgcmVzdWx0IHBhZ2VzIHRvIGFnZ3JlZ2F0ZS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgIFtvcHRpb25zLnNpbmNlPW51bGxdICAgICAgICAgICAgT25seSByZXRyaWV2ZSByZWNvcmRzIG1vZGlmaWVkIHNpbmNlIHRoZSBwcm92aWRlZCB0aW1lc3RhbXAuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBsaXN0UmVjb3JkcyhvcHRpb25zPXt9KSB7XG4gICAgY29uc3QgeyBodHRwIH0gPSB0aGlzLmNsaWVudDtcbiAgICBjb25zdCB7IHNvcnQsIGZpbHRlcnMsIGxpbWl0LCBwYWdlcywgc2luY2UgfSA9IHtcbiAgICAgIHNvcnQ6IFwiLWxhc3RfbW9kaWZpZWRcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIC8vIFNhZmV0eS9Db25zaXN0ZW5jeSBjaGVjayBvbiBFVGFnIHZhbHVlLlxuICAgIGlmIChzaW5jZSAmJiB0eXBlb2Yoc2luY2UpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgZm9yIHNpbmNlICgke3NpbmNlfSksIHNob3VsZCBiZSBFVGFnIHZhbHVlLmApO1xuICAgIH1cbiAgICBjb25zdCBjb2xsSGVhZGVycyA9IHRoaXMub3B0aW9ucy5oZWFkZXJzO1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcInJlY29yZFwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUpO1xuICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0gcXNpZnkoe1xuICAgICAgLi4uZmlsdGVycyxcbiAgICAgIF9zb3J0OiBzb3J0LFxuICAgICAgX2xpbWl0OiBsaW1pdCxcbiAgICAgIF9zaW5jZTogc2luY2UsXG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdHMgPSBbXSwgY3VycmVudCA9IDA7XG5cbiAgICBjb25zdCBuZXh0ID0gZnVuY3Rpb24obmV4dFBhZ2UpIHtcbiAgICAgIGlmICghbmV4dFBhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFnaW5hdGlvbiBleGhhdXN0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2Nlc3NOZXh0UGFnZShuZXh0UGFnZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHByb2Nlc3NOZXh0UGFnZSA9IChuZXh0UGFnZSkgPT4ge1xuICAgICAgcmV0dXJuIGh0dHAucmVxdWVzdChuZXh0UGFnZSwge2hlYWRlcnM6IGNvbGxIZWFkZXJzfSlcbiAgICAgICAgLnRoZW4oaGFuZGxlUmVzcG9uc2UpO1xuICAgIH07XG5cbiAgICBjb25zdCBwYWdlUmVzdWx0cyA9IChyZXN1bHRzLCBuZXh0UGFnZSwgZXRhZykgPT4ge1xuICAgICAgLy8gRVRhZyBzdHJpbmcgaXMgc3VwcG9zZWQgdG8gYmUgb3BhcXVlIGFuZCBzdG9yZWQgwqthcy1pc8K7LlxuICAgICAgLy8gRVRhZyBoZWFkZXIgdmFsdWVzIGFyZSBxdW90ZWQgKGJlY2F1c2Ugb2YgKiBhbmQgVy9cImZvb1wiKS5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhc3RfbW9kaWZpZWQ6IGV0YWcgPyBldGFnLnJlcGxhY2UoL1wiL2csIFwiXCIpIDogZXRhZyxcbiAgICAgICAgZGF0YTogcmVzdWx0cyxcbiAgICAgICAgbmV4dDogbmV4dC5iaW5kKG51bGwsIG5leHRQYWdlKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlUmVzcG9uc2UgPSAoe2hlYWRlcnMsIGpzb259KSA9PiB7XG4gICAgICBjb25zdCBuZXh0UGFnZSA9IGhlYWRlcnMuZ2V0KFwiTmV4dC1QYWdlXCIpO1xuICAgICAgY29uc3QgZXRhZyA9IGhlYWRlcnMuZ2V0KFwiRVRhZ1wiKTtcbiAgICAgIGlmICghcGFnZXMpIHtcbiAgICAgICAgcmV0dXJuIHBhZ2VSZXN1bHRzKGpzb24uZGF0YSwgbmV4dFBhZ2UsIGV0YWcpO1xuICAgICAgfVxuICAgICAgLy8gQWdncmVnYXRlIG5ldyByZXN1bHRzIHdpdGggcHJldmlvdXMgb25lc1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KGpzb24uZGF0YSk7XG4gICAgICBjdXJyZW50ICs9IDE7XG4gICAgICBpZiAoY3VycmVudCA+PSBwYWdlcyB8fCAhbmV4dFBhZ2UpIHtcbiAgICAgICAgLy8gUGFnaW5hdGlvbiBleGhhdXN0ZWRcbiAgICAgICAgcmV0dXJuIHBhZ2VSZXN1bHRzKHJlc3VsdHMsIG5leHRQYWdlLCBldGFnKTtcbiAgICAgIH1cbiAgICAgIC8vIEZvbGxvdyBuZXh0IHBhZ2VcbiAgICAgIHJldHVybiBwcm9jZXNzTmV4dFBhZ2UobmV4dFBhZ2UpO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZSh7XG4gICAgICBwYXRoOiBwYXRoICsgXCI/XCIgKyBxdWVyeXN0cmluZyxcbiAgICAgIC4uLnRoaXMuX2NvbGxPcHRpb25zKG9wdGlvbnMpLFxuICAgIH0sIHtyYXc6IHRydWV9KS50aGVuKGhhbmRsZVJlc3BvbnNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBiYXRjaCBvcGVyYXRpb25zIGF0IHRoZSBjdXJyZW50IGNvbGxlY3Rpb24gbGV2ZWwuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICAgICAgICAgICAgICAgICBUaGUgYmF0Y2ggb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgW29wdGlvbnM9e31dICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgW29wdGlvbnMuaGVhZGVyc10gICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gIFtvcHRpb25zLnNhZmVdICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gIFtvcHRpb25zLmFnZ3JlZ2F0ZV0gIFByb2R1Y2VzIGEgZ3JvdXBlZCByZXN1bHQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgYmF0Y2goZm4sIG9wdGlvbnM9e30pIHtcbiAgICBjb25zdCByZXFPcHRpb25zID0gdGhpcy5fY29sbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmJhdGNoKGZuLCB7XG4gICAgICAuLi5yZXFPcHRpb25zLFxuICAgICAgYnVja2V0OiB0aGlzLmJ1Y2tldC5uYW1lLFxuICAgICAgY29sbGVjdGlvbjogdGhpcy5uYW1lLFxuICAgIH0pO1xuICB9XG59XG4iLCIvKipcbiAqIEVuZHBvaW50cyB0ZW1wbGF0ZXMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5jb25zdCBFTkRQT0lOVFMgPSB7XG4gIHJvb3Q6ICAgICAgICAgICAgICAgICAgICgpID0+IFwiL1wiLFxuICBiYXRjaDogICAgICAgICAgICAgICAgICAoKSA9PiBcIi9iYXRjaFwiLFxuICBidWNrZXQ6ICAgICAgICAgICAoYnVja2V0KSA9PiBcIi9idWNrZXRzXCIgKyAoYnVja2V0ID8gYC8ke2J1Y2tldH1gIDogXCJcIiksXG4gIGNvbGxlY3Rpb246IChidWNrZXQsIGNvbGwpID0+IGAke0VORFBPSU5UUy5idWNrZXQoYnVja2V0KX0vY29sbGVjdGlvbnNgICsgKGNvbGwgPyBgLyR7Y29sbH1gIDogXCJcIiksXG4gIGdyb3VwOiAgICAgKGJ1Y2tldCwgZ3JvdXApID0+IGAke0VORFBPSU5UUy5idWNrZXQoYnVja2V0KX0vZ3JvdXBzYCArIChncm91cCA/IGAvJHtncm91cH1gIDogXCJcIiksXG4gIHJlY29yZDogKGJ1Y2tldCwgY29sbCwgaWQpID0+IGAke0VORFBPSU5UUy5jb2xsZWN0aW9uKGJ1Y2tldCwgY29sbCl9L3JlY29yZHNgICsgKGlkID8gYC8ke2lkfWAgOiBcIlwiKSxcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgc2VydmVyIGVucG9pbnQgYnkgaXRzIG5hbWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgbmFtZSBUaGUgZW5kcG9pbnQgbmFtZS5cbiAqIEBwYXJhbSAgey4uLnN0cmluZ30gYXJncyBUaGUgZW5kcG9pbnQgcGFyYW1ldGVycy5cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZW5kcG9pbnQobmFtZSwgLi4uYXJncykge1xuICByZXR1cm4gRU5EUE9JTlRTW25hbWVdKC4uLmFyZ3MpO1xufVxuIiwiLyoqXG4gKiBLaW50byBzZXJ2ZXIgZXJyb3IgY29kZSBkZXNjcmlwdG9ycy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgMTA0OiBcIk1pc3NpbmcgQXV0aG9yaXphdGlvbiBUb2tlblwiLFxuICAxMDU6IFwiSW52YWxpZCBBdXRob3JpemF0aW9uIFRva2VuXCIsXG4gIDEwNjogXCJSZXF1ZXN0IGJvZHkgd2FzIG5vdCB2YWxpZCBKU09OXCIsXG4gIDEwNzogXCJJbnZhbGlkIHJlcXVlc3QgcGFyYW1ldGVyXCIsXG4gIDEwODogXCJNaXNzaW5nIHJlcXVlc3QgcGFyYW1ldGVyXCIsXG4gIDEwOTogXCJJbnZhbGlkIHBvc3RlZCBkYXRhXCIsXG4gIDExMDogXCJJbnZhbGlkIFRva2VuIC8gaWRcIixcbiAgMTExOiBcIk1pc3NpbmcgVG9rZW4gLyBpZFwiLFxuICAxMTI6IFwiQ29udGVudC1MZW5ndGggaGVhZGVyIHdhcyBub3QgcHJvdmlkZWRcIixcbiAgMTEzOiBcIlJlcXVlc3QgYm9keSB0b28gbGFyZ2VcIixcbiAgMTE0OiBcIlJlc291cmNlIHdhcyBtb2RpZmllZCBtZWFud2hpbGVcIixcbiAgMTE1OiBcIk1ldGhvZCBub3QgYWxsb3dlZCBvbiB0aGlzIGVuZCBwb2ludCAoaGludDogc2VydmVyIG1heSBiZSByZWFkb25seSlcIixcbiAgMTE2OiBcIlJlcXVlc3RlZCB2ZXJzaW9uIG5vdCBhdmFpbGFibGUgb24gdGhpcyBzZXJ2ZXJcIixcbiAgMTE3OiBcIkNsaWVudCBoYXMgc2VudCB0b28gbWFueSByZXF1ZXN0c1wiLFxuICAxMjE6IFwiUmVzb3VyY2UgYWNjZXNzIGlzIGZvcmJpZGRlbiBmb3IgdGhpcyB1c2VyXCIsXG4gIDEyMjogXCJBbm90aGVyIHJlc291cmNlIHZpb2xhdGVzIGNvbnN0cmFpbnRcIixcbiAgMjAxOiBcIlNlcnZpY2UgVGVtcG9yYXJ5IHVuYXZhaWxhYmxlIGR1ZSB0byBoaWdoIGxvYWRcIixcbiAgMjAyOiBcIlNlcnZpY2UgZGVwcmVjYXRlZFwiLFxuICA5OTk6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBFUlJPUl9DT0RFUyBmcm9tIFwiLi9lcnJvcnNcIjtcblxuLyoqXG4gKiBFbmhhbmNlZCBIVFRQIGNsaWVudCBmb3IgdGhlIEtpbnRvIHByb3RvY29sLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSFRUUCB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IEhUVFAgcmVxdWVzdCBoZWFkZXJzIGFwcGxpZWQgdG8gZWFjaCBvdXRnb2luZyByZXF1ZXN0LlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBERUZBVUxUX1JFUVVFU1RfSEVBREVSUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJBY2NlcHRcIjogICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgb3B0aW9ucy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHt0aW1lb3V0OiA1MDAwLCByZXF1ZXN0TW9kZTogXCJjb3JzXCJ9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZXZlbnRzICAgICAgICAgICAgICAgICAgICAgICBUaGUgZXZlbnQgaGFuZGxlci5cbiAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgIFtvcHRpb25zPXt9fSAgICAgICAgICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gICAgICAgW29wdGlvbnMudGltZW91dD01MDAwXSAgICAgICBUaGUgcmVxdWVzdCB0aW1lb3V0IGluIG1zIChkZWZhdWx0OiBgNTAwMGApLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgW29wdGlvbnMucmVxdWVzdE1vZGU9XCJjb3JzXCJdIFRoZSBIVFRQIHJlcXVlc3QgbW9kZSAoZGVmYXVsdDogYFwiY29yc1wiYCkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihldmVudHMsIG9wdGlvbnM9e30pIHtcbiAgICAvLyBwdWJsaWMgcHJvcGVydGllc1xuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBlbWl0dGVyIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtFdmVudEVtaXR0ZXJ9XG4gICAgICovXG4gICAgaWYgKCFldmVudHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGV2ZW50cyBoYW5kbGVyIHByb3ZpZGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0IG1vZGUuXG4gICAgICogQHNlZSAgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3Rtb2RlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3RNb2RlID0gb3B0aW9ucy5yZXF1ZXN0TW9kZSB8fCBIVFRQLmRlZmF1bHRPcHRpb25zLnJlcXVlc3RNb2RlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlcXVlc3QgdGltZW91dC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCBIVFRQLmRlZmF1bHRPcHRpb25zLnRpbWVvdXQ7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYW4gSFRUUCByZXF1ZXN0IHRvIHRoZSBLaW50byBzZXJ2ZXIuXG4gICAqXG4gICAqIFJlc29sdmVzIHdpdGggYW4gb2JqZXQgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIEhUVFAgcmVzcG9uc2UgcHJvcGVydGllczpcbiAgICogLSBge051bWJlcn0gIHN0YXR1c2AgIFRoZSBIVFRQIHN0YXR1cyBjb2RlLlxuICAgKiAtIGB7T2JqZWN0fSAganNvbmAgICAgVGhlIEpTT04gcmVzcG9uc2UgYm9keS5cbiAgICogLSBge0hlYWRlcnN9IGhlYWRlcnNgIFRoZSByZXNwb25zZSBoZWFkZXJzIG9iamVjdDsgc2VlIHRoZSBFUzYgZmV0Y2goKSBzcGVjLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHVybCAgICAgICAgICAgICAgIFRoZSBVUkwuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnM9e31dICAgICAgVGhlIGZldGNoKCkgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gVGhlIHJlcXVlc3QgaGVhZGVycyBvYmplY3QgKGRlZmF1bHQ6IHt9KVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVxdWVzdCh1cmwsIG9wdGlvbnM9e2hlYWRlcnM6e319KSB7XG4gICAgbGV0IHJlc3BvbnNlLCBzdGF0dXMsIHN0YXR1c1RleHQsIGhlYWRlcnMsIGhhc1RpbWVkb3V0O1xuICAgIC8vIEVuc3VyZSBkZWZhdWx0IHJlcXVlc3QgaGVhZGVycyBhcmUgYWx3YXlzIHNldFxuICAgIG9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIEhUVFAuREVGQVVMVF9SRVFVRVNUX0hFQURFUlMsIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgb3B0aW9ucy5tb2RlID0gdGhpcy5yZXF1ZXN0TW9kZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgX3RpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBoYXNUaW1lZG91dCA9IHRydWU7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJSZXF1ZXN0IHRpbWVvdXQuXCIpKTtcbiAgICAgIH0sIHRoaXMudGltZW91dCk7XG4gICAgICBmZXRjaCh1cmwsIG9wdGlvbnMpIC50aGVuKHJlcyA9PiB7XG4gICAgICAgIGlmICghaGFzVGltZWRvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RpbWVvdXRJZCk7XG4gICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpZiAoIWhhc1RpbWVkb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF90aW1lb3V0SWQpO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KVxuICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgcmVzcG9uc2UgPSByZXM7XG4gICAgICAgIGhlYWRlcnMgPSByZXMuaGVhZGVycztcbiAgICAgICAgc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgICAgc3RhdHVzVGV4dCA9IHJlcy5zdGF0dXNUZXh0O1xuICAgICAgICB0aGlzLl9jaGVja0ZvckRlcHJlY2F0aW9uSGVhZGVyKGhlYWRlcnMpO1xuICAgICAgICB0aGlzLl9jaGVja0ZvckJhY2tvZmZIZWFkZXIoc3RhdHVzLCBoZWFkZXJzKTtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JSZXRyeUFmdGVySGVhZGVyKHN0YXR1cywgaGVhZGVycyk7XG4gICAgICAgIHJldHVybiByZXMudGV4dCgpO1xuICAgICAgfSlcbiAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSBib2R5OyBpZiBzbyBwYXJzZSBpdCBhcyBKU09OLlxuICAgICAgLnRoZW4odGV4dCA9PiB7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IHdlIGNhbid0IGNvbnN1bWUgdGhlIHJlc3BvbnNlIGJvZHkgdHdpY2UuXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgSFRUUCAke3N0YXR1cyB8fCAwfTsgJHtlcnJ9YCk7XG4gICAgICAgIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIGVycm9yLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pXG4gICAgICAudGhlbihqc29uID0+IHtcbiAgICAgICAgaWYgKGpzb24gJiYgc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgIGxldCBtZXNzYWdlID0gYEhUVFAgJHtzdGF0dXN9ICR7anNvbi5lcnJvcnx8XCJcIn06IGA7XG4gICAgICAgICAgaWYgKGpzb24uZXJybm8gJiYganNvbi5lcnJubyBpbiBFUlJPUl9DT0RFUykge1xuICAgICAgICAgICAgY29uc3QgZXJybm9Nc2cgPSBFUlJPUl9DT0RFU1tqc29uLmVycm5vXTtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gZXJybm9Nc2c7XG4gICAgICAgICAgICBpZiAoanNvbi5tZXNzYWdlICYmIGpzb24ubWVzc2FnZSAhPT0gZXJybm9Nc2cpIHtcbiAgICAgICAgICAgICAgbWVzc2FnZSArPSBgICgke2pzb24ubWVzc2FnZX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBzdGF0dXNUZXh0IHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UudHJpbSgpKTtcbiAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgIGVycm9yLmRhdGEgPSBqc29uO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7c3RhdHVzLCBqc29uLCBoZWFkZXJzfTtcbiAgICAgIH0pO1xuICB9XG5cbiAgX2NoZWNrRm9yRGVwcmVjYXRpb25IZWFkZXIoaGVhZGVycykge1xuICAgIGNvbnN0IGFsZXJ0SGVhZGVyID0gaGVhZGVycy5nZXQoXCJBbGVydFwiKTtcbiAgICBpZiAoIWFsZXJ0SGVhZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBhbGVydDtcbiAgICB0cnkge1xuICAgICAgYWxlcnQgPSBKU09OLnBhcnNlKGFsZXJ0SGVhZGVyKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgY29uc29sZS53YXJuKFwiVW5hYmxlIHRvIHBhcnNlIEFsZXJ0IGhlYWRlciBtZXNzYWdlXCIsIGFsZXJ0SGVhZGVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKGFsZXJ0Lm1lc3NhZ2UsIGFsZXJ0LnVybCk7XG4gICAgdGhpcy5ldmVudHMuZW1pdChcImRlcHJlY2F0ZWRcIiwgYWxlcnQpO1xuICB9XG5cbiAgX2NoZWNrRm9yQmFja29mZkhlYWRlcihzdGF0dXMsIGhlYWRlcnMpIHtcbiAgICBsZXQgYmFja29mZk1zO1xuICAgIGNvbnN0IGJhY2tvZmZTZWNvbmRzID0gcGFyc2VJbnQoaGVhZGVycy5nZXQoXCJCYWNrb2ZmXCIpLCAxMCk7XG4gICAgaWYgKGJhY2tvZmZTZWNvbmRzID4gMCkge1xuICAgICAgYmFja29mZk1zID0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSArIChiYWNrb2ZmU2Vjb25kcyAqIDEwMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYWNrb2ZmTXMgPSAwO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50cy5lbWl0KFwiYmFja29mZlwiLCBiYWNrb2ZmTXMpO1xuICB9XG5cbiAgX2NoZWNrRm9yUmV0cnlBZnRlckhlYWRlcihzdGF0dXMsIGhlYWRlcnMpIHtcbiAgICBsZXQgcmV0cnlBZnRlciA9IGhlYWRlcnMuZ2V0KFwiUmV0cnktQWZ0ZXJcIik7XG4gICAgaWYgKCFyZXRyeUFmdGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHJ5QWZ0ZXIgPSAobmV3IERhdGUoKS5nZXRUaW1lKCkpICsgKHBhcnNlSW50KHJldHJ5QWZ0ZXIsIDEwKSAqIDEwMDApO1xuICAgIHRoaXMuZXZlbnRzLmVtaXQoXCJyZXRyeS1hZnRlclwiLCByZXRyeUFmdGVyKTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBcImlzb21vcnBoaWMtZmV0Y2hcIjtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJldmVudHNcIjtcblxuaW1wb3J0IEtpbnRvQ2xpZW50QmFzZSBmcm9tIFwiLi9iYXNlXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2ludG9DbGllbnQgZXh0ZW5kcyBLaW50b0NsaWVudEJhc2Uge1xuICBjb25zdHJ1Y3RvcihyZW1vdGUsIG9wdGlvbnM9e30pIHtcbiAgICBjb25zdCBldmVudHMgPSBvcHRpb25zLmV2ZW50cyB8fCBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBzdXBlcihyZW1vdGUsIE9iamVjdC5hc3NpZ24oe2V2ZW50c30sIG9wdGlvbnMpKTtcbiAgfVxufVxuXG4vLyBUaGlzIGlzIGEgaGFjayB0byBhdm9pZCBCcm93c2VyaWZ5IHRvIGV4cG9zZSB0aGUgYWJvdmUgY2xhc3Ncbi8vIGF0IGBuZXcgS2ludG9DbGllbnQoKWAgaW5zdGVhZCBvZiBgbmV3IEtpbnRvQ2xpZW50LmRlZmF1bHQoKWAuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0tpbnRvL2tpbnRvLWh0dHAuanMvaXNzdWVzLzc3XG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IEtpbnRvQ2xpZW50O1xufVxuIiwiaW1wb3J0IHsgb21pdCB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmNvbnN0IHJlcXVlc3REZWZhdWx0cyA9IHtcbiAgc2FmZTogZmFsc2UsXG4gIC8vIGNoZWNrIGlmIHdlIHNob3VsZCBzZXQgZGVmYXVsdCBjb250ZW50IHR5cGUgaGVyZVxuICBoZWFkZXJzOiB7fSxcbiAgcGVybWlzc2lvbnM6IHVuZGVmaW5lZCxcbiAgZGF0YTogdW5kZWZpbmVkLFxuICBwYXRjaDogZmFsc2UsXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhZmVIZWFkZXIoc2FmZSwgbGFzdF9tb2RpZmllZCkge1xuICBpZiAoIXNhZmUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgaWYgKGxhc3RfbW9kaWZpZWQpIHtcbiAgICByZXR1cm4ge1wiSWYtTWF0Y2hcIjogYFwiJHtsYXN0X21vZGlmaWVkfVwiYH07XG4gIH1cbiAgcmV0dXJuIHtcIklmLU5vbmUtTWF0Y2hcIjogXCIqXCJ9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KHBhdGgsIHtkYXRhLCBwZXJtaXNzaW9uc30sIG9wdGlvbnM9e30pIHtcbiAgY29uc3QgeyBoZWFkZXJzLCBzYWZlIH0gPSB7XG4gICAgLi4ucmVxdWVzdERlZmF1bHRzLFxuICAgIC4uLm9wdGlvbnMsXG4gIH07XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBkYXRhICYmIGRhdGEuaWQgPyBcIlBVVFwiIDogXCJQT1NUXCIsXG4gICAgcGF0aCxcbiAgICBoZWFkZXJzOiB7Li4uaGVhZGVycywgLi4uc2FmZUhlYWRlcihzYWZlKX0sXG4gICAgYm9keToge1xuICAgICAgZGF0YSxcbiAgICAgIHBlcm1pc3Npb25zXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVSZXF1ZXN0KHBhdGgsIHtkYXRhLCBwZXJtaXNzaW9uc30sIG9wdGlvbnM9e30pIHtcbiAgY29uc3Qge1xuICAgIGhlYWRlcnMsXG4gICAgc2FmZSxcbiAgICBwYXRjaCxcbiAgfSA9IHsuLi5yZXF1ZXN0RGVmYXVsdHMsIC4uLm9wdGlvbnN9O1xuICBjb25zdCB7IGxhc3RfbW9kaWZpZWQgfSA9IHsgLi4uZGF0YSwgLi4ub3B0aW9ucyB9O1xuXG4gIGlmIChPYmplY3Qua2V5cyhvbWl0KGRhdGEsIFwiaWRcIiwgXCJsYXN0X21vZGlmaWVkXCIpKS5sZW5ndGggPT09IDApIHtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IHBhdGNoID8gXCJQQVRDSFwiIDogXCJQVVRcIixcbiAgICBwYXRoLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAuLi5zYWZlSGVhZGVyKHNhZmUsIGxhc3RfbW9kaWZpZWQpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICBkYXRhLFxuICAgICAgcGVybWlzc2lvbnNcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZVJlcXVlc3QocGF0aCwgb3B0aW9ucz17fSkge1xuICBjb25zdCB7IGhlYWRlcnMsIHNhZmUsIGxhc3RfbW9kaWZpZWR9ID0ge1xuICAgIC4uLnJlcXVlc3REZWZhdWx0cyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGlmIChzYWZlICYmICFsYXN0X21vZGlmaWVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2FmZSBjb25jdXJyZW5jeSBjaGVjayByZXF1aXJlcyBhIGxhc3RfbW9kaWZpZWQgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgIHBhdGgsXG4gICAgaGVhZGVyczogey4uLmhlYWRlcnMsIC4uLnNhZmVIZWFkZXIoc2FmZSwgbGFzdF9tb2RpZmllZCl9XG4gIH07XG59XG4iLCIvKipcbiAqIENodW5rcyBhbiBhcnJheSBpbnRvIG4gcGllY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtBcnJheX0gIGFycmF5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFydGl0aW9uKGFycmF5LCBuKSB7XG4gIGlmIChuIDw9IDApIHtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgcmV0dXJuIGFycmF5LnJlZHVjZSgoYWNjLCB4LCBpKSA9PiB7XG4gICAgaWYgKGkgPT09IDAgfHwgaSAlIG4gPT09IDApIHtcbiAgICAgIGFjYy5wdXNoKFt4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY1thY2MubGVuZ3RoIC0gMV0ucHVzaCh4KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xufVxuXG4vKipcbiAqIE1hcHMgYSBsaXN0IHRvIHByb21pc2VzIHVzaW5nIHRoZSBwcm92aWRlZCBtYXBwaW5nIGZ1bmN0aW9uLCBleGVjdXRlcyB0aGVtXG4gKiBzZXF1ZW50aWFsbHkgdGhlbiByZXR1cm5zIGEgUHJvbWlzZSByZXNvbHZpbmcgd2l0aCBvcmRlcmVkIHJlc3VsdHMgb2J0YWluZWQuXG4gKiBUaGluayBvZiB0aGlzIGFzIGEgc2VxdWVudGlhbCBQcm9taXNlLmFsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7QXJyYXl9ICAgIGxpc3QgVGhlIGxpc3QgdG8gbWFwLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgVGhlIG1hcHBpbmcgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcE1hcChsaXN0LCBmbikge1xuICBsZXQgcmVzdWx0cyA9IFtdO1xuICByZXR1cm4gbGlzdC5yZWR1Y2UoKHByb21pc2UsIGVudHJ5KSA9PiB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZuKGVudHJ5KSlcbiAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChyZXN1bHQpKTtcbiAgICB9KTtcbiAgfSwgUHJvbWlzZS5yZXNvbHZlKCkpLnRoZW4oKCkgPT4gcmVzdWx0cyk7XG59XG5cbi8qKlxuICogVGFrZXMgYW4gb2JqZWN0IGFuZCByZXR1cm5zIGEgY29weSBvZiBpdCB3aXRoIHRoZSBwcm92aWRlZCBrZXlzIG9taXR0ZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge09iamVjdH0gICAgb2JqICBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSAgey4uLlN0cmluZ30ga2V5cyBUaGUga2V5cyB0byBvbWl0LlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gb21pdChvYmosIC4uLmtleXMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIGFjY1trZXldID0gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJucyBhIHJlc291cmNlIGRhdGEgb2JqZWN0IGZyb20gdGhlIHByb3ZpZGVkIGFyZ3VtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtPYmplY3R8U3RyaW5nfSByZXNvdXJjZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EYXRhQm9keShyZXNvdXJjZSkge1xuICBpZiAoaXNPYmplY3QocmVzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHJlc291cmNlO1xuICB9XG4gIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ge2lkOiByZXNvdXJjZX07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudC5cIik7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBvYmplY3QgaW50byBhbiBVUkwgcXVlcnkgc3RyaW5nLCBzdHJpcHBpbmcgb3V0IGFueSB1bmRlZmluZWRcbiAqIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXNpZnkob2JqKSB7XG4gIGNvbnN0IHNlcCA9IFwiJlwiO1xuICBjb25zdCBlbmNvZGUgPSAodikgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIiA/IFN0cmluZyh2KSA6IHYpO1xuICBjb25zdCBzdHJpcFVuZGVmaW5lZCA9IChvKSA9PiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG8pKTtcbiAgY29uc3Qgc3RyaXBwZWQgPSBzdHJpcFVuZGVmaW5lZChvYmopO1xuICByZXR1cm4gT2JqZWN0LmtleXMoc3RyaXBwZWQpLm1hcCgoaykgPT4ge1xuICAgIGNvbnN0IGtzID0gZW5jb2RlKGspICsgXCI9XCI7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3RyaXBwZWRba10pKSB7XG4gICAgICByZXR1cm4gc3RyaXBwZWRba10ubWFwKCh2KSA9PiBrcyArIGVuY29kZSh2KSkuam9pbihzZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ga3MgKyBlbmNvZGUoc3RyaXBwZWRba10pO1xuICAgIH1cbiAgfSkuam9pbihzZXApO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHZlcnNpb24gaXMgd2l0aGluIHRoZSBwcm92aWRlZCByYW5nZS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHZlcnNpb24gICAgVGhlIHZlcnNpb24gdG8gY2hlY2suXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG1pblZlcnNpb24gVGhlIG1pbmltdW0gc3VwcG9ydGVkIHZlcnNpb24gKGluY2x1c2l2ZSkuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG1heFZlcnNpb24gVGhlIG1pbmltdW0gc3VwcG9ydGVkIHZlcnNpb24gKGV4Y2x1c2l2ZSkuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZlcnNpb24gaXMgb3V0c2lkZSBvZiB0aGUgcHJvdmlkZWQgcmFuZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1ZlcnNpb24odmVyc2lvbiwgbWluVmVyc2lvbiwgbWF4VmVyc2lvbikge1xuICBjb25zdCBleHRyYWN0ID0gKHN0cikgPT4gc3RyLnNwbGl0KFwiLlwiKS5tYXAoeCA9PiBwYXJzZUludCh4LCAxMCkpO1xuICBjb25zdCBbdmVyTWFqb3IsIHZlck1pbm9yXSA9IGV4dHJhY3QodmVyc2lvbik7XG4gIGNvbnN0IFttaW5NYWpvciwgbWluTWlub3JdID0gZXh0cmFjdChtaW5WZXJzaW9uKTtcbiAgY29uc3QgW21heE1ham9yLCBtYXhNaW5vcl0gPSBleHRyYWN0KG1heFZlcnNpb24pO1xuICBjb25zdCBjaGVja3MgPSBbXG4gICAgdmVyTWFqb3IgPCBtaW5NYWpvcixcbiAgICB2ZXJNYWpvciA9PT0gbWluTWFqb3IgJiYgdmVyTWlub3IgPCBtaW5NaW5vcixcbiAgICB2ZXJNYWpvciA+IG1heE1ham9yLFxuICAgIHZlck1ham9yID09PSBtYXhNYWpvciAmJiB2ZXJNaW5vciA+PSBtYXhNaW5vcixcbiAgXTtcbiAgaWYgKGNoZWNrcy5zb21lKHggPT4geCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFZlcnNpb24gJHt2ZXJzaW9ufSBkb2Vzbid0IHNhdGlzZnkgYCArXG4gICAgICAgICAgICAgICAgICAgIGAke21pblZlcnNpb259IDw9IHggPCAke21heFZlcnNpb259YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBkZWNvcmF0b3IgZnVuY3Rpb24gZW5zdXJpbmcgYSB2ZXJzaW9uIGNoZWNrIGlzIHBlcmZvcm1lZCBhZ2FpbnN0XG4gKiB0aGUgcHJvdmlkZWQgcmVxdWlyZW1lbnRzIGJlZm9yZSBleGVjdXRpbmcgaXQuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBtaW4gVGhlIHJlcXVpcmVkIG1pbiB2ZXJzaW9uIChpbmNsdXNpdmUpLlxuICogQHBhcmFtICB7U3RyaW5nfSBtYXggVGhlIHJlcXVpcmVkIG1heCB2ZXJzaW9uIChpbmNsdXNpdmUpLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0KG1pbiwgbWF4KSB7XG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGNvbnN0IGZuID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB3cmFwcGVkTWV0aG9kID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAvLyBcInRoaXNcIiBpcyB0aGUgY3VycmVudCBpbnN0YW5jZSB3aGljaCBpdHMgbWV0aG9kIGlzIGRlY29yYXRlZC5cbiAgICAgICAgICBjb25zdCBjbGllbnQgPSBcImNsaWVudFwiIGluIHRoaXMgPyB0aGlzLmNsaWVudCA6IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGNsaWVudC5mZXRjaEhUVFBBcGlWZXJzaW9uKClcbiAgICAgICAgICAgIC50aGVuKHZlcnNpb24gPT4gY2hlY2tWZXJzaW9uKHZlcnNpb24sIG1pbiwgbWF4KSlcbiAgICAgICAgICAgIC50aGVuKFByb21pc2UucmVzb2x2ZShmbi5hcHBseSh0aGlzLCBhcmdzKSkpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgdmFsdWU6IHdyYXBwZWRNZXRob2QsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd3JhcHBlZE1ldGhvZDtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGRlY29yYXRvciBmdW5jdGlvbiBlbnN1cmluZyB0aGF0IHRoZSBzcGVjaWZpZWQgY2FwYWJpbGl0aWVzIGFyZVxuICogYXZhaWxhYmxlIG9uIHRoZSBzZXJ2ZXIgYmVmb3JlIGV4ZWN1dGluZyBpdC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheTxTdHJpbmc+fSBjYXBhYmlsaXRpZXMgVGhlIHJlcXVpcmVkIGNhcGFiaWxpdGllcy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FwYWJsZShjYXBhYmlsaXRpZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgY29uc3QgZm4gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRNZXRob2QgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIC8vIFwidGhpc1wiIGlzIHRoZSBjdXJyZW50IGluc3RhbmNlIHdoaWNoIGl0cyBtZXRob2QgaXMgZGVjb3JhdGVkLlxuICAgICAgICAgIGNvbnN0IGNsaWVudCA9IFwiY2xpZW50XCIgaW4gdGhpcyA/IHRoaXMuY2xpZW50IDogdGhpcztcbiAgICAgICAgICByZXR1cm4gY2xpZW50LmZldGNoU2VydmVyQ2FwYWJpbGl0aWVzKClcbiAgICAgICAgICAgIC50aGVuKGF2YWlsYWJsZSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1pc3NpbmcgPSBjYXBhYmlsaXRpZXMuZmlsdGVyKGMgPT4gYXZhaWxhYmxlLmluZGV4T2YoYykgPCAwKTtcbiAgICAgICAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWlyZWQgY2FwYWJpbGl0aWVzICR7bWlzc2luZy5qb2luKFwiLCBcIil9IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5vdCBwcmVzZW50IG9uIHNlcnZlclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKFByb21pc2UucmVzb2x2ZShmbi5hcHBseSh0aGlzLCBhcmdzKSkpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgdmFsdWU6IHdyYXBwZWRNZXRob2QsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd3JhcHBlZE1ldGhvZDtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGRlY29yYXRvciBmdW5jdGlvbiBlbnN1cmluZyBhbiBvcGVyYXRpb24gaXMgbm90IHBlcmZvcm1lZCBmcm9tXG4gKiB3aXRoaW4gYSBiYXRjaCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZSB0byB0aHJvdy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9iYXRjaChtZXNzYWdlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGNvbnN0IGZuID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB3cmFwcGVkTWV0aG9kID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAvLyBcInRoaXNcIiBpcyB0aGUgY3VycmVudCBpbnN0YW5jZSB3aGljaCBpdHMgbWV0aG9kIGlzIGRlY29yYXRlZC5cbiAgICAgICAgICBpZiAodGhpcy5faXNCYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICB2YWx1ZTogd3JhcHBlZE1ldGhvZCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3cmFwcGVkTWV0aG9kO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gb2JqZWN0IChpLmUuIG5vdCBhbiBhcnJheSBub3IgbnVsbCkuXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRoaW5nIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHRoaW5nKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IFwib2JqZWN0XCIgJiYgdGhpbmcgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodGhpbmcpO1xufVxuIl19
