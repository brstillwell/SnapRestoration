(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.KintoClient = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.
require('whatwg-fetch');
module.exports = self.fetch.bind(self);

},{"whatwg-fetch":3}],3:[function(require,module,exports){
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    reader.readAsText(blob)
    return fileReaderReady(reader)
  }

  var support = {
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  function Body() {
    this.bodyUsed = false


    this._initBody = function(body) {
      this._bodyInit = body
      if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (!body) {
        this._bodyText = ''
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }

      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      }
    } else {
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = input
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = xhr.getAllResponseHeaders().trim().split('\n')
    pairs.forEach(function(header) {
      var split = header.trim().split(':')
      var key = split.shift().trim()
      var value = split.join(':').trim()
      head.append(key, value)
    })
    return head
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = options.status
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = options.statusText
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input
      } else {
        request = new Request(input, init)
      }

      var xhr = new XMLHttpRequest()

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL')
        }

        return;
      }

      xhr.onload = function() {
        var status = (xhr.status === 1223) ? 204 : xhr.status
        if (status < 100 || status > 599) {
          reject(new TypeError('Network request failed'))
          return
        }
        var options = {
          status: status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SUPPORTED_PROTOCOL_VERSION = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _desc, _value, _class;

var _utils = require("./utils");

var _http = require("./http");

var _http2 = _interopRequireDefault(_http);

var _endpoint = require("./endpoint");

var _endpoint2 = _interopRequireDefault(_endpoint);

var _requests = require("./requests");

var requests = _interopRequireWildcard(_requests);

var _batch = require("./batch");

var _bucket = require("./bucket");

var _bucket2 = _interopRequireDefault(_bucket);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * Currently supported protocol version.
 * @type {String}
 */
var SUPPORTED_PROTOCOL_VERSION = exports.SUPPORTED_PROTOCOL_VERSION = "v1";

/**
 * High level HTTP client for the Kinto API.
 *
 * @example
 * const client = new KintoClient("https://kinto.dev.mozaws.net/v1");
 * client.bucket("default")
*    .collection("my-blog")
*    .createRecord({title: "First article"})
 *   .then(console.log.bind(console))
 *   .catch(console.error.bind(console));
 */
var KintoClientBase = (_dec = (0, _utils.nobatch)("This operation is not supported within a batch operation."), _dec2 = (0, _utils.nobatch)("This operation is not supported within a batch operation."), _dec3 = (0, _utils.nobatch)("This operation is not supported within a batch operation."), _dec4 = (0, _utils.nobatch)("This operation is not supported within a batch operation."), _dec5 = (0, _utils.nobatch)("Can't use batch within a batch!"), _dec6 = (0, _utils.support)("1.4", "2.0"), (_class = function () {
  /**
   * Constructor.
   *
   * @param  {String} remote  The remote URL.
   * @param  {Object}  options The options object.
   * @param  {Boolean} options.safe        Adds concurrency headers to every
   * requests (default: `true`).
   * @param  {EventEmitter} options.events The events handler. If none provided
   * an `EventEmitter` instance will be created.
   * @param  {Object}  options.headers     The key-value headers to pass to each
   * request (default: `{}`).
   * @param  {String}  options.bucket      The default bucket to use (default:
   * `"default"`)
   * @param  {String}  options.requestMode The HTTP request mode (from ES6 fetch
   * spec).
   * @param  {Number}  options.timeout     The requests timeout in ms (default: `5000`).
   */

  function KintoClientBase(remote) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, KintoClientBase);

    if (typeof remote !== "string" || !remote.length) {
      throw new Error("Invalid remote URL: " + remote);
    }
    if (remote[remote.length - 1] === "/") {
      remote = remote.slice(0, -1);
    }
    this._backoffReleaseTime = null;

    /**
     * Default request options container.
     * @private
     * @type {Object}
     */
    this.defaultReqOptions = {
      bucket: options.bucket || "default",
      headers: options.headers || {},
      safe: !!options.safe
    };

    this._options = options;
    this._requests = [];
    this._isBatch = !!options.batch;

    // public properties
    /**
     * The remote server base URL.
     * @type {String}
     */
    this.remote = remote;
    /**
     * Current server information.
     * @ignore
     * @type {Object|null}
     */
    this.serverInfo = null;
    /**
     * The event emitter instance. Should comply with the `EventEmitter`
     * interface.
     * @ignore
     * @type {Class}
     */
    this.events = options.events;

    var requestMode = options.requestMode;
    var timeout = options.timeout;
    /**
     * The HTTP instance.
     * @ignore
     * @type {HTTP}
     */

    this.http = new _http2.default(this.events, { requestMode: requestMode, timeout: timeout });
    this._registerHTTPEvents();
  }

  /**
   * The remote endpoint base URL. Setting the value will also extract and
   * validate the version.
   * @type {String}
   */


  _createClass(KintoClientBase, [{
    key: "_registerHTTPEvents",


    /**
     * Registers HTTP events.
     * @private
     */
    value: function _registerHTTPEvents() {
      var _this = this;

      // Prevent registering event from a batch client instance
      if (!this._isBatch) {
        this.events.on("backoff", function (backoffMs) {
          _this._backoffReleaseTime = backoffMs;
        });
      }
    }

    /**
     * Retrieve a bucket object to perform operations on it.
     *
     * @param  {String}  name    The bucket name.
     * @param  {Object}  options The request options.
     * @param  {Boolean} safe    The resulting safe option.
     * @param  {String}  bucket  The resulting bucket name option.
     * @param  {Object}  headers The extended headers object option.
     * @return {Bucket}
     */

  }, {
    key: "bucket",
    value: function bucket(name) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var bucketOptions = (0, _utils.omit)(this._getRequestOptions(options), "bucket");
      return new _bucket2.default(this, name, bucketOptions);
    }

    /**
     * Generates a request options object, deeply merging the client configured
     * defaults with the ones provided as argument.
     *
     * Note: Headers won't be overriden but merged with instance default ones.
     *
     * @private
     * @param    {Object} options The request options.
     * @return   {Object}
     * @property {Boolean} safe    The resulting safe option.
     * @property {String}  bucket  The resulting bucket name option.
     * @property {Object}  headers The extended headers object option.
     */

  }, {
    key: "_getRequestOptions",
    value: function _getRequestOptions() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return _extends({}, this.defaultReqOptions, options, {
        batch: this._isBatch,
        // Note: headers should never be overriden but extended
        headers: _extends({}, this.defaultReqOptions.headers, options.headers)
      });
    }

    /**
     * Retrieves server information and persist them locally. This operation is
     * usually performed a single time during the instance lifecycle.
     *
     * @param  {Object}  options The request options.
     *
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchServerInfo",
    value: function fetchServerInfo() {
      var _this2 = this;

      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      if (this.serverInfo) {
        return Promise.resolve(this.serverInfo);
      }
      return this.http.request(this.remote + (0, _endpoint2.default)("root"), {
        headers: _extends({}, this.defaultReqOptions.headers, options.headers)
      }).then(function (_ref) {
        var json = _ref.json;

        _this2.serverInfo = json;
        return _this2.serverInfo;
      });
    }

    /**
     * Retrieves Kinto server settings.
     *
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchServerSettings",
    value: function fetchServerSettings() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.fetchServerInfo(options).then(function (_ref2) {
        var settings = _ref2.settings;
        return settings;
      });
    }

    /**
     * Retrieve server capabilities information.
     *
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchServerCapabilities",
    value: function fetchServerCapabilities() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.fetchServerInfo(options).then(function (_ref3) {
        var capabilities = _ref3.capabilities;
        return capabilities;
      });
    }

    /**
     * Retrieve authenticated user information.
     *
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchUser",
    value: function fetchUser() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.fetchServerInfo(options).then(function (_ref4) {
        var user = _ref4.user;
        return user;
      });
    }

    /**
     * Retrieve authenticated user information.
     *
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "fetchHTTPApiVersion",
    value: function fetchHTTPApiVersion() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.fetchServerInfo(options).then(function (_ref5) {
        var http_api_version = _ref5.http_api_version;

        return http_api_version;
      });
    }

    /**
     * Process batch requests, chunking them according to the batch_max_requests
     * server setting when needed.
     *
     * @param  {Array}  requests The list of batch subrequests to perform.
     * @param  {Object} options  The options object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "_batchRequests",
    value: function _batchRequests(requests) {
      var _this3 = this;

      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var headers = _extends({}, this.defaultReqOptions.headers, options.headers);
      if (!requests.length) {
        return Promise.resolve([]);
      }
      return this.fetchServerSettings().then(function (serverSettings) {
        var maxRequests = serverSettings["batch_max_requests"];
        if (maxRequests && requests.length > maxRequests) {
          var chunks = (0, _utils.partition)(requests, maxRequests);
          return (0, _utils.pMap)(chunks, function (chunk) {
            return _this3._batchRequests(chunk, options);
          });
        }
        return _this3.execute({
          path: (0, _endpoint2.default)("batch"),
          method: "POST",
          headers: headers,
          body: {
            defaults: { headers: headers },
            requests: requests
          }
        })
        // we only care about the responses
        .then(function (_ref6) {
          var responses = _ref6.responses;
          return responses;
        });
      });
    }

    /**
     * Sends batch requests to the remote server.
     *
     * Note: Reserved for internal use only.
     *
     * @ignore
     * @param  {Function} fn      The function to use for describing batch ops.
     * @param  {Object}   options The options object.
     * @param  {Boolean}  options.safe      The safe option.
     * @param  {String}   options.bucket    The bucket name option.
     * @param  {Object}   options.headers   The headers object option.
     * @param  {Boolean}  options.aggregate Produces an aggregated result object
     * (default: `false`).
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "batch",
    value: function batch(fn) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var rootBatch = new KintoClientBase(this.remote, _extends({}, this._options, this._getRequestOptions(options), {
        batch: true
      }));
      var bucketBatch = void 0,
          collBatch = void 0;
      if (options.bucket) {
        bucketBatch = rootBatch.bucket(options.bucket);
        if (options.collection) {
          collBatch = bucketBatch.collection(options.collection);
        }
      }
      var batchClient = collBatch || bucketBatch || rootBatch;
      try {
        fn(batchClient);
      } catch (err) {
        return Promise.reject(err);
      }
      return this._batchRequests(rootBatch._requests, options).then(function (responses) {
        if (options.aggregate) {
          return (0, _batch.aggregate)(responses, rootBatch._requests);
        }
        return responses;
      });
    }

    /**
     * Executes an atomic HTTP request.
     *
     * @private
     * @param  {Object}  request     The request object.
     * @param  {Object}  options     The options object.
     * @param  {Boolean} options.raw Resolve with full response object, including
     * json body and headers (Default: `false`, so only the json body is
     * retrieved).
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "execute",
    value: function execute(request) {
      var _this4 = this;

      var options = arguments.length <= 1 || arguments[1] === undefined ? { raw: false } : arguments[1];

      // If we're within a batch, add the request to the stack to send at once.
      if (this._isBatch) {
        this._requests.push(request);
        // Resolve with a message in case people attempt at consuming the result
        // from within a batch operation.
        var msg = "This result is generated from within a batch " + "operation and should not be consumed.";
        return Promise.resolve(options.raw ? { json: msg } : msg);
      }
      var promise = this.fetchServerSettings().then(function (_) {
        return _this4.http.request(_this4.remote + request.path, _extends({}, request, {
          body: JSON.stringify(request.body)
        }));
      });
      return options.raw ? promise : promise.then(function (_ref7) {
        var json = _ref7.json;
        return json;
      });
    }

    /**
     * Retrieves the list of buckets.
     *
     * @param  {Object} options         The options object.
     * @param  {Object} options.headers The headers object option.
     * @return {Promise<Object[], Error>}
     */

  }, {
    key: "listBuckets",
    value: function listBuckets() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.execute({
        path: (0, _endpoint2.default)("bucket"),
        headers: _extends({}, this.defaultReqOptions.headers, options.headers)
      });
    }

    /**
     * Creates a new bucket on the server.
     *
     * @param  {String}   id              The bucket name.
     * @param  {Object}   options         The options object.
     * @param  {Boolean}  options.data    The bucket data option.
     * @param  {Boolean}  options.safe    The safe option.
     * @param  {Object}   options.headers The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "createBucket",
    value: function createBucket(id) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!id) {
        throw new Error("A bucket id is required.");
      }
      // Note that we simply ignore any "bucket" option passed here, as the one
      // we're interested in is the one provided as a required argument.
      var reqOptions = this._getRequestOptions(options);
      var _reqOptions$data = reqOptions.data;
      var data = _reqOptions$data === undefined ? {} : _reqOptions$data;
      var permissions = reqOptions.permissions;

      data.id = id;
      var path = (0, _endpoint2.default)("bucket", id);
      return this.execute(requests.createRequest(path, { data: data, permissions: permissions }, reqOptions));
    }

    /**
     * Deletes a bucket from the server.
     *
     * @ignore
     * @param  {Object|String} bucket          The bucket to delete.
     * @param  {Object}        options         The options object.
     * @param  {Boolean}       options.safe    The safe option.
     * @param  {Object}        options.headers The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteBucket",
    value: function deleteBucket(bucket) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var bucketObj = (0, _utils.toDataBody)(bucket);
      if (!bucketObj.id) {
        throw new Error("A bucket id is required.");
      }
      var path = (0, _endpoint2.default)("bucket", bucketObj.id);
      var _bucketObj = { bucketObj: bucketObj };
      var last_modified = _bucketObj.last_modified;

      var reqOptions = this._getRequestOptions(_extends({ last_modified: last_modified }, options));
      return this.execute(requests.deleteRequest(path, reqOptions));
    }

    /**
     * Deletes all buckets on the server.
     *
     * @ignore
     * @param  {Object}  options         The options object.
     * @param  {Boolean} options.safe    The safe option.
     * @param  {Object}  options.headers The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteBuckets",
    value: function deleteBuckets() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var reqOptions = this._getRequestOptions(options);
      var path = (0, _endpoint2.default)("bucket");
      return this.execute(requests.deleteRequest(path, reqOptions));
    }
  }, {
    key: "remote",
    get: function get() {
      return this._remote;
    }

    /**
     * @ignore
     */
    ,
    set: function set(url) {
      var version = void 0;
      try {
        version = url.match(/\/(v\d+)\/?$/)[1];
      } catch (err) {
        throw new Error("The remote URL must contain the version: " + url);
      }
      if (version !== SUPPORTED_PROTOCOL_VERSION) {
        throw new Error("Unsupported protocol version: " + version);
      }
      this._remote = url;
      this._version = version;
    }

    /**
     * The current server protocol version, eg. `v1`.
     * @type {String}
     */

  }, {
    key: "version",
    get: function get() {
      return this._version;
    }

    /**
     * Backoff remaining time, in milliseconds. Defaults to zero if no backoff is
     * ongoing.
     *
     * @type {Number}
     */

  }, {
    key: "backoff",
    get: function get() {
      var currentTime = new Date().getTime();
      if (this._backoffReleaseTime && currentTime < this._backoffReleaseTime) {
        return this._backoffReleaseTime - currentTime;
      }
      return 0;
    }
  }]);

  return KintoClientBase;
}(), (_applyDecoratedDescriptor(_class.prototype, "fetchServerSettings", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "fetchServerSettings"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "fetchServerCapabilities", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, "fetchServerCapabilities"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "fetchUser", [_dec3], Object.getOwnPropertyDescriptor(_class.prototype, "fetchUser"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "fetchHTTPApiVersion", [_dec4], Object.getOwnPropertyDescriptor(_class.prototype, "fetchHTTPApiVersion"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "batch", [_dec5], Object.getOwnPropertyDescriptor(_class.prototype, "batch"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "deleteBuckets", [_dec6], Object.getOwnPropertyDescriptor(_class.prototype, "deleteBuckets"), _class.prototype)), _class));
exports.default = KintoClientBase;

},{"./batch":5,"./bucket":6,"./endpoint":8,"./http":10,"./requests":12,"./utils":13}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.aggregate = aggregate;
/**
 * Exports batch responses as a result object.
 *
 * @private
 * @param  {Array} responses The batch subrequest responses.
 * @param  {Array} requests  The initial issued requests.
 * @return {Object}
 */
function aggregate() {
  var responses = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
  var requests = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

  if (responses.length !== requests.length) {
    throw new Error("Responses length should match requests one.");
  }
  var results = {
    errors: [],
    published: [],
    conflicts: [],
    skipped: []
  };
  return responses.reduce(function (acc, response, index) {
    var status = response.status;

    if (status >= 200 && status < 400) {
      acc.published.push(response.body);
    } else if (status === 404) {
      acc.skipped.push(response.body);
    } else if (status === 412) {
      acc.conflicts.push({
        // XXX: specifying the type is probably superfluous
        type: "outgoing",
        local: requests[index].body,
        remote: response.body.details && response.body.details.existing || null
      });
    } else {
      acc.errors.push({
        path: response.path,
        sent: requests[index],
        error: response.body
      });
    }
    return acc;
  }, results);
}

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require("./utils");

var _collection = require("./collection");

var _collection2 = _interopRequireDefault(_collection);

var _requests = require("./requests");

var requests = _interopRequireWildcard(_requests);

var _endpoint = require("./endpoint");

var _endpoint2 = _interopRequireDefault(_endpoint);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Abstract representation of a selected bucket.
 *
 */

var Bucket = function () {
  /**
   * Constructor.
   *
   * @param  {KintoClient} client          The client instance.
   * @param  {String}      name            The bucket name.
   * @param  {Object}      options.headers The headers object option.
   * @param  {Boolean}     options.safe    The safe option.
   */

  function Bucket(client, name) {
    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, Bucket);

    /**
     * @ignore
     */
    this.client = client;
    /**
     * The bucket name.
     * @type {String}
     */
    this.name = name;
    /**
     * The default options object.
     * @ignore
     * @type {Object}
     */
    this.options = options;
    /**
     * @ignore
     */
    this._isBatch = !!options.batch;
  }

  /**
   * Merges passed request options with default bucket ones, if any.
   *
   * @private
   * @param  {Object} options The options to merge.
   * @return {Object}         The merged options.
   */


  _createClass(Bucket, [{
    key: "_bucketOptions",
    value: function _bucketOptions() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var headers = _extends({}, this.options && this.options.headers, options.headers);
      return _extends({}, this.options, options, {
        headers: headers,
        bucket: this.name,
        batch: this._isBatch
      });
    }

    /**
     * Selects a collection.
     *
     * @param  {String} name            The collection name.
     * @param  {Object} options         The options object.
     * @param  {Object} options.headers The headers object option.
     * @param  {Boolean}  options.safe  The safe option.
     * @return {Collection}
     */

  }, {
    key: "collection",
    value: function collection(name) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      return new _collection2.default(this.client, this, name, this._bucketOptions(options));
    }

    /**
     * Retrieves bucket data.
     *
     * @param  {Object} options         The options object.
     * @param  {Object} options.headers The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getData",
    value: function getData() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.client.execute({
        path: (0, _endpoint2.default)("bucket", this.name),
        headers: _extends({}, this.options.headers, options.headers)
      }).then(function (res) {
        return res.data;
      });
    }

    /**
     * Set bucket data.
     * @param  {Object}   data            The bucket data object.
     * @param  {Object}   options         The options object.
     * @param  {Object}   options.headers The headers object option.
     * @param  {Boolean}  options.safe    The safe option.
     * @param  {Boolean}  options.patch   The patch option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(data)) {
        throw new Error("A bucket object is required.");
      }

      var bucket = _extends({}, data, { id: this.name });

      // For default bucket, we need to drop the id from the data object.
      // Bug in Kinto < 3.1.1
      var bucketId = bucket.id;
      if (bucket.id === "default") {
        delete bucket.id;
      }

      var path = (0, _endpoint2.default)("bucket", bucketId);
      var permissions = options.permissions;

      var reqOptions = _extends({}, this._bucketOptions(options));
      var request = requests.updateRequest(path, { data: bucket, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Retrieves the list of collections in the current bucket.
     *
     * @param  {Object} options         The options object.
     * @param  {Object} options.headers The headers object option.
     * @return {Promise<Array<Object>, Error>}
     */

  }, {
    key: "listCollections",
    value: function listCollections() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.client.execute({
        path: (0, _endpoint2.default)("collection", this.name),
        headers: _extends({}, this.options.headers, options.headers)
      });
    }

    /**
     * Creates a new collection in current bucket.
     *
     * @param  {String|undefined}  id        The collection id.
     * @param  {Object}  options             The options object.
     * @param  {Boolean} options.safe        The safe option.
     * @param  {Object}  options.headers     The headers object option.
     * @param  {Object}  options.permissions The permissions object.
     * @param  {Object}  options.data        The data object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "createCollection",
    value: function createCollection(id) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var reqOptions = this._bucketOptions(options);
      var permissions = reqOptions.permissions;
      var _reqOptions$data = reqOptions.data;
      var data = _reqOptions$data === undefined ? {} : _reqOptions$data;

      data.id = id;
      var path = (0, _endpoint2.default)("collection", this.name, id);
      var request = requests.createRequest(path, { data: data, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Deletes a collection from the current bucket.
     *
     * @param  {Object|String} collection  The collection to delete.
     * @param  {Object}    options         The options object.
     * @param  {Object}    options.headers The headers object option.
     * @param  {Boolean}   options.safe    The safe option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteCollection",
    value: function deleteCollection(collection) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var collectionObj = (0, _utils.toDataBody)(collection);
      if (!collectionObj.id) {
        throw new Error("A collection id is required.");
      }
      var id = collectionObj.id;
      var last_modified = collectionObj.last_modified;

      var reqOptions = this._bucketOptions(_extends({ last_modified: last_modified }, options));
      var path = (0, _endpoint2.default)("collection", this.name, id);
      var request = requests.deleteRequest(path, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Retrieves the list of groups in the current bucket.
     *
     * @param  {Object} options         The options object.
     * @param  {Object} options.headers The headers object option.
     * @return {Promise<Array<Object>, Error>}
     */

  }, {
    key: "listGroups",
    value: function listGroups() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.client.execute({
        path: (0, _endpoint2.default)("group", this.name),
        headers: _extends({}, this.options.headers, options.headers)
      });
    }

    /**
     * Creates a new group in current bucket.
     *
     * @param  {String}  id                  The group id.
     * @param  {Object}  options             The options object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getGroup",
    value: function getGroup(id) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      return this.client.execute({
        path: (0, _endpoint2.default)("group", this.name, id),
        headers: _extends({}, this.options.headers, options.headers)
      });
    }

    /**
     * Creates a new group in current bucket.
     *
     * @param  {String|undefined}  id        The group id.
     * @param  {Array<String>}     members   The list of principals.
     * @param  {Object}  options             The options object.
     * @param  {Object}  options.data        The data object.
     * @param  {Object}  options.permissions The permissions object.
     * @param  {Boolean} options.safe        The safe option.
     * @param  {Object}  options.headers     The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "createGroup",
    value: function createGroup(id) {
      var members = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      var reqOptions = this._bucketOptions(options);
      var data = _extends({}, options.data, {
        id: id,
        members: members
      });
      var path = (0, _endpoint2.default)("group", this.name, id);
      var permissions = options.permissions;

      var request = requests.createRequest(path, { data: data, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Updates an existing group in current bucket.
     *
     * @param  {Object}  group               The group object.
     * @param  {Object}  options             The options object.
     * @param  {Object}  options.data        The data object.
     * @param  {Object}  options.permissions The permissions object.
     * @param  {Boolean} options.safe        The safe option.
     * @param  {Object}  options.headers     The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "updateGroup",
    value: function updateGroup(group) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(group)) {
        throw new Error("A group object is required.");
      }
      if (!group.id) {
        throw new Error("A group id is required.");
      }
      var reqOptions = this._bucketOptions(options);
      var data = _extends({}, options.data, group);
      var path = (0, _endpoint2.default)("group", this.name, group.id);
      var permissions = options.permissions;

      var request = requests.updateRequest(path, { data: data, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Deletes a group from the current bucket.
     *
     * @param  {Object|String} group       The group to delete.
     * @param  {Object}    options         The options object.
     * @param  {Object}    options.headers The headers object option.
     * @param  {Boolean}   options.safe    The safe option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteGroup",
    value: function deleteGroup(group) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var groupObj = (0, _utils.toDataBody)(group);
      var id = groupObj.id;
      var last_modified = groupObj.last_modified;

      var reqOptions = this._bucketOptions(_extends({ last_modified: last_modified }, options));
      var path = (0, _endpoint2.default)("group", this.name, id);
      var request = requests.deleteRequest(path, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Retrieves the list of permissions for this bucket.
     *
     * @param  {Object} options         The options object.
     * @param  {Object} options.headers The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getPermissions",
    value: function getPermissions() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      return this.client.execute({
        path: (0, _endpoint2.default)("bucket", this.name),
        headers: _extends({}, this.options.headers, options.headers)
      }).then(function (res) {
        return res.permissions;
      });
    }

    /**
     * Recplaces all existing bucket permissions with the ones provided.
     *
     * @param  {Object}  permissions           The permissions object.
     * @param  {Object}  options               The options object
     * @param  {Object}  options               The options object.
     * @param  {Boolean} options.safe          The safe option.
     * @param  {Object}  options.headers       The headers object option.
     * @param  {Object}  options.last_modified The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "setPermissions",
    value: function setPermissions(permissions) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(permissions)) {
        throw new Error("A permissions object is required.");
      }
      var path = (0, _endpoint2.default)("bucket", this.name);
      var reqOptions = _extends({}, this._bucketOptions(options));
      var last_modified = options.last_modified;

      var data = { last_modified: last_modified };
      var request = requests.updateRequest(path, { data: data, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Performs batch operations at the current bucket level.
     *
     * @param  {Function} fn                 The batch operation function.
     * @param  {Object}   options            The options object.
     * @param  {Object}   options.headers    The headers object option.
     * @param  {Boolean}  options.safe       The safe option.
     * @param  {Boolean}  options.aggregate  Produces a grouped result object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "batch",
    value: function batch(fn) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      return this.client.batch(fn, this._bucketOptions(options));
    }
  }]);

  return Bucket;
}();

exports.default = Bucket;

},{"./collection":7,"./endpoint":8,"./requests":12,"./utils":13}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require("./utils");

var _requests = require("./requests");

var requests = _interopRequireWildcard(_requests);

var _endpoint = require("./endpoint");

var _endpoint2 = _interopRequireDefault(_endpoint);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Abstract representation of a selected collection.
 *
 */

var Collection = function () {
  /**
   * Constructor.
   *
   * @param  {KintoClient}  client          The client instance.
   * @param  {Bucket}       bucket          The bucket instance.
   * @param  {String}       name            The collection name.
   * @param  {Object}       options.headers The headers object option.
   * @param  {Boolean}      options.safe    The safe option.
   */

  function Collection(client, bucket, name) {
    var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

    _classCallCheck(this, Collection);

    /**
     * @ignore
     */
    this.client = client;
    /**
     * @ignore
     */
    this.bucket = bucket;
    /**
     * The collection name.
     * @type {String}
     */
    this.name = name;

    /**
     * The default collection options object, embedding the default bucket ones.
     * @ignore
     * @type {Object}
     */
    this.options = _extends({}, this.bucket.options, options, {
      headers: _extends({}, this.bucket.options && this.bucket.options.headers, options.headers)
    });
    /**
     * @ignore
     */
    this._isBatch = !!options.batch;
  }

  /**
   * Merges passed request options with default bucket and collection ones, if
   * any.
   *
   * @private
   * @param  {Object} options The options to merge.
   * @return {Object}         The merged options.
   */


  _createClass(Collection, [{
    key: "_collOptions",
    value: function _collOptions() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var headers = _extends({}, this.options && this.options.headers, options.headers);
      return _extends({}, this.options, options, {
        headers: headers
      });
    }

    /**
     * Retrieves collection data.
     *
     * @param  {Object} options         The options object.
     * @param  {Object} options.headers The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getData",
    value: function getData() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var _collOptions2 = this._collOptions(options);

      var headers = _collOptions2.headers;

      return this.client.execute({
        path: (0, _endpoint2.default)("collection", this.bucket.name, this.name),
        headers: headers
      }).then(function (res) {
        return res.data;
      });
    }

    /**
     * Set collection data.
     * @param  {Object}   data            The collection data object.
     * @param  {Object}   options         The options object.
     * @param  {Object}   options.headers The headers object option.
     * @param  {Boolean}  options.safe    The safe option.
     * @param  {Boolean}  options.patch   The patch option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(data)) {
        throw new Error("A collection object is required.");
      }
      var reqOptions = this._collOptions(options);
      var permissions = reqOptions.permissions;


      var path = (0, _endpoint2.default)("collection", this.bucket.name, this.name);
      var request = requests.updateRequest(path, { data: data, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Retrieves the list of permissions for this collection.
     *
     * @param  {Object} options         The options object.
     * @param  {Object} options.headers The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getPermissions",
    value: function getPermissions() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var _collOptions3 = this._collOptions(options);

      var headers = _collOptions3.headers;

      return this.client.execute({
        path: (0, _endpoint2.default)("collection", this.bucket.name, this.name),
        headers: headers
      }).then(function (res) {
        return res.permissions;
      });
    }

    /**
     * Replaces all existing collection permissions with the ones provided.
     *
     * @param  {Object}   permissions     The permissions object.
     * @param  {Object}   options         The options object
     * @param  {Object}   options.headers The headers object option.
     * @param  {Boolean}  options.safe    The safe option.
     * @param  {Number}   options.last_modified The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "setPermissions",
    value: function setPermissions(permissions) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(permissions)) {
        throw new Error("A permissions object is required.");
      }
      var reqOptions = this._collOptions(options);
      var path = (0, _endpoint2.default)("collection", this.bucket.name, this.name);
      var data = { last_modified: options.last_modified };
      var request = requests.updateRequest(path, { data: data, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Creates a record in current collection.
     *
     * @param  {Object} record          The record to create.
     * @param  {Object} options         The options object.
     * @param  {Object} options.headers The headers object option.
     * @param  {Boolean}  options.safe  The safe option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "createRecord",
    value: function createRecord(record) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var reqOptions = this._collOptions(options);
      var permissions = reqOptions.permissions;

      var path = (0, _endpoint2.default)("record", this.bucket.name, this.name, record.id);
      var request = requests.createRequest(path, { data: record, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Updates a record in current collection.
     *
     * @param  {Object}  record                The record to update.
     * @param  {Object}  options               The options object.
     * @param  {Object}  options.headers       The headers object option.
     * @param  {Boolean} options.safe          The safe option.
     * @param  {Number}  options.last_modified The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "updateRecord",
    value: function updateRecord(record) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (!(0, _utils.isObject)(record)) {
        throw new Error("A record object is required.");
      }
      if (!record.id) {
        throw new Error("A record id is required.");
      }
      var reqOptions = this._collOptions(options);
      var permissions = reqOptions.permissions;

      var path = (0, _endpoint2.default)("record", this.bucket.name, this.name, record.id);
      var request = requests.updateRequest(path, { data: record, permissions: permissions }, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Deletes a record from the current collection.
     *
     * @param  {Object|String} record          The record to delete.
     * @param  {Object}        options         The options object.
     * @param  {Object}        options.headers The headers object option.
     * @param  {Boolean}       options.safe    The safe option.
     * @param  {Number}        options.last_modified The last_modified option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "deleteRecord",
    value: function deleteRecord(record) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var recordObj = (0, _utils.toDataBody)(record);
      if (!recordObj.id) {
        throw new Error("A record id is required.");
      }
      var id = recordObj.id;
      var last_modified = recordObj.last_modified;

      var reqOptions = this._collOptions(_extends({ last_modified: last_modified }, options));
      var path = (0, _endpoint2.default)("record", this.bucket.name, this.name, id);
      var request = requests.deleteRequest(path, reqOptions);
      return this.client.execute(request);
    }

    /**
     * Retrieves a record from the current collection.
     *
     * @param  {String} id              The record id to retrieve.
     * @param  {Object} options         The options object.
     * @param  {Object} options.headers The headers object option.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "getRecord",
    value: function getRecord(id) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      return this.client.execute(_extends({
        path: (0, _endpoint2.default)("record", this.bucket.name, this.name, id)
      }, this._collOptions(options)));
    }

    /**
     * Lists records from the current collection.
     *
     * Sorting is done by passing a `sort` string option:
     *
     * - The field to order the results by, prefixed with `-` for descending.
     * Default: `-last_modified`.
     *
     * @see http://kinto.readthedocs.io/en/stable/core/api/resource.html#sorting
     *
     * Filtering is done by passing a `filters` option object:
     *
     * - `{fieldname: "value"}`
     * - `{min_fieldname: 4000}`
     * - `{in_fieldname: "1,2,3"}`
     * - `{not_fieldname: 0}`
     * - `{exclude_fieldname: "0,1"}`
     *
     * @see http://kinto.readthedocs.io/en/stable/core/api/resource.html#filtering
     *
     * Paginating is done by passing a `limit` option, then calling the `next()`
     * method from the resolved result object to fetch the next page, if any.
     *
     * @param  {Object}   options         The options object.
     * @param  {Object}   options.headers The headers object option.
     * @param  {Object}   options.filters The filters object.
     * @param  {String}   options.sort    The sort field.
     * @param  {String}   options.limit   The limit field.
     * @param  {String}   options.pages   The number of result pages to aggregate.
     * @param  {Number}   options.since   Only retrieve records modified since the
     * provided timestamp.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "listRecords",
    value: function listRecords() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var http = this.client.http;

      var _sort$options = _extends({
        sort: "-last_modified"
      }, options);

      var sort = _sort$options.sort;
      var filters = _sort$options.filters;
      var limit = _sort$options.limit;
      var pages = _sort$options.pages;
      var since = _sort$options.since;
      // Safety/Consistency check on ETag value.

      if (since && typeof since !== "string") {
        throw new Error("Invalid value for since (" + since + "), should be ETag value.");
      }
      var collHeaders = this.options.headers;
      var path = (0, _endpoint2.default)("record", this.bucket.name, this.name);
      var querystring = (0, _utils.qsify)(_extends({}, filters, {
        _sort: sort,
        _limit: limit,
        _since: since
      }));
      var results = [],
          current = 0;

      var next = function next(nextPage) {
        if (!nextPage) {
          throw new Error("Pagination exhausted.");
        }
        return processNextPage(nextPage);
      };

      var processNextPage = function processNextPage(nextPage) {
        return http.request(nextPage, { headers: collHeaders }).then(handleResponse);
      };

      var pageResults = function pageResults(results, nextPage, etag) {
        return {
          last_modified: etag,
          data: results,
          next: next.bind(null, nextPage)
        };
      };

      var handleResponse = function handleResponse(_ref) {
        var headers = _ref.headers;
        var json = _ref.json;

        var nextPage = headers.get("Next-Page");
        // ETag are supposed to be opaque and stored «as-is».
        var etag = headers.get("ETag");
        if (!pages) {
          return pageResults(json.data, nextPage, etag);
        }
        // Aggregate new results with previous ones
        results = results.concat(json.data);
        current += 1;
        if (current >= pages || !nextPage) {
          // Pagination exhausted
          return pageResults(results, nextPage, etag);
        }
        // Follow next page
        return processNextPage(nextPage);
      };

      return this.client.execute(_extends({
        path: path + "?" + querystring
      }, this._collOptions(options)), { raw: true }).then(handleResponse);
    }

    /**
     * Performs batch operations at the current collection level.
     *
     * @param  {Function} fn                 The batch operation function.
     * @param  {Object}   options            The options object.
     * @param  {Object}   options.headers    The headers object option.
     * @param  {Boolean}  options.safe       The safe option.
     * @param  {Boolean}  options.aggregate  Produces a grouped result object.
     * @return {Promise<Object, Error>}
     */

  }, {
    key: "batch",
    value: function batch(fn) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var reqOptions = this._collOptions(options);
      return this.client.batch(fn, _extends({}, reqOptions, {
        bucket: this.bucket.name,
        collection: this.name
      }));
    }
  }]);

  return Collection;
}();

exports.default = Collection;

},{"./endpoint":8,"./requests":12,"./utils":13}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = endpoint;
/**
 * Endpoints templates.
 * @type {Object}
 */
var ENDPOINTS = {
  root: function root() {
    return "/";
  },
  batch: function batch() {
    return "/batch";
  },
  bucket: function bucket(_bucket) {
    return "/buckets" + (_bucket ? "/" + _bucket : "");
  },
  collection: function collection(bucket, coll) {
    return ENDPOINTS.bucket(bucket) + "/collections" + (coll ? "/" + coll : "");
  },
  group: function group(bucket, _group) {
    return ENDPOINTS.bucket(bucket) + "/groups" + (_group ? "/" + _group : "");
  },
  record: function record(bucket, coll, id) {
    return ENDPOINTS.collection(bucket, coll) + "/records" + (id ? "/" + id : "");
  }
};

/**
 * Retrieves a server enpoint by its name.
 *
 * @private
 * @param  {String}    name The endpoint name.
 * @param  {...string} args The endpoint parameters.
 * @return {String}
 */
function endpoint(name) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return ENDPOINTS[name].apply(ENDPOINTS, args);
}

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Kinto server error code descriptors.
 * @type {Object}
 */
exports.default = {
  104: "Missing Authorization Token",
  105: "Invalid Authorization Token",
  106: "Request body was not valid JSON",
  107: "Invalid request parameter",
  108: "Missing request parameter",
  109: "Invalid posted data",
  110: "Invalid Token / id",
  111: "Missing Token / id",
  112: "Content-Length header was not provided",
  113: "Request body too large",
  114: "Resource was modified meanwhile",
  115: "Method not allowed on this end point",
  116: "Requested version not available on this server",
  117: "Client has sent too many requests",
  121: "Resource access is forbidden for this user",
  122: "Another resource violates constraint",
  201: "Service Temporary unavailable due to high load",
  202: "Service deprecated",
  999: "Internal Server Error"
};

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _errors = require("./errors");

var _errors2 = _interopRequireDefault(_errors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Enhanced HTTP client for the Kinto protocol.
 * @private
 */

var HTTP = function () {
  _createClass(HTTP, null, [{
    key: "DEFAULT_REQUEST_HEADERS",

    /**
     * Default HTTP request headers applied to each outgoing request.
     *
     * @type {Object}
     */
    get: function get() {
      return {
        "Accept": "application/json",
        "Content-Type": "application/json"
      };
    }

    /**
     * Default options.
     *
     * @type {Object}
     */

  }, {
    key: "defaultOptions",
    get: function get() {
      return { timeout: 5000, requestMode: "cors" };
    }

    /**
     * Constructor.
     *
     * Options:
     * - {Number} timeout      The request timeout in ms (default: `5000`).
     * - {String} requestMode  The HTTP request mode (default: `"cors"`).
     *
     * @param {EventEmitter} events  The event handler.
     * @param {Object}       options The options object.
     */

  }]);

  function HTTP(events) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, HTTP);

    // public properties
    /**
     * The event emitter instance.
     * @type {EventEmitter}
     */
    if (!events) {
      throw new Error("No events handler provided");
    }
    this.events = events;

    /**
     * The request mode.
     * @see  https://fetch.spec.whatwg.org/#requestmode
     * @type {String}
     */
    this.requestMode = options.requestMode || HTTP.defaultOptions.requestMode;

    /**
     * The request timeout.
     * @type {Number}
     */
    this.timeout = options.timeout || HTTP.defaultOptions.timeout;
  }

  /**
   * Performs an HTTP request to the Kinto server.
   *
   * Options:
   * - `{Object} headers` The request headers object (default: {})
   *
   * Resolves with an objet containing the following HTTP response properties:
   * - `{Number}  status`  The HTTP status code.
   * - `{Object}  json`    The JSON response body.
   * - `{Headers} headers` The response headers object; see the ES6 fetch() spec.
   *
   * @param  {String} url     The URL.
   * @param  {Object} options The fetch() options object.
   * @return {Promise}
   */


  _createClass(HTTP, [{
    key: "request",
    value: function request(url) {
      var _this = this;

      var options = arguments.length <= 1 || arguments[1] === undefined ? { headers: {} } : arguments[1];

      var response = void 0,
          status = void 0,
          statusText = void 0,
          headers = void 0,
          hasTimedout = void 0;
      // Ensure default request headers are always set
      options.headers = Object.assign({}, HTTP.DEFAULT_REQUEST_HEADERS, options.headers);
      options.mode = this.requestMode;
      return new Promise(function (resolve, reject) {
        var _timeoutId = setTimeout(function () {
          hasTimedout = true;
          reject(new Error("Request timeout."));
        }, _this.timeout);
        fetch(url, options).then(function (res) {
          if (!hasTimedout) {
            clearTimeout(_timeoutId);
            resolve(res);
          }
        }).catch(function (err) {
          if (!hasTimedout) {
            clearTimeout(_timeoutId);
            reject(err);
          }
        });
      }).then(function (res) {
        response = res;
        headers = res.headers;
        status = res.status;
        statusText = res.statusText;
        _this._checkForDeprecationHeader(headers);
        _this._checkForBackoffHeader(status, headers);
        _this._checkForRetryAfterHeader(status, headers);
        return res.text();
      })
      // Check if we have a body; if so parse it as JSON.
      .then(function (text) {
        if (text.length === 0) {
          return null;
        }
        // Note: we can't consume the response body twice.
        return JSON.parse(text);
      }).catch(function (err) {
        var error = new Error("HTTP " + (status || 0) + "; " + err);
        error.response = response;
        error.stack = err.stack;
        throw error;
      }).then(function (json) {
        if (json && status >= 400) {
          var message = "HTTP " + status + " " + (json.error || "") + ": ";
          if (json.errno && json.errno in _errors2.default) {
            var errnoMsg = _errors2.default[json.errno];
            message += errnoMsg;
            if (json.message && json.message !== errnoMsg) {
              message += " (" + json.message + ")";
            }
          } else {
            message += statusText || "";
          }
          var error = new Error(message.trim());
          error.response = response;
          error.data = json;
          throw error;
        }
        return { status: status, json: json, headers: headers };
      });
    }
  }, {
    key: "_checkForDeprecationHeader",
    value: function _checkForDeprecationHeader(headers) {
      var alertHeader = headers.get("Alert");
      if (!alertHeader) {
        return;
      }
      var alert = void 0;
      try {
        alert = JSON.parse(alertHeader);
      } catch (err) {
        console.warn("Unable to parse Alert header message", alertHeader);
        return;
      }
      console.warn(alert.message, alert.url);
      this.events.emit("deprecated", alert);
    }
  }, {
    key: "_checkForBackoffHeader",
    value: function _checkForBackoffHeader(status, headers) {
      var backoffMs = void 0;
      var backoffSeconds = parseInt(headers.get("Backoff"), 10);
      if (backoffSeconds > 0) {
        backoffMs = new Date().getTime() + backoffSeconds * 1000;
      } else {
        backoffMs = 0;
      }
      this.events.emit("backoff", backoffMs);
    }
  }, {
    key: "_checkForRetryAfterHeader",
    value: function _checkForRetryAfterHeader(status, headers) {
      var retryAfter = headers.get("Retry-After");
      if (!retryAfter) {
        return;
      }
      retryAfter = new Date().getTime() + parseInt(retryAfter, 10) * 1000;
      this.events.emit("retry-after", retryAfter);
    }
  }]);

  return HTTP;
}();

exports.default = HTTP;

},{"./errors":9}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

require("isomorphic-fetch");

var _events = require("events");

var _base = require("./base");

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KintoClient = function (_KintoClientBase) {
  _inherits(KintoClient, _KintoClientBase);

  function KintoClient(remote) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, KintoClient);

    var events = options.events || new _events.EventEmitter();

    return _possibleConstructorReturn(this, Object.getPrototypeOf(KintoClient).call(this, remote, Object.assign({ events: events }, options)));
  }

  return KintoClient;
}(_base2.default);

exports.default = KintoClient;

},{"./base":4,"events":1,"isomorphic-fetch":2}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.createRequest = createRequest;
exports.updateRequest = updateRequest;
exports.deleteRequest = deleteRequest;

var _utils = require("./utils");

var requestDefaults = {
  safe: false,
  // check if we should set default content type here
  headers: {},
  permissions: undefined,
  data: undefined,
  patch: false
};

function safeHeader(safe, last_modified) {
  if (!safe) {
    return {};
  }
  if (last_modified) {
    return { "If-Match": "\"" + last_modified + "\"" };
  }
  return { "If-None-Match": "*" };
}

/**
 * @private
 */
function createRequest(path, _ref) {
  var data = _ref.data;
  var permissions = _ref.permissions;
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var _requestDefaults$opti = _extends({}, requestDefaults, options);

  var headers = _requestDefaults$opti.headers;
  var safe = _requestDefaults$opti.safe;

  return {
    method: data && data.id ? "PUT" : "POST",
    path: path,
    headers: _extends({}, headers, safeHeader(safe)),
    body: {
      data: data,
      permissions: permissions
    }
  };
}

/**
 * @private
 */
function updateRequest(path, _ref2) {
  var data = _ref2.data;
  var permissions = _ref2.permissions;
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var _requestDefaults$opti2 = _extends({}, requestDefaults, options);

  var headers = _requestDefaults$opti2.headers;
  var safe = _requestDefaults$opti2.safe;
  var patch = _requestDefaults$opti2.patch;

  var _data$options = _extends({}, data, options);

  var last_modified = _data$options.last_modified;


  if (Object.keys((0, _utils.omit)(data, "id", "last_modified")).length === 0) {
    data = undefined;
  }

  return {
    method: patch ? "PATCH" : "PUT",
    path: path,
    headers: _extends({}, headers, safeHeader(safe, last_modified)),
    body: {
      data: data,
      permissions: permissions
    }
  };
}

/**
 * @private
 */
function deleteRequest(path) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var _requestDefaults$opti3 = _extends({}, requestDefaults, options);

  var headers = _requestDefaults$opti3.headers;
  var safe = _requestDefaults$opti3.safe;
  var last_modified = _requestDefaults$opti3.last_modified;

  if (safe && !last_modified) {
    throw new Error("Safe concurrency check requires a last_modified value.");
  }
  return {
    method: "DELETE",
    path: path,
    headers: _extends({}, headers, safeHeader(safe, last_modified))
  };
}

},{"./utils":13}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.partition = partition;
exports.pMap = pMap;
exports.omit = omit;
exports.toDataBody = toDataBody;
exports.qsify = qsify;
exports.checkVersion = checkVersion;
exports.support = support;
exports.nobatch = nobatch;
exports.isObject = isObject;
/**
 * Chunks an array into n pieces.
 *
 * @private
 * @param  {Array}  array
 * @param  {Number} n
 * @return {Array}
 */
function partition(array, n) {
  if (n <= 0) {
    return array;
  }
  return array.reduce(function (acc, x, i) {
    if (i === 0 || i % n === 0) {
      acc.push([x]);
    } else {
      acc[acc.length - 1].push(x);
    }
    return acc;
  }, []);
}

/**
 * Maps a list to promises using the provided mapping function, executes them
 * sequentially then returns a Promise resolving with ordered results obtained.
 * Think of this as a sequential Promise.all.
 *
 * @private
 * @param  {Array}    list The list to map.
 * @param  {Function} fn   The mapping function.
 * @return {Promise}
 */
function pMap(list, fn) {
  var results = [];
  return list.reduce(function (promise, entry) {
    return promise.then(function () {
      return Promise.resolve(fn(entry)).then(function (result) {
        return results = results.concat(result);
      });
    });
  }, Promise.resolve()).then(function () {
    return results;
  });
}

/**
 * Takes an object and returns a copy of it with the provided keys omitted.
 *
 * @private
 * @param  {Object}    obj  The source object.
 * @param  {...String} keys The keys to omit.
 * @return {Object}
 */
function omit(obj) {
  for (var _len = arguments.length, keys = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }

  return Object.keys(obj).reduce(function (acc, key) {
    if (keys.indexOf(key) === -1) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}

/**
 * Always returns a resource data object from the provided argument.
 *
 * @private
 * @param  {Object|String} resource
 * @return {Object}
 */
function toDataBody(resource) {
  if (isObject(resource)) {
    return resource;
  }
  if (typeof resource === "string") {
    return { id: resource };
  }
  throw new Error("Invalid argument.");
}

/**
 * Transforms an object into an URL query string, stripping out any undefined
 * values.
 *
 * @param  {Object} obj
 * @return {String}
 */
function qsify(obj) {
  var sep = "&";
  var encode = function encode(v) {
    return encodeURIComponent(typeof v === "boolean" ? String(v) : v);
  };
  var stripUndefined = function stripUndefined(o) {
    return JSON.parse(JSON.stringify(o));
  };
  var stripped = stripUndefined(obj);
  return Object.keys(stripped).map(function (k) {
    var ks = encode(k) + "=";
    if (Array.isArray(stripped[k])) {
      return stripped[k].map(function (v) {
        return ks + encode(v);
      }).join(sep);
    } else {
      return ks + encode(stripped[k]);
    }
  }).join(sep);
}

/**
 * Checks if a version is within the provided range.
 *
 * @param  {String} version    The version to check.
 * @param  {String} minVersion The minimum supported version (inclusive).
 * @param  {String} maxVersion The minimum supported version (exclusive).
 * @throws {Error} If the version is outside of the provided range.
 */
function checkVersion(version, minVersion, maxVersion) {
  var extract = function extract(str) {
    return str.split(".").map(function (x) {
      return parseInt(x, 10);
    });
  };

  var _extract = extract(version);

  var _extract2 = _slicedToArray(_extract, 2);

  var verMajor = _extract2[0];
  var verMinor = _extract2[1];

  var _extract3 = extract(minVersion);

  var _extract4 = _slicedToArray(_extract3, 2);

  var minMajor = _extract4[0];
  var minMinor = _extract4[1];

  var _extract5 = extract(maxVersion);

  var _extract6 = _slicedToArray(_extract5, 2);

  var maxMajor = _extract6[0];
  var maxMinor = _extract6[1];

  var checks = [verMajor < minMajor, verMajor === minMajor && verMinor < minMinor, verMajor > maxMajor, verMajor === maxMajor && verMinor >= maxMinor];
  if (checks.some(function (x) {
    return x;
  })) {
    throw new Error("Version " + version + " doesn't satisfy " + (minVersion + " <= x < " + maxVersion));
  }
}

/**
 * Generates a decorator function ensuring a version check is performed against
 * the provided requirements before executing it.
 *
 * @param  {String} min The required min version (inclusive).
 * @param  {String} max The required max version (inclusive).
 * @return {Function}
 */
function support(min, max) {
  return function (target, key, descriptor) {
    var fn = descriptor.value;
    return {
      configurable: true,
      get: function get() {
        var _this = this;

        var wrappedMethod = function wrappedMethod() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          // "this" is the current instance which its method is decorated.
          var client = "client" in _this ? _this.client : _this;
          return client.fetchHTTPApiVersion().then(function (version) {
            return checkVersion(version, min, max);
          }).then(Promise.resolve(fn.apply(_this, args)));
        };
        Object.defineProperty(this, key, {
          value: wrappedMethod,
          configurable: true,
          writable: true
        });
        return wrappedMethod;
      }
    };
  };
}

/**
 * Generates a decorator function ensuring an operation is not performed from
 * within a batch request.
 *
 * @param  {String} message The error message to throw.
 * @return {Function}
 */
function nobatch(message) {
  return function (target, key, descriptor) {
    var fn = descriptor.value;
    return {
      configurable: true,
      get: function get() {
        var _this2 = this;

        var wrappedMethod = function wrappedMethod() {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          // "this" is the current instance which its method is decorated.
          if (_this2._isBatch) {
            throw new Error(message);
          }
          return fn.apply(_this2, args);
        };
        Object.defineProperty(this, key, {
          value: wrappedMethod,
          configurable: true,
          writable: true
        });
        return wrappedMethod;
      }
    };
  };
}

/**
 * Returns true if the specified value is an object (i.e. not an array nor null).
 * @param  {Object} thing The value to inspect.
 * @return {bool}
 */
function isObject(thing) {
  return (typeof thing === "undefined" ? "undefined" : _typeof(thing)) === "object" && thing !== null && !Array.isArray(thing);
}

},{}]},{},[11])(11)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9pc29tb3JwaGljLWZldGNoL2ZldGNoLW5wbS1icm93c2VyaWZ5LmpzIiwibm9kZV9tb2R1bGVzL2lzb21vcnBoaWMtZmV0Y2gvbm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcyIsInNyYy9iYXNlLmpzIiwic3JjL2JhdGNoLmpzIiwic3JjL2J1Y2tldC5qcyIsInNyYy9jb2xsZWN0aW9uLmpzIiwic3JjL2VuZHBvaW50LmpzIiwic3JjL2Vycm9ycy5qcyIsInNyYy9odHRwLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL3JlcXVlc3RzLmpzIiwic3JjL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LGlCQUFPLGFBQVA7QUFDQSx3QkFBYyxJQUFkO0FBQ0Esb0JBQVUsSUFBVjtTQUhGLEVBUkk7QUFhSixlQUFPLGFBQVAsQ0FiSTtPQUZEO0tBQVAsQ0FGdUM7R0FBbEMsQ0FEeUI7Q0FBM0I7Ozs7Ozs7OztBQStCQSxTQUFTLE9BQVQsQ0FBaUIsT0FBakIsRUFBMEI7QUFDL0IsU0FBTyxVQUFTLE1BQVQsRUFBaUIsR0FBakIsRUFBc0IsVUFBdEIsRUFBa0M7QUFDdkMsUUFBTSxLQUFLLFdBQVcsS0FBWCxDQUQ0QjtBQUV2QyxXQUFPO0FBQ0wsb0JBQWMsSUFBZDtBQUNBLDBCQUFNOzs7QUFDSixZQUFNLGdCQUFnQixTQUFoQixhQUFnQixHQUFhOzZDQUFUOztXQUFTOzs7QUFFakMsY0FBSSxPQUFLLFFBQUwsRUFBZTtBQUNqQixrQkFBTSxJQUFJLEtBQUosQ0FBVSxPQUFWLENBQU4sQ0FEaUI7V0FBbkI7QUFHQSxpQkFBTyxHQUFHLEtBQUgsU0FBZSxJQUFmLENBQVAsQ0FMaUM7U0FBYixDQURsQjtBQVFKLGVBQU8sY0FBUCxDQUFzQixJQUF0QixFQUE0QixHQUE1QixFQUFpQztBQUMvQixpQkFBTyxhQUFQO0FBQ0Esd0JBQWMsSUFBZDtBQUNBLG9CQUFVLElBQVY7U0FIRixFQVJJO0FBYUosZUFBTyxhQUFQLENBYkk7T0FGRDtLQUFQLENBRnVDO0dBQWxDLENBRHdCO0NBQTFCOzs7Ozs7O0FBNkJBLFNBQVMsUUFBVCxDQUFrQixLQUFsQixFQUF5QjtBQUM5QixTQUFPLFFBQU8scURBQVAsS0FBaUIsUUFBakIsSUFBNkIsVUFBVSxJQUFWLElBQWtCLENBQUMsTUFBTSxPQUFOLENBQWMsS0FBZCxDQUFELENBRHhCO0NBQXpCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8vIHRoZSB3aGF0d2ctZmV0Y2ggcG9seWZpbGwgaW5zdGFsbHMgdGhlIGZldGNoKCkgZnVuY3Rpb25cbi8vIG9uIHRoZSBnbG9iYWwgb2JqZWN0ICh3aW5kb3cgb3Igc2VsZilcbi8vXG4vLyBSZXR1cm4gdGhhdCBhcyB0aGUgZXhwb3J0IGZvciB1c2UgaW4gV2VicGFjaywgQnJvd3NlcmlmeSBldGMuXG5yZXF1aXJlKCd3aGF0d2ctZmV0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gc2VsZi5mZXRjaC5iaW5kKHNlbGYpO1xuIiwiKGZ1bmN0aW9uKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmIChzZWxmLmZldGNoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG5cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgICB2YXIgbGlzdCA9IHRoaXMubWFwW25hbWVdXG4gICAgaWYgKCFsaXN0KSB7XG4gICAgICBsaXN0ID0gW11cbiAgICAgIHRoaXMubWFwW25hbWVdID0gbGlzdFxuICAgIH1cbiAgICBsaXN0LnB1c2godmFsdWUpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG4gICAgcmV0dXJuIHZhbHVlcyA/IHZhbHVlc1swXSA6IG51bGxcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gfHwgW11cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBbbm9ybWFsaXplVmFsdWUodmFsdWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5tYXApLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5tYXBbbmFtZV0uZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzKVxuICAgICAgfSwgdGhpcylcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgICB9XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gICAgcmV0dXJuIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICAgIHJldHVybiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB9XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHlcbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIC8vIE9ubHkgc3VwcG9ydCBBcnJheUJ1ZmZlcnMgZm9yIFBPU1QgbWV0aG9kLlxuICAgICAgICAvLyBSZWNlaXZpbmcgQXJyYXlCdWZmZXJzIGhhcHBlbnMgdmlhIEJsb2JzLCBpbnN0ZWFkLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIHJldHVybiByZWplY3RlZCA/IHJlamVjdGVkIDogUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuICAgIGlmIChSZXF1ZXN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGlucHV0KSkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IGlucHV0XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnb21pdCdcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpXG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsXG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGxcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSlcbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMpXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhlYWRlcnMoeGhyKSB7XG4gICAgdmFyIGhlYWQgPSBuZXcgSGVhZGVycygpXG4gICAgdmFyIHBhaXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnRyaW0oKS5zcGxpdCgnXFxuJylcbiAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgdmFyIHNwbGl0ID0gaGVhZGVyLnRyaW0oKS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gc3BsaXQuc2hpZnQoKS50cmltKClcbiAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJzonKS50cmltKClcbiAgICAgIGhlYWQuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgfSlcbiAgICByZXR1cm4gaGVhZFxuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzXG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dFxuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgPyBvcHRpb25zLmhlYWRlcnMgOiBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KVxuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9XG5cbiAgc2VsZi5IZWFkZXJzID0gSGVhZGVycztcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlO1xuXG4gIHNlbGYuZmV0Y2ggPSBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0XG4gICAgICBpZiAoUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgJiYgIWluaXQpIHtcbiAgICAgICAgcmVxdWVzdCA9IGlucHV0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgICBmdW5jdGlvbiByZXNwb25zZVVSTCgpIHtcbiAgICAgICAgaWYgKCdyZXNwb25zZVVSTCcgaW4geGhyKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVVSTFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXZvaWQgc2VjdXJpdHkgd2FybmluZ3Mgb24gZ2V0UmVzcG9uc2VIZWFkZXIgd2hlbiBub3QgYWxsb3dlZCBieSBDT1JTXG4gICAgICAgIGlmICgvXlgtUmVxdWVzdC1VUkw6L20udGVzdCh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1SZXF1ZXN0LVVSTCcpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9ICh4aHIuc3RhdHVzID09PSAxMjIzKSA/IDIwNCA6IHhoci5zdGF0dXNcbiAgICAgICAgaWYgKHN0YXR1cyA8IDEwMCB8fCBzdGF0dXMgPiA1OTkpIHtcbiAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMoeGhyKSxcbiAgICAgICAgICB1cmw6IHJlc3BvbnNlVVJMKClcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSlcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgfSlcblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgICB9KVxuICB9XG4gIHNlbGYuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcGFydGl0aW9uLCBwTWFwLCBvbWl0LCBzdXBwb3J0LCBub2JhdGNoLCB0b0RhdGFCb2R5IH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCBIVFRQIGZyb20gXCIuL2h0dHBcIjtcbmltcG9ydCBlbmRwb2ludCBmcm9tIFwiLi9lbmRwb2ludFwiO1xuaW1wb3J0ICogYXMgcmVxdWVzdHMgZnJvbSBcIi4vcmVxdWVzdHNcIjtcbmltcG9ydCB7IGFnZ3JlZ2F0ZSB9IGZyb20gXCIuL2JhdGNoXCI7XG5pbXBvcnQgQnVja2V0IGZyb20gXCIuL2J1Y2tldFwiO1xuXG5cbi8qKlxuICogQ3VycmVudGx5IHN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uLlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IFNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OID0gXCJ2MVwiO1xuXG4vKipcbiAqIEhpZ2ggbGV2ZWwgSFRUUCBjbGllbnQgZm9yIHRoZSBLaW50byBBUEkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGNsaWVudCA9IG5ldyBLaW50b0NsaWVudChcImh0dHBzOi8va2ludG8uZGV2Lm1vemF3cy5uZXQvdjFcIik7XG4gKiBjbGllbnQuYnVja2V0KFwiZGVmYXVsdFwiKVxuKiAgICAuY29sbGVjdGlvbihcIm15LWJsb2dcIilcbiogICAgLmNyZWF0ZVJlY29yZCh7dGl0bGU6IFwiRmlyc3QgYXJ0aWNsZVwifSlcbiAqICAgLnRoZW4oY29uc29sZS5sb2cuYmluZChjb25zb2xlKSlcbiAqICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtpbnRvQ2xpZW50QmFzZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSByZW1vdGUgIFRoZSByZW1vdGUgVVJMLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvcHRpb25zIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5zYWZlICAgICAgICBBZGRzIGNvbmN1cnJlbmN5IGhlYWRlcnMgdG8gZXZlcnlcbiAgICogcmVxdWVzdHMgKGRlZmF1bHQ6IGB0cnVlYCkuXG4gICAqIEBwYXJhbSAge0V2ZW50RW1pdHRlcn0gb3B0aW9ucy5ldmVudHMgVGhlIGV2ZW50cyBoYW5kbGVyLiBJZiBub25lIHByb3ZpZGVkXG4gICAqIGFuIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb3B0aW9ucy5oZWFkZXJzICAgICBUaGUga2V5LXZhbHVlIGhlYWRlcnMgdG8gcGFzcyB0byBlYWNoXG4gICAqIHJlcXVlc3QgKGRlZmF1bHQ6IGB7fWApLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBvcHRpb25zLmJ1Y2tldCAgICAgIFRoZSBkZWZhdWx0IGJ1Y2tldCB0byB1c2UgKGRlZmF1bHQ6XG4gICAqIGBcImRlZmF1bHRcImApXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIG9wdGlvbnMucmVxdWVzdE1vZGUgVGhlIEhUVFAgcmVxdWVzdCBtb2RlIChmcm9tIEVTNiBmZXRjaFxuICAgKiBzcGVjKS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgb3B0aW9ucy50aW1lb3V0ICAgICBUaGUgcmVxdWVzdHMgdGltZW91dCBpbiBtcyAoZGVmYXVsdDogYDUwMDBgKS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbW90ZSwgb3B0aW9ucz17fSkge1xuICAgIGlmICh0eXBlb2YocmVtb3RlKSAhPT0gXCJzdHJpbmdcIiB8fCAhcmVtb3RlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZW1vdGUgVVJMOiBcIiArIHJlbW90ZSk7XG4gICAgfVxuICAgIGlmIChyZW1vdGVbcmVtb3RlLmxlbmd0aC0xXSA9PT0gXCIvXCIpIHtcbiAgICAgIHJlbW90ZSA9IHJlbW90ZS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHRoaXMuX2JhY2tvZmZSZWxlYXNlVGltZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHJlcXVlc3Qgb3B0aW9ucyBjb250YWluZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuZGVmYXVsdFJlcU9wdGlvbnMgPSB7XG4gICAgICBidWNrZXQ6ICBvcHRpb25zLmJ1Y2tldCAgfHwgXCJkZWZhdWx0XCIsXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMgfHwge30sXG4gICAgICBzYWZlOiAgICAhIW9wdGlvbnMuc2FmZSxcbiAgICB9O1xuXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9pc0JhdGNoID0gISFvcHRpb25zLmJhdGNoO1xuXG4gICAgLy8gcHVibGljIHByb3BlcnRpZXNcbiAgICAvKipcbiAgICAgKiBUaGUgcmVtb3RlIHNlcnZlciBiYXNlIFVSTC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucmVtb3RlID0gcmVtb3RlO1xuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc2VydmVyIGluZm9ybWF0aW9uLlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zZXJ2ZXJJbmZvID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgZW1pdHRlciBpbnN0YW5jZS4gU2hvdWxkIGNvbXBseSB3aXRoIHRoZSBgRXZlbnRFbWl0dGVyYFxuICAgICAqIGludGVyZmFjZS5cbiAgICAgKiBAaWdub3JlXG4gICAgICogQHR5cGUge0NsYXNzfVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRzID0gb3B0aW9ucy5ldmVudHM7XG5cbiAgICBjb25zdCB7cmVxdWVzdE1vZGUsIHRpbWVvdXR9ID0gb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiBUaGUgSFRUUCBpbnN0YW5jZS5cbiAgICAgKiBAaWdub3JlXG4gICAgICogQHR5cGUge0hUVFB9XG4gICAgICovXG4gICAgdGhpcy5odHRwID0gbmV3IEhUVFAodGhpcy5ldmVudHMsIHtyZXF1ZXN0TW9kZSwgdGltZW91dH0pO1xuICAgIHRoaXMuX3JlZ2lzdGVySFRUUEV2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByZW1vdGUgZW5kcG9pbnQgYmFzZSBVUkwuIFNldHRpbmcgdGhlIHZhbHVlIHdpbGwgYWxzbyBleHRyYWN0IGFuZFxuICAgKiB2YWxpZGF0ZSB0aGUgdmVyc2lvbi5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCByZW1vdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbW90ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzZXQgcmVtb3RlKHVybCkge1xuICAgIGxldCB2ZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICB2ZXJzaW9uID0gdXJsLm1hdGNoKC9cXC8odlxcZCspXFwvPyQvKVsxXTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZW1vdGUgVVJMIG11c3QgY29udGFpbiB0aGUgdmVyc2lvbjogXCIgKyB1cmwpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiAhPT0gU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT04pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHt2ZXJzaW9ufWApO1xuICAgIH1cbiAgICB0aGlzLl9yZW1vdGUgPSB1cmw7XG4gICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gIH1cblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc2VydmVyIHByb3RvY29sIHZlcnNpb24sIGVnLiBgdjFgLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcnNpb247XG4gIH1cblxuICAvKipcbiAgICogQmFja29mZiByZW1haW5pbmcgdGltZSwgaW4gbWlsbGlzZWNvbmRzLiBEZWZhdWx0cyB0byB6ZXJvIGlmIG5vIGJhY2tvZmYgaXNcbiAgICogb25nb2luZy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBiYWNrb2ZmKCkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgaWYgKHRoaXMuX2JhY2tvZmZSZWxlYXNlVGltZSAmJiBjdXJyZW50VGltZSA8IHRoaXMuX2JhY2tvZmZSZWxlYXNlVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2JhY2tvZmZSZWxlYXNlVGltZSAtIGN1cnJlbnRUaW1lO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgSFRUUCBldmVudHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVnaXN0ZXJIVFRQRXZlbnRzKCkge1xuICAgIC8vIFByZXZlbnQgcmVnaXN0ZXJpbmcgZXZlbnQgZnJvbSBhIGJhdGNoIGNsaWVudCBpbnN0YW5jZVxuICAgIGlmICghdGhpcy5faXNCYXRjaCkge1xuICAgICAgdGhpcy5ldmVudHMub24oXCJiYWNrb2ZmXCIsIGJhY2tvZmZNcyA9PiB7XG4gICAgICAgIHRoaXMuX2JhY2tvZmZSZWxlYXNlVGltZSA9IGJhY2tvZmZNcztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhIGJ1Y2tldCBvYmplY3QgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lICAgIFRoZSBidWNrZXQgbmFtZS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb3B0aW9ucyBUaGUgcmVxdWVzdCBvcHRpb25zLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBzYWZlICAgIFRoZSByZXN1bHRpbmcgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIGJ1Y2tldCAgVGhlIHJlc3VsdGluZyBidWNrZXQgbmFtZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gIGhlYWRlcnMgVGhlIGV4dGVuZGVkIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiB7QnVja2V0fVxuICAgKi9cbiAgYnVja2V0KG5hbWUsIG9wdGlvbnM9e30pIHtcbiAgICBjb25zdCBidWNrZXRPcHRpb25zID0gb21pdCh0aGlzLl9nZXRSZXF1ZXN0T3B0aW9ucyhvcHRpb25zKSwgXCJidWNrZXRcIik7XG4gICAgcmV0dXJuIG5ldyBCdWNrZXQodGhpcywgbmFtZSwgYnVja2V0T3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcmVxdWVzdCBvcHRpb25zIG9iamVjdCwgZGVlcGx5IG1lcmdpbmcgdGhlIGNsaWVudCBjb25maWd1cmVkXG4gICAqIGRlZmF1bHRzIHdpdGggdGhlIG9uZXMgcHJvdmlkZWQgYXMgYXJndW1lbnQuXG4gICAqXG4gICAqIE5vdGU6IEhlYWRlcnMgd29uJ3QgYmUgb3ZlcnJpZGVuIGJ1dCBtZXJnZWQgd2l0aCBpbnN0YW5jZSBkZWZhdWx0IG9uZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAgICB7T2JqZWN0fSBvcHRpb25zIFRoZSByZXF1ZXN0IG9wdGlvbnMuXG4gICAqIEByZXR1cm4gICB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNhZmUgICAgVGhlIHJlc3VsdGluZyBzYWZlIG9wdGlvbi5cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9ICBidWNrZXQgIFRoZSByZXN1bHRpbmcgYnVja2V0IG5hbWUgb3B0aW9uLlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gIGhlYWRlcnMgVGhlIGV4dGVuZGVkIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICovXG4gIF9nZXRSZXF1ZXN0T3B0aW9ucyhvcHRpb25zPXt9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuZGVmYXVsdFJlcU9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYmF0Y2g6IHRoaXMuX2lzQmF0Y2gsXG4gICAgICAvLyBOb3RlOiBoZWFkZXJzIHNob3VsZCBuZXZlciBiZSBvdmVycmlkZW4gYnV0IGV4dGVuZGVkXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLnRoaXMuZGVmYXVsdFJlcU9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHNlcnZlciBpbmZvcm1hdGlvbiBhbmQgcGVyc2lzdCB0aGVtIGxvY2FsbHkuIFRoaXMgb3BlcmF0aW9uIGlzXG4gICAqIHVzdWFsbHkgcGVyZm9ybWVkIGEgc2luZ2xlIHRpbWUgZHVyaW5nIHRoZSBpbnN0YW5jZSBsaWZlY3ljbGUuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG9wdGlvbnMgVGhlIHJlcXVlc3Qgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGZldGNoU2VydmVySW5mbyhvcHRpb25zPXt9KSB7XG4gICAgaWYgKHRoaXMuc2VydmVySW5mbykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnNlcnZlckluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5odHRwLnJlcXVlc3QodGhpcy5yZW1vdGUgKyBlbmRwb2ludChcInJvb3RcIiksIHtcbiAgICAgIGhlYWRlcnM6IHsuLi50aGlzLmRlZmF1bHRSZXFPcHRpb25zLmhlYWRlcnMsIC4uLm9wdGlvbnMuaGVhZGVyc31cbiAgICB9KVxuICAgICAgLnRoZW4oKHtqc29ufSkgPT4ge1xuICAgICAgICB0aGlzLnNlcnZlckluZm8gPSBqc29uO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJJbmZvO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIEtpbnRvIHNlcnZlciBzZXR0aW5ncy5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIEBub2JhdGNoKFwiVGhpcyBvcGVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCB3aXRoaW4gYSBiYXRjaCBvcGVyYXRpb24uXCIpXG4gIGZldGNoU2VydmVyU2V0dGluZ3Mob3B0aW9ucz17fSkge1xuICAgIHJldHVybiB0aGlzLmZldGNoU2VydmVySW5mbyhvcHRpb25zKS50aGVuKCh7c2V0dGluZ3N9KSA9PiBzZXR0aW5ncyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgc2VydmVyIGNhcGFiaWxpdGllcyBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIEBub2JhdGNoKFwiVGhpcyBvcGVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCB3aXRoaW4gYSBiYXRjaCBvcGVyYXRpb24uXCIpXG4gIGZldGNoU2VydmVyQ2FwYWJpbGl0aWVzKG9wdGlvbnM9e30pIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaFNlcnZlckluZm8ob3B0aW9ucykudGhlbigoe2NhcGFiaWxpdGllc30pID0+IGNhcGFiaWxpdGllcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYXV0aGVudGljYXRlZCB1c2VyIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgQG5vYmF0Y2goXCJUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhpbiBhIGJhdGNoIG9wZXJhdGlvbi5cIilcbiAgZmV0Y2hVc2VyKG9wdGlvbnM9e30pIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaFNlcnZlckluZm8ob3B0aW9ucykudGhlbigoe3VzZXJ9KSA9PiB1c2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhdXRoZW50aWNhdGVkIHVzZXIgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBAbm9iYXRjaChcIlRoaXMgb3BlcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aGluIGEgYmF0Y2ggb3BlcmF0aW9uLlwiKVxuICBmZXRjaEhUVFBBcGlWZXJzaW9uKG9wdGlvbnM9e30pIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaFNlcnZlckluZm8ob3B0aW9ucykudGhlbigoe2h0dHBfYXBpX3ZlcnNpb259KSA9PiB7XG4gICAgICByZXR1cm4gaHR0cF9hcGlfdmVyc2lvbjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGJhdGNoIHJlcXVlc3RzLCBjaHVua2luZyB0aGVtIGFjY29yZGluZyB0byB0aGUgYmF0Y2hfbWF4X3JlcXVlc3RzXG4gICAqIHNlcnZlciBzZXR0aW5nIHdoZW4gbmVlZGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtBcnJheX0gIHJlcXVlc3RzIFRoZSBsaXN0IG9mIGJhdGNoIHN1YnJlcXVlc3RzIHRvIHBlcmZvcm0uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgX2JhdGNoUmVxdWVzdHMocmVxdWVzdHMsIG9wdGlvbnM9e30pIHtcbiAgICBjb25zdCBoZWFkZXJzID0gey4uLnRoaXMuZGVmYXVsdFJlcU9wdGlvbnMuaGVhZGVycywgLi4ub3B0aW9ucy5oZWFkZXJzfTtcbiAgICBpZiAoIXJlcXVlc3RzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZldGNoU2VydmVyU2V0dGluZ3MoKVxuICAgICAgLnRoZW4oc2VydmVyU2V0dGluZ3MgPT4ge1xuICAgICAgICBjb25zdCBtYXhSZXF1ZXN0cyA9IHNlcnZlclNldHRpbmdzW1wiYmF0Y2hfbWF4X3JlcXVlc3RzXCJdO1xuICAgICAgICBpZiAobWF4UmVxdWVzdHMgJiYgcmVxdWVzdHMubGVuZ3RoID4gbWF4UmVxdWVzdHMpIHtcbiAgICAgICAgICBjb25zdCBjaHVua3MgPSBwYXJ0aXRpb24ocmVxdWVzdHMsIG1heFJlcXVlc3RzKTtcbiAgICAgICAgICByZXR1cm4gcE1hcChjaHVua3MsIGNodW5rID0+IHRoaXMuX2JhdGNoUmVxdWVzdHMoY2h1bmssIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlKHtcbiAgICAgICAgICBwYXRoOiBlbmRwb2ludChcImJhdGNoXCIpLFxuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBkZWZhdWx0czoge2hlYWRlcnN9LFxuICAgICAgICAgICAgcmVxdWVzdHM6IHJlcXVlc3RzXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgIC8vIHdlIG9ubHkgY2FyZSBhYm91dCB0aGUgcmVzcG9uc2VzXG4gICAgICAgICAgLnRoZW4oKHtyZXNwb25zZXN9KSA9PiByZXNwb25zZXMpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYmF0Y2ggcmVxdWVzdHMgdG8gdGhlIHJlbW90ZSBzZXJ2ZXIuXG4gICAqXG4gICAqIE5vdGU6IFJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICpcbiAgICogQGlnbm9yZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgICBUaGUgZnVuY3Rpb24gdG8gdXNlIGZvciBkZXNjcmliaW5nIGJhdGNoIG9wcy5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIG9wdGlvbnMgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgb3B0aW9ucy5zYWZlICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgb3B0aW9ucy5idWNrZXQgICAgVGhlIGJ1Y2tldCBuYW1lIG9wdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIG9wdGlvbnMuaGVhZGVycyAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBvcHRpb25zLmFnZ3JlZ2F0ZSBQcm9kdWNlcyBhbiBhZ2dyZWdhdGVkIHJlc3VsdCBvYmplY3RcbiAgICogKGRlZmF1bHQ6IGBmYWxzZWApLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgQG5vYmF0Y2goXCJDYW4ndCB1c2UgYmF0Y2ggd2l0aGluIGEgYmF0Y2ghXCIpXG4gIGJhdGNoKGZuLCBvcHRpb25zPXt9KSB7XG4gICAgY29uc3Qgcm9vdEJhdGNoID0gbmV3IEtpbnRvQ2xpZW50QmFzZSh0aGlzLnJlbW90ZSwge1xuICAgICAgLi4udGhpcy5fb3B0aW9ucyxcbiAgICAgIC4uLnRoaXMuX2dldFJlcXVlc3RPcHRpb25zKG9wdGlvbnMpLFxuICAgICAgYmF0Y2g6IHRydWVcbiAgICB9KTtcbiAgICBsZXQgYnVja2V0QmF0Y2gsIGNvbGxCYXRjaDtcbiAgICBpZiAob3B0aW9ucy5idWNrZXQpIHtcbiAgICAgIGJ1Y2tldEJhdGNoID0gcm9vdEJhdGNoLmJ1Y2tldChvcHRpb25zLmJ1Y2tldCk7XG4gICAgICBpZiAob3B0aW9ucy5jb2xsZWN0aW9uKSB7XG4gICAgICAgIGNvbGxCYXRjaCA9IGJ1Y2tldEJhdGNoLmNvbGxlY3Rpb24ob3B0aW9ucy5jb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYmF0Y2hDbGllbnQgPSBjb2xsQmF0Y2ggfHwgYnVja2V0QmF0Y2ggfHwgcm9vdEJhdGNoO1xuICAgIHRyeSB7XG4gICAgICBmbihiYXRjaENsaWVudCk7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYmF0Y2hSZXF1ZXN0cyhyb290QmF0Y2guX3JlcXVlc3RzLCBvcHRpb25zKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlcykgPT4ge1xuICAgICAgICBpZiAob3B0aW9ucy5hZ2dyZWdhdGUpIHtcbiAgICAgICAgICByZXR1cm4gYWdncmVnYXRlKHJlc3BvbnNlcywgcm9vdEJhdGNoLl9yZXF1ZXN0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlcztcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGFuIGF0b21pYyBIVFRQIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gIHJlcXVlc3QgICAgIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb3B0aW9ucyAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLnJhdyBSZXNvbHZlIHdpdGggZnVsbCByZXNwb25zZSBvYmplY3QsIGluY2x1ZGluZ1xuICAgKiBqc29uIGJvZHkgYW5kIGhlYWRlcnMgKERlZmF1bHQ6IGBmYWxzZWAsIHNvIG9ubHkgdGhlIGpzb24gYm9keSBpc1xuICAgKiByZXRyaWV2ZWQpLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgZXhlY3V0ZShyZXF1ZXN0LCBvcHRpb25zPXtyYXc6IGZhbHNlfSkge1xuICAgIC8vIElmIHdlJ3JlIHdpdGhpbiBhIGJhdGNoLCBhZGQgdGhlIHJlcXVlc3QgdG8gdGhlIHN0YWNrIHRvIHNlbmQgYXQgb25jZS5cbiAgICBpZiAodGhpcy5faXNCYXRjaCkge1xuICAgICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICAgIC8vIFJlc29sdmUgd2l0aCBhIG1lc3NhZ2UgaW4gY2FzZSBwZW9wbGUgYXR0ZW1wdCBhdCBjb25zdW1pbmcgdGhlIHJlc3VsdFxuICAgICAgLy8gZnJvbSB3aXRoaW4gYSBiYXRjaCBvcGVyYXRpb24uXG4gICAgICBjb25zdCBtc2cgPSBcIlRoaXMgcmVzdWx0IGlzIGdlbmVyYXRlZCBmcm9tIHdpdGhpbiBhIGJhdGNoIFwiICtcbiAgICAgICAgICAgICAgICAgIFwib3BlcmF0aW9uIGFuZCBzaG91bGQgbm90IGJlIGNvbnN1bWVkLlwiO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvcHRpb25zLnJhdyA/IHtqc29uOiBtc2d9IDogbXNnKTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuZmV0Y2hTZXJ2ZXJTZXR0aW5ncygpXG4gICAgICAudGhlbihfID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cC5yZXF1ZXN0KHRoaXMucmVtb3RlICsgcmVxdWVzdC5wYXRoLCB7XG4gICAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LmJvZHkpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIG9wdGlvbnMucmF3ID8gcHJvbWlzZSA6IHByb21pc2UudGhlbigoe2pzb259KSA9PiBqc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgYnVja2V0cy5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMuaGVhZGVycyBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdFtdLCBFcnJvcj59XG4gICAqL1xuICBsaXN0QnVja2V0cyhvcHRpb25zPXt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZSh7XG4gICAgICBwYXRoOiBlbmRwb2ludChcImJ1Y2tldFwiKSxcbiAgICAgIGhlYWRlcnM6IHsuLi50aGlzLmRlZmF1bHRSZXFPcHRpb25zLmhlYWRlcnMsIC4uLm9wdGlvbnMuaGVhZGVyc31cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGJ1Y2tldCBvbiB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgaWQgICAgICAgICAgICAgIFRoZSBidWNrZXQgbmFtZS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIG9wdGlvbnMgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBvcHRpb25zLmRhdGEgICAgVGhlIGJ1Y2tldCBkYXRhIG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gIG9wdGlvbnMuc2FmZSAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBvcHRpb25zLmhlYWRlcnMgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGNyZWF0ZUJ1Y2tldChpZCwgb3B0aW9ucz17fSkge1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgYnVja2V0IGlkIGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgLy8gTm90ZSB0aGF0IHdlIHNpbXBseSBpZ25vcmUgYW55IFwiYnVja2V0XCIgb3B0aW9uIHBhc3NlZCBoZXJlLCBhcyB0aGUgb25lXG4gICAgLy8gd2UncmUgaW50ZXJlc3RlZCBpbiBpcyB0aGUgb25lIHByb3ZpZGVkIGFzIGEgcmVxdWlyZWQgYXJndW1lbnQuXG4gICAgY29uc3QgcmVxT3B0aW9ucyA9IHRoaXMuX2dldFJlcXVlc3RPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHsgZGF0YT17fSwgcGVybWlzc2lvbnMgfSA9IHJlcU9wdGlvbnM7XG4gICAgZGF0YS5pZCA9IGlkO1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImJ1Y2tldFwiLCBpZCk7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShyZXF1ZXN0cy5jcmVhdGVSZXF1ZXN0KHBhdGgsIHsgZGF0YSwgcGVybWlzc2lvbnMgfSwgcmVxT3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBidWNrZXQgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAaWdub3JlXG4gICAqIEBwYXJhbSAge09iamVjdHxTdHJpbmd9IGJ1Y2tldCAgICAgICAgICBUaGUgYnVja2V0IHRvIGRlbGV0ZS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgb3B0aW9ucyAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgb3B0aW9ucy5zYWZlICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgb3B0aW9ucy5oZWFkZXJzIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBkZWxldGVCdWNrZXQoYnVja2V0LCBvcHRpb25zPXt9KSB7XG4gICAgY29uc3QgYnVja2V0T2JqID0gdG9EYXRhQm9keShidWNrZXQpO1xuICAgIGlmICghYnVja2V0T2JqLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGJ1Y2tldCBpZCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImJ1Y2tldFwiLCBidWNrZXRPYmouaWQpO1xuICAgIGNvbnN0IHsgbGFzdF9tb2RpZmllZCB9ID0geyBidWNrZXRPYmogfTtcbiAgICBjb25zdCByZXFPcHRpb25zID0gdGhpcy5fZ2V0UmVxdWVzdE9wdGlvbnMoeyBsYXN0X21vZGlmaWVkLCAuLi5vcHRpb25zIH0pO1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGUocmVxdWVzdHMuZGVsZXRlUmVxdWVzdChwYXRoLCByZXFPcHRpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgYnVja2V0cyBvbiB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAaWdub3JlXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG9wdGlvbnMgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdGlvbnMuc2FmZSAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG9wdGlvbnMuaGVhZGVycyBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgQHN1cHBvcnQoXCIxLjRcIiwgXCIyLjBcIilcbiAgZGVsZXRlQnVja2V0cyhvcHRpb25zPXt9KSB7XG4gICAgY29uc3QgcmVxT3B0aW9ucyA9IHRoaXMuX2dldFJlcXVlc3RPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImJ1Y2tldFwiKTtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRlKHJlcXVlc3RzLmRlbGV0ZVJlcXVlc3QocGF0aCwgcmVxT3B0aW9ucykpO1xuICB9XG59XG4iLCIvKipcbiAqIEV4cG9ydHMgYmF0Y2ggcmVzcG9uc2VzIGFzIGEgcmVzdWx0IG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7QXJyYXl9IHJlc3BvbnNlcyBUaGUgYmF0Y2ggc3VicmVxdWVzdCByZXNwb25zZXMuXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVxdWVzdHMgIFRoZSBpbml0aWFsIGlzc3VlZCByZXF1ZXN0cy5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFnZ3JlZ2F0ZShyZXNwb25zZXM9W10sIHJlcXVlc3RzPVtdKSB7XG4gIGlmIChyZXNwb25zZXMubGVuZ3RoICE9PSByZXF1ZXN0cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZXMgbGVuZ3RoIHNob3VsZCBtYXRjaCByZXF1ZXN0cyBvbmUuXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdHMgPSB7XG4gICAgZXJyb3JzOiAgICBbXSxcbiAgICBwdWJsaXNoZWQ6IFtdLFxuICAgIGNvbmZsaWN0czogW10sXG4gICAgc2tpcHBlZDogICBbXSxcbiAgfTtcbiAgcmV0dXJuIHJlc3BvbnNlcy5yZWR1Y2UoKGFjYywgcmVzcG9uc2UsIGluZGV4KSA9PiB7XG4gICAgY29uc3Qge3N0YXR1c30gPSByZXNwb25zZTtcbiAgICBpZiAoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCA0MDApIHtcbiAgICAgIGFjYy5wdWJsaXNoZWQucHVzaChyZXNwb25zZS5ib2R5KTtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICBhY2Muc2tpcHBlZC5wdXNoKHJlc3BvbnNlLmJvZHkpO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MTIpIHtcbiAgICAgIGFjYy5jb25mbGljdHMucHVzaCh7XG4gICAgICAgIC8vIFhYWDogc3BlY2lmeWluZyB0aGUgdHlwZSBpcyBwcm9iYWJseSBzdXBlcmZsdW91c1xuICAgICAgICB0eXBlOiBcIm91dGdvaW5nXCIsXG4gICAgICAgIGxvY2FsOiByZXF1ZXN0c1tpbmRleF0uYm9keSxcbiAgICAgICAgcmVtb3RlOiByZXNwb25zZS5ib2R5LmRldGFpbHMgJiZcbiAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5LmRldGFpbHMuZXhpc3RpbmcgfHwgbnVsbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjYy5lcnJvcnMucHVzaCh7XG4gICAgICAgIHBhdGg6IHJlc3BvbnNlLnBhdGgsXG4gICAgICAgIHNlbnQ6IHJlcXVlc3RzW2luZGV4XSxcbiAgICAgICAgZXJyb3I6IHJlc3BvbnNlLmJvZHlcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCByZXN1bHRzKTtcbn1cbiIsImltcG9ydCB7IHRvRGF0YUJvZHksIGlzT2JqZWN0IH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gXCIuL2NvbGxlY3Rpb25cIjtcbmltcG9ydCAqIGFzIHJlcXVlc3RzIGZyb20gXCIuL3JlcXVlc3RzXCI7XG5pbXBvcnQgZW5kcG9pbnQgZnJvbSBcIi4vZW5kcG9pbnRcIjtcblxuXG4vKipcbiAqIEFic3RyYWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgc2VsZWN0ZWQgYnVja2V0LlxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnVja2V0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gIHtLaW50b0NsaWVudH0gY2xpZW50ICAgICAgICAgIFRoZSBjbGllbnQgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICAgICBuYW1lICAgICAgICAgICAgVGhlIGJ1Y2tldCBuYW1lLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgb3B0aW9ucy5oZWFkZXJzIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICBvcHRpb25zLnNhZmUgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50LCBuYW1lLCBvcHRpb25zPXt9KSB7XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIC8qKlxuICAgICAqIFRoZSBidWNrZXQgbmFtZS5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQGlnbm9yZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5faXNCYXRjaCA9ICEhb3B0aW9ucy5iYXRjaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZXMgcGFzc2VkIHJlcXVlc3Qgb3B0aW9ucyB3aXRoIGRlZmF1bHQgYnVja2V0IG9uZXMsIGlmIGFueS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHRvIG1lcmdlLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgVGhlIG1lcmdlZCBvcHRpb25zLlxuICAgKi9cbiAgX2J1Y2tldE9wdGlvbnMob3B0aW9ucz17fSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJ1Y2tldDogdGhpcy5uYW1lLFxuICAgICAgYmF0Y2g6IHRoaXMuX2lzQmF0Y2hcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgYSBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgICAgICAgICAgICBUaGUgY29sbGVjdGlvbiBuYW1lLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucy5oZWFkZXJzIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBvcHRpb25zLnNhZmUgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbn1cbiAgICovXG4gIGNvbGxlY3Rpb24obmFtZSwgb3B0aW9ucz17fSkge1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLmNsaWVudCwgdGhpcywgbmFtZSwgdGhpcy5fYnVja2V0T3B0aW9ucyhvcHRpb25zKSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYnVja2V0IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zLmhlYWRlcnMgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGdldERhdGEob3B0aW9ucz17fSkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHtcbiAgICAgIHBhdGg6IGVuZHBvaW50KFwiYnVja2V0XCIsIHRoaXMubmFtZSksXG4gICAgICBoZWFkZXJzOiB7Li4udGhpcy5vcHRpb25zLmhlYWRlcnMsIC4uLm9wdGlvbnMuaGVhZGVyc31cbiAgICB9KVxuICAgIC50aGVuKChyZXMpID0+IHJlcy5kYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYnVja2V0IGRhdGEuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBkYXRhICAgICAgICAgICAgVGhlIGJ1Y2tldCBkYXRhIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIG9wdGlvbnMgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBvcHRpb25zLmhlYWRlcnMgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gIG9wdGlvbnMuc2FmZSAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBvcHRpb25zLnBhdGNoICAgVGhlIHBhdGNoIG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIHNldERhdGEoZGF0YSwgb3B0aW9ucz17fSkge1xuICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgYnVja2V0IG9iamVjdCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuXG4gICAgY29uc3QgYnVja2V0ID0gey4uLmRhdGEsIGlkOiB0aGlzLm5hbWV9O1xuXG4gICAgLy8gRm9yIGRlZmF1bHQgYnVja2V0LCB3ZSBuZWVkIHRvIGRyb3AgdGhlIGlkIGZyb20gdGhlIGRhdGEgb2JqZWN0LlxuICAgIC8vIEJ1ZyBpbiBLaW50byA8IDMuMS4xXG4gICAgY29uc3QgYnVja2V0SWQgPSBidWNrZXQuaWQ7XG4gICAgaWYgKGJ1Y2tldC5pZCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgIGRlbGV0ZSBidWNrZXQuaWQ7XG4gICAgfVxuXG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiYnVja2V0XCIsIGJ1Y2tldElkKTtcbiAgICBjb25zdCB7IHBlcm1pc3Npb25zIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJlcU9wdGlvbnMgPSB7Li4udGhpcy5fYnVja2V0T3B0aW9ucyhvcHRpb25zKX07XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzLnVwZGF0ZVJlcXVlc3QocGF0aCwge2RhdGE6IGJ1Y2tldCwgcGVybWlzc2lvbnN9LCByZXFPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgY29sbGVjdGlvbnMgaW4gdGhlIGN1cnJlbnQgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucy5oZWFkZXJzIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8T2JqZWN0PiwgRXJyb3I+fVxuICAgKi9cbiAgbGlzdENvbGxlY3Rpb25zKG9wdGlvbnM9e30pIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZSh7XG4gICAgICBwYXRoOiBlbmRwb2ludChcImNvbGxlY3Rpb25cIiwgdGhpcy5uYW1lKSxcbiAgICAgIGhlYWRlcnM6IHsuLi50aGlzLm9wdGlvbnMuaGVhZGVycywgLi4ub3B0aW9ucy5oZWFkZXJzfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29sbGVjdGlvbiBpbiBjdXJyZW50IGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfHVuZGVmaW5lZH0gIGlkICAgICAgICBUaGUgY29sbGVjdGlvbiBpZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb3B0aW9ucyAgICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdGlvbnMuc2FmZSAgICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvcHRpb25zLmhlYWRlcnMgICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG9wdGlvbnMucGVybWlzc2lvbnMgVGhlIHBlcm1pc3Npb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb3B0aW9ucy5kYXRhICAgICAgICBUaGUgZGF0YSBvYmplY3QuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBjcmVhdGVDb2xsZWN0aW9uKGlkLCBvcHRpb25zPXt9KSB7XG4gICAgY29uc3QgcmVxT3B0aW9ucyA9IHRoaXMuX2J1Y2tldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgeyBwZXJtaXNzaW9ucywgZGF0YT17fSB9ID0gcmVxT3B0aW9ucztcbiAgICBkYXRhLmlkID0gaWQ7XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiY29sbGVjdGlvblwiLCB0aGlzLm5hbWUsIGlkKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMuY3JlYXRlUmVxdWVzdChwYXRoLCB7ZGF0YSwgcGVybWlzc2lvbnN9LCByZXFPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgY29sbGVjdGlvbiBmcm9tIHRoZSBjdXJyZW50IGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiAgVGhlIGNvbGxlY3Rpb24gdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgIG9wdGlvbnMgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgb3B0aW9ucy5oZWFkZXJzIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICAgb3B0aW9ucy5zYWZlICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGRlbGV0ZUNvbGxlY3Rpb24oY29sbGVjdGlvbiwgb3B0aW9ucz17fSkge1xuICAgIGNvbnN0IGNvbGxlY3Rpb25PYmogPSB0b0RhdGFCb2R5KGNvbGxlY3Rpb24pO1xuICAgIGlmICghY29sbGVjdGlvbk9iai5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBjb2xsZWN0aW9uIGlkIGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgY29uc3Qge2lkLCBsYXN0X21vZGlmaWVkfSA9IGNvbGxlY3Rpb25PYmo7XG4gICAgY29uc3QgcmVxT3B0aW9ucyA9IHRoaXMuX2J1Y2tldE9wdGlvbnMoeyBsYXN0X21vZGlmaWVkLCAuLi5vcHRpb25zIH0pO1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImNvbGxlY3Rpb25cIiwgdGhpcy5uYW1lLCBpZCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzLmRlbGV0ZVJlcXVlc3QocGF0aCwgcmVxT3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIGdyb3VwcyBpbiB0aGUgY3VycmVudCBidWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zLmhlYWRlcnMgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxPYmplY3Q+LCBFcnJvcj59XG4gICAqL1xuICBsaXN0R3JvdXBzKG9wdGlvbnM9e30pIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZSh7XG4gICAgICBwYXRoOiBlbmRwb2ludChcImdyb3VwXCIsIHRoaXMubmFtZSksXG4gICAgICBoZWFkZXJzOiB7Li4udGhpcy5vcHRpb25zLmhlYWRlcnMsIC4uLm9wdGlvbnMuaGVhZGVyc31cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGdyb3VwIGluIGN1cnJlbnQgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBpZCAgICAgICAgICAgICAgICAgIFRoZSBncm91cCBpZC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb3B0aW9ucyAgICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBnZXRHcm91cChpZCwgb3B0aW9ucz17fSkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHtcbiAgICAgIHBhdGg6IGVuZHBvaW50KFwiZ3JvdXBcIiwgdGhpcy5uYW1lLCBpZCksXG4gICAgICBoZWFkZXJzOiB7Li4udGhpcy5vcHRpb25zLmhlYWRlcnMsIC4uLm9wdGlvbnMuaGVhZGVyc31cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGdyb3VwIGluIGN1cnJlbnQgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd8dW5kZWZpbmVkfSAgaWQgICAgICAgIFRoZSBncm91cCBpZC5cbiAgICogQHBhcmFtICB7QXJyYXk8U3RyaW5nPn0gICAgIG1lbWJlcnMgICBUaGUgbGlzdCBvZiBwcmluY2lwYWxzLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvcHRpb25zICAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb3B0aW9ucy5kYXRhICAgICAgICBUaGUgZGF0YSBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG9wdGlvbnMucGVybWlzc2lvbnMgVGhlIHBlcm1pc3Npb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5zYWZlICAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG9wdGlvbnMuaGVhZGVycyAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGNyZWF0ZUdyb3VwKGlkLCBtZW1iZXJzPVtdLCBvcHRpb25zPXt9KSB7XG4gICAgY29uc3QgcmVxT3B0aW9ucyA9IHRoaXMuX2J1Y2tldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIC4uLm9wdGlvbnMuZGF0YSxcbiAgICAgIGlkLFxuICAgICAgbWVtYmVyc1xuICAgIH07XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiZ3JvdXBcIiwgdGhpcy5uYW1lLCBpZCk7XG4gICAgY29uc3Qge3Blcm1pc3Npb25zfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzLmNyZWF0ZVJlcXVlc3QocGF0aCwge2RhdGEsIHBlcm1pc3Npb25zfSwgcmVxT3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhbiBleGlzdGluZyBncm91cCBpbiBjdXJyZW50IGJ1Y2tldC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgZ3JvdXAgICAgICAgICAgICAgICBUaGUgZ3JvdXAgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvcHRpb25zICAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb3B0aW9ucy5kYXRhICAgICAgICBUaGUgZGF0YSBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG9wdGlvbnMucGVybWlzc2lvbnMgVGhlIHBlcm1pc3Npb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5zYWZlICAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG9wdGlvbnMuaGVhZGVycyAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIHVwZGF0ZUdyb3VwKGdyb3VwLCBvcHRpb25zPXt9KSB7XG4gICAgaWYgKCFpc09iamVjdChncm91cCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgZ3JvdXAgb2JqZWN0IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFncm91cC5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBncm91cCBpZCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHJlcU9wdGlvbnMgPSB0aGlzLl9idWNrZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAuLi5vcHRpb25zLmRhdGEsXG4gICAgICAuLi5ncm91cFxuICAgIH07XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiZ3JvdXBcIiwgdGhpcy5uYW1lLCBncm91cC5pZCk7XG4gICAgY29uc3Qge3Blcm1pc3Npb25zfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzLnVwZGF0ZVJlcXVlc3QocGF0aCwge2RhdGEsIHBlcm1pc3Npb25zfSwgcmVxT3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIGdyb3VwIGZyb20gdGhlIGN1cnJlbnQgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R8U3RyaW5nfSBncm91cCAgICAgICBUaGUgZ3JvdXAgdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgIG9wdGlvbnMgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgb3B0aW9ucy5oZWFkZXJzIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICAgb3B0aW9ucy5zYWZlICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGRlbGV0ZUdyb3VwKGdyb3VwLCBvcHRpb25zPXt9KSB7XG4gICAgY29uc3QgZ3JvdXBPYmogPSB0b0RhdGFCb2R5KGdyb3VwKTtcbiAgICBjb25zdCB7aWQsIGxhc3RfbW9kaWZpZWR9ID0gZ3JvdXBPYmo7XG4gICAgY29uc3QgcmVxT3B0aW9ucyA9IHRoaXMuX2J1Y2tldE9wdGlvbnMoe2xhc3RfbW9kaWZpZWQsIC4uLm9wdGlvbnN9KTtcbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJncm91cFwiLCB0aGlzLm5hbWUsIGlkKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMuZGVsZXRlUmVxdWVzdChwYXRoLCByZXFPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgcGVybWlzc2lvbnMgZm9yIHRoaXMgYnVja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucy5oZWFkZXJzIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBnZXRQZXJtaXNzaW9ucyhvcHRpb25zPXt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUoe1xuICAgICAgcGF0aDogZW5kcG9pbnQoXCJidWNrZXRcIiwgdGhpcy5uYW1lKSxcbiAgICAgIGhlYWRlcnM6IHsuLi50aGlzLm9wdGlvbnMuaGVhZGVycywgLi4ub3B0aW9ucy5oZWFkZXJzfVxuICAgIH0pXG4gICAgLnRoZW4oKHJlcykgPT4gcmVzLnBlcm1pc3Npb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNwbGFjZXMgYWxsIGV4aXN0aW5nIGJ1Y2tldCBwZXJtaXNzaW9ucyB3aXRoIHRoZSBvbmVzIHByb3ZpZGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBwZXJtaXNzaW9ucyAgICAgICAgICAgVGhlIHBlcm1pc3Npb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb3B0aW9ucyAgICAgICAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvcHRpb25zICAgICAgICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLnNhZmUgICAgICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvcHRpb25zLmhlYWRlcnMgICAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb3B0aW9ucy5sYXN0X21vZGlmaWVkIFRoZSBsYXN0X21vZGlmaWVkIG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIHNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zLCBvcHRpb25zPXt9KSB7XG4gICAgaWYgKCFpc09iamVjdChwZXJtaXNzaW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgcGVybWlzc2lvbnMgb2JqZWN0IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGVuZHBvaW50KFwiYnVja2V0XCIsIHRoaXMubmFtZSk7XG4gICAgY29uc3QgcmVxT3B0aW9ucyA9IHsuLi50aGlzLl9idWNrZXRPcHRpb25zKG9wdGlvbnMpfTtcbiAgICBjb25zdCB7bGFzdF9tb2RpZmllZH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGRhdGEgPSB7bGFzdF9tb2RpZmllZH07XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzLnVwZGF0ZVJlcXVlc3QocGF0aCwge2RhdGEsIHBlcm1pc3Npb25zfSwgcmVxT3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYmF0Y2ggb3BlcmF0aW9ucyBhdCB0aGUgY3VycmVudCBidWNrZXQgbGV2ZWwuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICAgICAgICAgICAgICAgVGhlIGJhdGNoIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIG9wdGlvbnMgICAgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBvcHRpb25zLmhlYWRlcnMgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gIG9wdGlvbnMuc2FmZSAgICAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBvcHRpb25zLmFnZ3JlZ2F0ZSAgUHJvZHVjZXMgYSBncm91cGVkIHJlc3VsdCBvYmplY3QuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBiYXRjaChmbiwgb3B0aW9ucz17fSkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5iYXRjaChmbiwgdGhpcy5fYnVja2V0T3B0aW9ucyhvcHRpb25zKSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IHRvRGF0YUJvZHksIHFzaWZ5LCBpc09iamVjdCB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgKiBhcyByZXF1ZXN0cyBmcm9tIFwiLi9yZXF1ZXN0c1wiO1xuaW1wb3J0IGVuZHBvaW50IGZyb20gXCIuL2VuZHBvaW50XCI7XG5cblxuLyoqXG4gKiBBYnN0cmFjdCByZXByZXNlbnRhdGlvbiBvZiBhIHNlbGVjdGVkIGNvbGxlY3Rpb24uXG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xsZWN0aW9uIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gIHtLaW50b0NsaWVudH0gIGNsaWVudCAgICAgICAgICBUaGUgY2xpZW50IGluc3RhbmNlLlxuICAgKiBAcGFyYW0gIHtCdWNrZXR9ICAgICAgIGJ1Y2tldCAgICAgICAgICBUaGUgYnVja2V0IGluc3RhbmNlLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIG5hbWUgICAgICAgICAgICBUaGUgY29sbGVjdGlvbiBuYW1lLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIG9wdGlvbnMuaGVhZGVycyBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgICAgIG9wdGlvbnMuc2FmZSAgICBUaGUgc2FmZSBvcHRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGJ1Y2tldCwgbmFtZSwgb3B0aW9ucz17fSkge1xuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5idWNrZXQgPSBidWNrZXQ7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbGxlY3Rpb24gbmFtZS5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBjb2xsZWN0aW9uIG9wdGlvbnMgb2JqZWN0LCBlbWJlZGRpbmcgdGhlIGRlZmF1bHQgYnVja2V0IG9uZXMuXG4gICAgICogQGlnbm9yZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgLi4udGhpcy5idWNrZXQub3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLnRoaXMuYnVja2V0Lm9wdGlvbnMgJiYgdGhpcy5idWNrZXQub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9pc0JhdGNoID0gISFvcHRpb25zLmJhdGNoO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlcyBwYXNzZWQgcmVxdWVzdCBvcHRpb25zIHdpdGggZGVmYXVsdCBidWNrZXQgYW5kIGNvbGxlY3Rpb24gb25lcywgaWZcbiAgICogYW55LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgdG8gbWVyZ2UuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBUaGUgbWVyZ2VkIG9wdGlvbnMuXG4gICAqL1xuICBfY29sbE9wdGlvbnMob3B0aW9ucz17fSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGVhZGVycyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBjb2xsZWN0aW9uIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zLmhlYWRlcnMgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGdldERhdGEob3B0aW9ucz17fSkge1xuICAgIGNvbnN0IHsgaGVhZGVycyB9ID0gdGhpcy5fY29sbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUoe1xuICAgICAgcGF0aDogZW5kcG9pbnQoXCJjb2xsZWN0aW9uXCIsIHRoaXMuYnVja2V0Lm5hbWUsIHRoaXMubmFtZSksXG4gICAgICBoZWFkZXJzXG4gICAgfSlcbiAgICAudGhlbihyZXMgPT4gcmVzLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjb2xsZWN0aW9uIGRhdGEuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBkYXRhICAgICAgICAgICAgVGhlIGNvbGxlY3Rpb24gZGF0YSBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBvcHRpb25zICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgb3B0aW9ucy5oZWFkZXJzIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBvcHRpb25zLnNhZmUgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgb3B0aW9ucy5wYXRjaCAgIFRoZSBwYXRjaCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBzZXREYXRhKGRhdGEsIG9wdGlvbnM9e30pIHtcbiAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGNvbGxlY3Rpb24gb2JqZWN0IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVxT3B0aW9ucyA9IHRoaXMuX2NvbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHsgcGVybWlzc2lvbnMgfSA9IHJlcU9wdGlvbnM7XG5cbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJjb2xsZWN0aW9uXCIsIHRoaXMuYnVja2V0Lm5hbWUsIHRoaXMubmFtZSk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzLnVwZGF0ZVJlcXVlc3QocGF0aCwge2RhdGEsIHBlcm1pc3Npb25zfSwgcmVxT3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUocmVxdWVzdCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIHBlcm1pc3Npb25zIGZvciB0aGlzIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zLmhlYWRlcnMgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGdldFBlcm1pc3Npb25zKG9wdGlvbnM9e30pIHtcbiAgICBjb25zdCB7IGhlYWRlcnMgfSA9IHRoaXMuX2NvbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5leGVjdXRlKHtcbiAgICAgIHBhdGg6IGVuZHBvaW50KFwiY29sbGVjdGlvblwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUpLFxuICAgICAgaGVhZGVyc1xuICAgIH0pXG4gICAgLnRoZW4ocmVzID0+IHJlcy5wZXJtaXNzaW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIGV4aXN0aW5nIGNvbGxlY3Rpb24gcGVybWlzc2lvbnMgd2l0aCB0aGUgb25lcyBwcm92aWRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIHBlcm1pc3Npb25zICAgICBUaGUgcGVybWlzc2lvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgb3B0aW9ucyAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgb3B0aW9ucy5oZWFkZXJzIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBvcHRpb25zLnNhZmUgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgb3B0aW9ucy5sYXN0X21vZGlmaWVkIFRoZSBsYXN0X21vZGlmaWVkIG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIHNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zLCBvcHRpb25zPXt9KSB7XG4gICAgaWYgKCFpc09iamVjdChwZXJtaXNzaW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgcGVybWlzc2lvbnMgb2JqZWN0IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVxT3B0aW9ucyA9IHRoaXMuX2NvbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcImNvbGxlY3Rpb25cIiwgdGhpcy5idWNrZXQubmFtZSwgdGhpcy5uYW1lKTtcbiAgICBjb25zdCBkYXRhID0geyBsYXN0X21vZGlmaWVkOiBvcHRpb25zLmxhc3RfbW9kaWZpZWQgfTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMudXBkYXRlUmVxdWVzdChwYXRoLCB7ZGF0YSwgcGVybWlzc2lvbnN9LCByZXFPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVjb3JkIGluIGN1cnJlbnQgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSByZWNvcmQgICAgICAgICAgVGhlIHJlY29yZCB0byBjcmVhdGUuXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zLmhlYWRlcnMgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gIG9wdGlvbnMuc2FmZSAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgY3JlYXRlUmVjb3JkKHJlY29yZCwgb3B0aW9ucz17fSkge1xuICAgIGNvbnN0IHJlcU9wdGlvbnMgPSB0aGlzLl9jb2xsT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB7IHBlcm1pc3Npb25zIH0gPSByZXFPcHRpb25zO1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcInJlY29yZFwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUsIHJlY29yZC5pZCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzLmNyZWF0ZVJlcXVlc3QocGF0aCwge2RhdGE6IHJlY29yZCwgcGVybWlzc2lvbnN9LCByZXFPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgcmVjb3JkIGluIGN1cnJlbnQgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgcmVjb3JkICAgICAgICAgICAgICAgIFRoZSByZWNvcmQgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvcHRpb25zICAgICAgICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvcHRpb25zLmhlYWRlcnMgICAgICAgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5zYWZlICAgICAgICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgb3B0aW9ucy5sYXN0X21vZGlmaWVkIFRoZSBsYXN0X21vZGlmaWVkIG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIHVwZGF0ZVJlY29yZChyZWNvcmQsIG9wdGlvbnM9e30pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHJlY29yZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgcmVjb3JkIG9iamVjdCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGlmICghcmVjb3JkLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIHJlY29yZCBpZCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHJlcU9wdGlvbnMgPSB0aGlzLl9jb2xsT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB7IHBlcm1pc3Npb25zIH0gPSByZXFPcHRpb25zO1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcInJlY29yZFwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUsIHJlY29yZC5pZCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzLnVwZGF0ZVJlcXVlc3QocGF0aCwge2RhdGE6IHJlY29yZCwgcGVybWlzc2lvbnN9LCByZXFPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgcmVjb3JkIGZyb20gdGhlIGN1cnJlbnQgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fFN0cmluZ30gcmVjb3JkICAgICAgICAgIFRoZSByZWNvcmQgdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICBvcHRpb25zICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICBvcHRpb25zLmhlYWRlcnMgVGhlIGhlYWRlcnMgb2JqZWN0IG9wdGlvbi5cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgb3B0aW9ucy5zYWZlICAgIFRoZSBzYWZlIG9wdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgb3B0aW9ucy5sYXN0X21vZGlmaWVkIFRoZSBsYXN0X21vZGlmaWVkIG9wdGlvbi5cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn1cbiAgICovXG4gIGRlbGV0ZVJlY29yZChyZWNvcmQsIG9wdGlvbnM9e30pIHtcbiAgICBjb25zdCByZWNvcmRPYmogPSB0b0RhdGFCb2R5KHJlY29yZCk7XG4gICAgaWYgKCFyZWNvcmRPYmouaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgcmVjb3JkIGlkIGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgY29uc3Qge2lkLCBsYXN0X21vZGlmaWVkfSA9IHJlY29yZE9iajtcbiAgICBjb25zdCByZXFPcHRpb25zID0gdGhpcy5fY29sbE9wdGlvbnMoeyBsYXN0X21vZGlmaWVkLCAuLi5vcHRpb25zIH0pO1xuICAgIGNvbnN0IHBhdGggPSBlbmRwb2ludChcInJlY29yZFwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUsIGlkKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHMuZGVsZXRlUmVxdWVzdChwYXRoLCByZXFPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZShyZXF1ZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSByZWNvcmQgZnJvbSB0aGUgY3VycmVudCBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGlkICAgICAgICAgICAgICBUaGUgcmVjb3JkIGlkIHRvIHJldHJpZXZlLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucy5oZWFkZXJzIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59XG4gICAqL1xuICBnZXRSZWNvcmQoaWQsIG9wdGlvbnM9e30pIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuZXhlY3V0ZSh7XG4gICAgICBwYXRoOiBlbmRwb2ludChcInJlY29yZFwiLCB0aGlzLmJ1Y2tldC5uYW1lLCB0aGlzLm5hbWUsIGlkKSxcbiAgICAgIC4uLnRoaXMuX2NvbGxPcHRpb25zKG9wdGlvbnMpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RzIHJlY29yZHMgZnJvbSB0aGUgY3VycmVudCBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBTb3J0aW5nIGlzIGRvbmUgYnkgcGFzc2luZyBhIGBzb3J0YCBzdHJpbmcgb3B0aW9uOlxuICAgKlxuICAgKiAtIFRoZSBmaWVsZCB0byBvcmRlciB0aGUgcmVzdWx0cyBieSwgcHJlZml4ZWQgd2l0aCBgLWAgZm9yIGRlc2NlbmRpbmcuXG4gICAqIERlZmF1bHQ6IGAtbGFzdF9tb2RpZmllZGAuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL2tpbnRvLnJlYWR0aGVkb2NzLmlvL2VuL3N0YWJsZS9jb3JlL2FwaS9yZXNvdXJjZS5odG1sI3NvcnRpbmdcbiAgICpcbiAgICogRmlsdGVyaW5nIGlzIGRvbmUgYnkgcGFzc2luZyBhIGBmaWx0ZXJzYCBvcHRpb24gb2JqZWN0OlxuICAgKlxuICAgKiAtIGB7ZmllbGRuYW1lOiBcInZhbHVlXCJ9YFxuICAgKiAtIGB7bWluX2ZpZWxkbmFtZTogNDAwMH1gXG4gICAqIC0gYHtpbl9maWVsZG5hbWU6IFwiMSwyLDNcIn1gXG4gICAqIC0gYHtub3RfZmllbGRuYW1lOiAwfWBcbiAgICogLSBge2V4Y2x1ZGVfZmllbGRuYW1lOiBcIjAsMVwifWBcbiAgICpcbiAgICogQHNlZSBodHRwOi8va2ludG8ucmVhZHRoZWRvY3MuaW8vZW4vc3RhYmxlL2NvcmUvYXBpL3Jlc291cmNlLmh0bWwjZmlsdGVyaW5nXG4gICAqXG4gICAqIFBhZ2luYXRpbmcgaXMgZG9uZSBieSBwYXNzaW5nIGEgYGxpbWl0YCBvcHRpb24sIHRoZW4gY2FsbGluZyB0aGUgYG5leHQoKWBcbiAgICogbWV0aG9kIGZyb20gdGhlIHJlc29sdmVkIHJlc3VsdCBvYmplY3QgdG8gZmV0Y2ggdGhlIG5leHQgcGFnZSwgaWYgYW55LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgb3B0aW9ucyAgICAgICAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIG9wdGlvbnMuaGVhZGVycyBUaGUgaGVhZGVycyBvYmplY3Qgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgb3B0aW9ucy5maWx0ZXJzIFRoZSBmaWx0ZXJzIG9iamVjdC5cbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIG9wdGlvbnMuc29ydCAgICBUaGUgc29ydCBmaWVsZC5cbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIG9wdGlvbnMubGltaXQgICBUaGUgbGltaXQgZmllbGQuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICBvcHRpb25zLnBhZ2VzICAgVGhlIG51bWJlciBvZiByZXN1bHQgcGFnZXMgdG8gYWdncmVnYXRlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgb3B0aW9ucy5zaW5jZSAgIE9ubHkgcmV0cmlldmUgcmVjb3JkcyBtb2RpZmllZCBzaW5jZSB0aGVcbiAgICogcHJvdmlkZWQgdGltZXN0YW1wLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgbGlzdFJlY29yZHMob3B0aW9ucz17fSkge1xuICAgIGNvbnN0IHsgaHR0cCB9ID0gdGhpcy5jbGllbnQ7XG4gICAgY29uc3QgeyBzb3J0LCBmaWx0ZXJzLCBsaW1pdCwgcGFnZXMsIHNpbmNlIH0gPSB7XG4gICAgICBzb3J0OiBcIi1sYXN0X21vZGlmaWVkXCIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICAvLyBTYWZldHkvQ29uc2lzdGVuY3kgY2hlY2sgb24gRVRhZyB2YWx1ZS5cbiAgICBpZiAoc2luY2UgJiYgdHlwZW9mKHNpbmNlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciBzaW5jZSAoJHtzaW5jZX0pLCBzaG91bGQgYmUgRVRhZyB2YWx1ZS5gKTtcbiAgICB9XG4gICAgY29uc3QgY29sbEhlYWRlcnMgPSB0aGlzLm9wdGlvbnMuaGVhZGVycztcbiAgICBjb25zdCBwYXRoID0gZW5kcG9pbnQoXCJyZWNvcmRcIiwgdGhpcy5idWNrZXQubmFtZSwgdGhpcy5uYW1lKTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHFzaWZ5KHtcbiAgICAgIC4uLmZpbHRlcnMsXG4gICAgICBfc29ydDogc29ydCxcbiAgICAgIF9saW1pdDogbGltaXQsXG4gICAgICBfc2luY2U6IHNpbmNlLFxuICAgIH0pO1xuICAgIGxldCByZXN1bHRzID0gW10sIGN1cnJlbnQgPSAwO1xuXG4gICAgY29uc3QgbmV4dCA9IGZ1bmN0aW9uKG5leHRQYWdlKSB7XG4gICAgICBpZiAoIW5leHRQYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhZ2luYXRpb24gZXhoYXVzdGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9jZXNzTmV4dFBhZ2UobmV4dFBhZ2UpO1xuICAgIH07XG5cbiAgICBjb25zdCBwcm9jZXNzTmV4dFBhZ2UgPSAobmV4dFBhZ2UpID0+IHtcbiAgICAgIHJldHVybiBodHRwLnJlcXVlc3QobmV4dFBhZ2UsIHtoZWFkZXJzOiBjb2xsSGVhZGVyc30pXG4gICAgICAgIC50aGVuKGhhbmRsZVJlc3BvbnNlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcGFnZVJlc3VsdHMgPSAocmVzdWx0cywgbmV4dFBhZ2UsIGV0YWcpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhc3RfbW9kaWZpZWQ6IGV0YWcsXG4gICAgICAgIGRhdGE6IHJlc3VsdHMsXG4gICAgICAgIG5leHQ6IG5leHQuYmluZChudWxsLCBuZXh0UGFnZSlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gKHtoZWFkZXJzLCBqc29ufSkgPT4ge1xuICAgICAgY29uc3QgbmV4dFBhZ2UgPSBoZWFkZXJzLmdldChcIk5leHQtUGFnZVwiKTtcbiAgICAgIC8vIEVUYWcgYXJlIHN1cHBvc2VkIHRvIGJlIG9wYXF1ZSBhbmQgc3RvcmVkIMKrYXMtaXPCuy5cbiAgICAgIGNvbnN0IGV0YWcgPSBoZWFkZXJzLmdldChcIkVUYWdcIik7XG4gICAgICBpZiAoIXBhZ2VzKSB7XG4gICAgICAgIHJldHVybiBwYWdlUmVzdWx0cyhqc29uLmRhdGEsIG5leHRQYWdlLCBldGFnKTtcbiAgICAgIH1cbiAgICAgIC8vIEFnZ3JlZ2F0ZSBuZXcgcmVzdWx0cyB3aXRoIHByZXZpb3VzIG9uZXNcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChqc29uLmRhdGEpO1xuICAgICAgY3VycmVudCArPSAxO1xuICAgICAgaWYgKGN1cnJlbnQgPj0gcGFnZXMgfHwgIW5leHRQYWdlKSB7XG4gICAgICAgIC8vIFBhZ2luYXRpb24gZXhoYXVzdGVkXG4gICAgICAgIHJldHVybiBwYWdlUmVzdWx0cyhyZXN1bHRzLCBuZXh0UGFnZSwgZXRhZyk7XG4gICAgICB9XG4gICAgICAvLyBGb2xsb3cgbmV4dCBwYWdlXG4gICAgICByZXR1cm4gcHJvY2Vzc05leHRQYWdlKG5leHRQYWdlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmV4ZWN1dGUoe1xuICAgICAgcGF0aDogcGF0aCArIFwiP1wiICsgcXVlcnlzdHJpbmcsXG4gICAgICAuLi50aGlzLl9jb2xsT3B0aW9ucyhvcHRpb25zKSxcbiAgICB9LCB7cmF3OiB0cnVlfSkudGhlbihoYW5kbGVSZXNwb25zZSk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYmF0Y2ggb3BlcmF0aW9ucyBhdCB0aGUgY3VycmVudCBjb2xsZWN0aW9uIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgICAgICAgICAgICAgIFRoZSBiYXRjaCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBvcHRpb25zICAgICAgICAgICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgb3B0aW9ucy5oZWFkZXJzICAgIFRoZSBoZWFkZXJzIG9iamVjdCBvcHRpb24uXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICBvcHRpb25zLnNhZmUgICAgICAgVGhlIHNhZmUgb3B0aW9uLlxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgb3B0aW9ucy5hZ2dyZWdhdGUgIFByb2R1Y2VzIGEgZ3JvdXBlZCByZXN1bHQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdCwgRXJyb3I+fVxuICAgKi9cbiAgYmF0Y2goZm4sIG9wdGlvbnM9e30pIHtcbiAgICBjb25zdCByZXFPcHRpb25zID0gdGhpcy5fY29sbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmJhdGNoKGZuLCB7XG4gICAgICAuLi5yZXFPcHRpb25zLFxuICAgICAgYnVja2V0OiB0aGlzLmJ1Y2tldC5uYW1lLFxuICAgICAgY29sbGVjdGlvbjogdGhpcy5uYW1lLFxuICAgIH0pO1xuICB9XG59XG4iLCIvKipcbiAqIEVuZHBvaW50cyB0ZW1wbGF0ZXMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5jb25zdCBFTkRQT0lOVFMgPSB7XG4gIHJvb3Q6ICAgICAgICAgICAgICAgICAgICgpID0+IFwiL1wiLFxuICBiYXRjaDogICAgICAgICAgICAgICAgICAoKSA9PiBcIi9iYXRjaFwiLFxuICBidWNrZXQ6ICAgICAgICAgICAoYnVja2V0KSA9PiBcIi9idWNrZXRzXCIgKyAoYnVja2V0ID8gYC8ke2J1Y2tldH1gIDogXCJcIiksXG4gIGNvbGxlY3Rpb246IChidWNrZXQsIGNvbGwpID0+IGAke0VORFBPSU5UUy5idWNrZXQoYnVja2V0KX0vY29sbGVjdGlvbnNgICsgKGNvbGwgPyBgLyR7Y29sbH1gIDogXCJcIiksXG4gIGdyb3VwOiAgICAgKGJ1Y2tldCwgZ3JvdXApID0+IGAke0VORFBPSU5UUy5idWNrZXQoYnVja2V0KX0vZ3JvdXBzYCArIChncm91cCA/IGAvJHtncm91cH1gIDogXCJcIiksXG4gIHJlY29yZDogKGJ1Y2tldCwgY29sbCwgaWQpID0+IGAke0VORFBPSU5UUy5jb2xsZWN0aW9uKGJ1Y2tldCwgY29sbCl9L3JlY29yZHNgICsgKGlkID8gYC8ke2lkfWAgOiBcIlwiKSxcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgc2VydmVyIGVucG9pbnQgYnkgaXRzIG5hbWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgbmFtZSBUaGUgZW5kcG9pbnQgbmFtZS5cbiAqIEBwYXJhbSAgey4uLnN0cmluZ30gYXJncyBUaGUgZW5kcG9pbnQgcGFyYW1ldGVycy5cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZW5kcG9pbnQobmFtZSwgLi4uYXJncykge1xuICByZXR1cm4gRU5EUE9JTlRTW25hbWVdKC4uLmFyZ3MpO1xufVxuIiwiLyoqXG4gKiBLaW50byBzZXJ2ZXIgZXJyb3IgY29kZSBkZXNjcmlwdG9ycy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgMTA0OiBcIk1pc3NpbmcgQXV0aG9yaXphdGlvbiBUb2tlblwiLFxuICAxMDU6IFwiSW52YWxpZCBBdXRob3JpemF0aW9uIFRva2VuXCIsXG4gIDEwNjogXCJSZXF1ZXN0IGJvZHkgd2FzIG5vdCB2YWxpZCBKU09OXCIsXG4gIDEwNzogXCJJbnZhbGlkIHJlcXVlc3QgcGFyYW1ldGVyXCIsXG4gIDEwODogXCJNaXNzaW5nIHJlcXVlc3QgcGFyYW1ldGVyXCIsXG4gIDEwOTogXCJJbnZhbGlkIHBvc3RlZCBkYXRhXCIsXG4gIDExMDogXCJJbnZhbGlkIFRva2VuIC8gaWRcIixcbiAgMTExOiBcIk1pc3NpbmcgVG9rZW4gLyBpZFwiLFxuICAxMTI6IFwiQ29udGVudC1MZW5ndGggaGVhZGVyIHdhcyBub3QgcHJvdmlkZWRcIixcbiAgMTEzOiBcIlJlcXVlc3QgYm9keSB0b28gbGFyZ2VcIixcbiAgMTE0OiBcIlJlc291cmNlIHdhcyBtb2RpZmllZCBtZWFud2hpbGVcIixcbiAgMTE1OiBcIk1ldGhvZCBub3QgYWxsb3dlZCBvbiB0aGlzIGVuZCBwb2ludFwiLFxuICAxMTY6IFwiUmVxdWVzdGVkIHZlcnNpb24gbm90IGF2YWlsYWJsZSBvbiB0aGlzIHNlcnZlclwiLFxuICAxMTc6IFwiQ2xpZW50IGhhcyBzZW50IHRvbyBtYW55IHJlcXVlc3RzXCIsXG4gIDEyMTogXCJSZXNvdXJjZSBhY2Nlc3MgaXMgZm9yYmlkZGVuIGZvciB0aGlzIHVzZXJcIixcbiAgMTIyOiBcIkFub3RoZXIgcmVzb3VyY2UgdmlvbGF0ZXMgY29uc3RyYWludFwiLFxuICAyMDE6IFwiU2VydmljZSBUZW1wb3JhcnkgdW5hdmFpbGFibGUgZHVlIHRvIGhpZ2ggbG9hZFwiLFxuICAyMDI6IFwiU2VydmljZSBkZXByZWNhdGVkXCIsXG4gIDk5OTogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIixcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEVSUk9SX0NPREVTIGZyb20gXCIuL2Vycm9yc1wiO1xuXG4vKipcbiAqIEVuaGFuY2VkIEhUVFAgY2xpZW50IGZvciB0aGUgS2ludG8gcHJvdG9jb2wuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIVFRQIHtcbiAgLyoqXG4gICAqIERlZmF1bHQgSFRUUCByZXF1ZXN0IGhlYWRlcnMgYXBwbGllZCB0byBlYWNoIG91dGdvaW5nIHJlcXVlc3QuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERFRkFVTFRfUkVRVUVTVF9IRUFERVJTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBcIkFjY2VwdFwiOiAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBvcHRpb25zLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge3RpbWVvdXQ6IDUwMDAsIHJlcXVlc3RNb2RlOiBcImNvcnNcIn07XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0b3IuXG4gICAqXG4gICAqIE9wdGlvbnM6XG4gICAqIC0ge051bWJlcn0gdGltZW91dCAgICAgIFRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gbXMgKGRlZmF1bHQ6IGA1MDAwYCkuXG4gICAqIC0ge1N0cmluZ30gcmVxdWVzdE1vZGUgIFRoZSBIVFRQIHJlcXVlc3QgbW9kZSAoZGVmYXVsdDogYFwiY29yc1wiYCkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBldmVudHMgIFRoZSBldmVudCBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihldmVudHMsIG9wdGlvbnM9e30pIHtcbiAgICAvLyBwdWJsaWMgcHJvcGVydGllc1xuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBlbWl0dGVyIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtFdmVudEVtaXR0ZXJ9XG4gICAgICovXG4gICAgaWYgKCFldmVudHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGV2ZW50cyBoYW5kbGVyIHByb3ZpZGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0IG1vZGUuXG4gICAgICogQHNlZSAgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3Rtb2RlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3RNb2RlID0gb3B0aW9ucy5yZXF1ZXN0TW9kZSB8fCBIVFRQLmRlZmF1bHRPcHRpb25zLnJlcXVlc3RNb2RlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlcXVlc3QgdGltZW91dC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCBIVFRQLmRlZmF1bHRPcHRpb25zLnRpbWVvdXQ7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYW4gSFRUUCByZXF1ZXN0IHRvIHRoZSBLaW50byBzZXJ2ZXIuXG4gICAqXG4gICAqIE9wdGlvbnM6XG4gICAqIC0gYHtPYmplY3R9IGhlYWRlcnNgIFRoZSByZXF1ZXN0IGhlYWRlcnMgb2JqZWN0IChkZWZhdWx0OiB7fSlcbiAgICpcbiAgICogUmVzb2x2ZXMgd2l0aCBhbiBvYmpldCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgSFRUUCByZXNwb25zZSBwcm9wZXJ0aWVzOlxuICAgKiAtIGB7TnVtYmVyfSAgc3RhdHVzYCAgVGhlIEhUVFAgc3RhdHVzIGNvZGUuXG4gICAqIC0gYHtPYmplY3R9ICBqc29uYCAgICBUaGUgSlNPTiByZXNwb25zZSBib2R5LlxuICAgKiAtIGB7SGVhZGVyc30gaGVhZGVyc2AgVGhlIHJlc3BvbnNlIGhlYWRlcnMgb2JqZWN0OyBzZWUgdGhlIEVTNiBmZXRjaCgpIHNwZWMuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdXJsICAgICBUaGUgVVJMLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgVGhlIGZldGNoKCkgb3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICByZXF1ZXN0KHVybCwgb3B0aW9ucz17aGVhZGVyczp7fX0pIHtcbiAgICBsZXQgcmVzcG9uc2UsIHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVycywgaGFzVGltZWRvdXQ7XG4gICAgLy8gRW5zdXJlIGRlZmF1bHQgcmVxdWVzdCBoZWFkZXJzIGFyZSBhbHdheXMgc2V0XG4gICAgb3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgSFRUUC5ERUZBVUxUX1JFUVVFU1RfSEVBREVSUywgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICBvcHRpb25zLm1vZGUgPSB0aGlzLnJlcXVlc3RNb2RlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBfdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGhhc1RpbWVkb3V0ID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlJlcXVlc3QgdGltZW91dC5cIikpO1xuICAgICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgICAgIGZldGNoKHVybCwgb3B0aW9ucykgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgaWYgKCFoYXNUaW1lZG91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChfdGltZW91dElkKTtcbiAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmICghaGFzVGltZWRvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RpbWVvdXRJZCk7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pXG4gICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICByZXNwb25zZSA9IHJlcztcbiAgICAgICAgaGVhZGVycyA9IHJlcy5oZWFkZXJzO1xuICAgICAgICBzdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgICBzdGF0dXNUZXh0ID0gcmVzLnN0YXR1c1RleHQ7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9yRGVwcmVjYXRpb25IZWFkZXIoaGVhZGVycyk7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9yQmFja29mZkhlYWRlcihzdGF0dXMsIGhlYWRlcnMpO1xuICAgICAgICB0aGlzLl9jaGVja0ZvclJldHJ5QWZ0ZXJIZWFkZXIoc3RhdHVzLCBoZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCk7XG4gICAgICB9KVxuICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIGJvZHk7IGlmIHNvIHBhcnNlIGl0IGFzIEpTT04uXG4gICAgICAudGhlbih0ZXh0ID0+IHtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogd2UgY2FuJ3QgY29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSB0d2ljZS5cbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBIVFRQICR7c3RhdHVzIHx8IDB9OyAke2Vycn1gKTtcbiAgICAgICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSlcbiAgICAgIC50aGVuKGpzb24gPT4ge1xuICAgICAgICBpZiAoanNvbiAmJiBzdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgbGV0IG1lc3NhZ2UgPSBgSFRUUCAke3N0YXR1c30gJHtqc29uLmVycm9yfHxcIlwifTogYDtcbiAgICAgICAgICBpZiAoanNvbi5lcnJubyAmJiBqc29uLmVycm5vIGluIEVSUk9SX0NPREVTKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJub01zZyA9IEVSUk9SX0NPREVTW2pzb24uZXJybm9dO1xuICAgICAgICAgICAgbWVzc2FnZSArPSBlcnJub01zZztcbiAgICAgICAgICAgIGlmIChqc29uLm1lc3NhZ2UgJiYganNvbi5tZXNzYWdlICE9PSBlcnJub01zZykge1xuICAgICAgICAgICAgICBtZXNzYWdlICs9IGAgKCR7anNvbi5tZXNzYWdlfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IHN0YXR1c1RleHQgfHwgXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZS50cmltKCkpO1xuICAgICAgICAgIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgZXJyb3IuZGF0YSA9IGpzb247XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtzdGF0dXMsIGpzb24sIGhlYWRlcnN9O1xuICAgICAgfSk7XG4gIH1cblxuICBfY2hlY2tGb3JEZXByZWNhdGlvbkhlYWRlcihoZWFkZXJzKSB7XG4gICAgY29uc3QgYWxlcnRIZWFkZXIgPSBoZWFkZXJzLmdldChcIkFsZXJ0XCIpO1xuICAgIGlmICghYWxlcnRIZWFkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGFsZXJ0O1xuICAgIHRyeSB7XG4gICAgICBhbGVydCA9IEpTT04ucGFyc2UoYWxlcnRIZWFkZXIpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gcGFyc2UgQWxlcnQgaGVhZGVyIG1lc3NhZ2VcIiwgYWxlcnRIZWFkZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oYWxlcnQubWVzc2FnZSwgYWxlcnQudXJsKTtcbiAgICB0aGlzLmV2ZW50cy5lbWl0KFwiZGVwcmVjYXRlZFwiLCBhbGVydCk7XG4gIH1cblxuICBfY2hlY2tGb3JCYWNrb2ZmSGVhZGVyKHN0YXR1cywgaGVhZGVycykge1xuICAgIGxldCBiYWNrb2ZmTXM7XG4gICAgY29uc3QgYmFja29mZlNlY29uZHMgPSBwYXJzZUludChoZWFkZXJzLmdldChcIkJhY2tvZmZcIiksIDEwKTtcbiAgICBpZiAoYmFja29mZlNlY29uZHMgPiAwKSB7XG4gICAgICBiYWNrb2ZmTXMgPSAobmV3IERhdGUoKS5nZXRUaW1lKCkpICsgKGJhY2tvZmZTZWNvbmRzICogMTAwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhY2tvZmZNcyA9IDA7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRzLmVtaXQoXCJiYWNrb2ZmXCIsIGJhY2tvZmZNcyk7XG4gIH1cblxuICBfY2hlY2tGb3JSZXRyeUFmdGVySGVhZGVyKHN0YXR1cywgaGVhZGVycykge1xuICAgIGxldCByZXRyeUFmdGVyID0gaGVhZGVycy5nZXQoXCJSZXRyeS1BZnRlclwiKTtcbiAgICBpZiAoIXJldHJ5QWZ0ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0cnlBZnRlciA9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgKyAocGFyc2VJbnQocmV0cnlBZnRlciwgMTApICogMTAwMCk7XG4gICAgdGhpcy5ldmVudHMuZW1pdChcInJldHJ5LWFmdGVyXCIsIHJldHJ5QWZ0ZXIpO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFwiaXNvbW9ycGhpYy1mZXRjaFwiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcImV2ZW50c1wiO1xuXG5pbXBvcnQgS2ludG9DbGllbnRCYXNlIGZyb20gXCIuL2Jhc2VcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW50b0NsaWVudCBleHRlbmRzIEtpbnRvQ2xpZW50QmFzZSB7XG4gIGNvbnN0cnVjdG9yKHJlbW90ZSwgb3B0aW9ucz17fSkge1xuICAgIGNvbnN0IGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzIHx8IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIHN1cGVyKHJlbW90ZSwgT2JqZWN0LmFzc2lnbih7ZXZlbnRzfSwgb3B0aW9ucykpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBvbWl0IH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuY29uc3QgcmVxdWVzdERlZmF1bHRzID0ge1xuICBzYWZlOiBmYWxzZSxcbiAgLy8gY2hlY2sgaWYgd2Ugc2hvdWxkIHNldCBkZWZhdWx0IGNvbnRlbnQgdHlwZSBoZXJlXG4gIGhlYWRlcnM6IHt9LFxuICBwZXJtaXNzaW9uczogdW5kZWZpbmVkLFxuICBkYXRhOiB1bmRlZmluZWQsXG4gIHBhdGNoOiBmYWxzZSxcbn07XG5cbmZ1bmN0aW9uIHNhZmVIZWFkZXIoc2FmZSwgbGFzdF9tb2RpZmllZCkge1xuICBpZiAoIXNhZmUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgaWYgKGxhc3RfbW9kaWZpZWQpIHtcbiAgICByZXR1cm4ge1wiSWYtTWF0Y2hcIjogYFwiJHtsYXN0X21vZGlmaWVkfVwiYH07XG4gIH1cbiAgcmV0dXJuIHtcIklmLU5vbmUtTWF0Y2hcIjogXCIqXCJ9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KHBhdGgsIHtkYXRhLCBwZXJtaXNzaW9uc30sIG9wdGlvbnM9e30pIHtcbiAgY29uc3QgeyBoZWFkZXJzLCBzYWZlIH0gPSB7XG4gICAgLi4ucmVxdWVzdERlZmF1bHRzLFxuICAgIC4uLm9wdGlvbnMsXG4gIH07XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBkYXRhICYmIGRhdGEuaWQgPyBcIlBVVFwiIDogXCJQT1NUXCIsXG4gICAgcGF0aCxcbiAgICBoZWFkZXJzOiB7Li4uaGVhZGVycywgLi4uc2FmZUhlYWRlcihzYWZlKX0sXG4gICAgYm9keToge1xuICAgICAgZGF0YSxcbiAgICAgIHBlcm1pc3Npb25zXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVSZXF1ZXN0KHBhdGgsIHtkYXRhLCBwZXJtaXNzaW9uc30sIG9wdGlvbnM9e30pIHtcbiAgY29uc3Qge1xuICAgIGhlYWRlcnMsXG4gICAgc2FmZSxcbiAgICBwYXRjaCxcbiAgfSA9IHsuLi5yZXF1ZXN0RGVmYXVsdHMsIC4uLm9wdGlvbnN9O1xuICBjb25zdCB7IGxhc3RfbW9kaWZpZWQgfSA9IHsgLi4uZGF0YSwgLi4ub3B0aW9ucyB9O1xuXG4gIGlmIChPYmplY3Qua2V5cyhvbWl0KGRhdGEsIFwiaWRcIiwgXCJsYXN0X21vZGlmaWVkXCIpKS5sZW5ndGggPT09IDApIHtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IHBhdGNoID8gXCJQQVRDSFwiIDogXCJQVVRcIixcbiAgICBwYXRoLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAuLi5zYWZlSGVhZGVyKHNhZmUsIGxhc3RfbW9kaWZpZWQpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICBkYXRhLFxuICAgICAgcGVybWlzc2lvbnNcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZVJlcXVlc3QocGF0aCwgb3B0aW9ucz17fSkge1xuICBjb25zdCB7IGhlYWRlcnMsIHNhZmUsIGxhc3RfbW9kaWZpZWR9ID0ge1xuICAgIC4uLnJlcXVlc3REZWZhdWx0cyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGlmIChzYWZlICYmICFsYXN0X21vZGlmaWVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2FmZSBjb25jdXJyZW5jeSBjaGVjayByZXF1aXJlcyBhIGxhc3RfbW9kaWZpZWQgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgIHBhdGgsXG4gICAgaGVhZGVyczogey4uLmhlYWRlcnMsIC4uLnNhZmVIZWFkZXIoc2FmZSwgbGFzdF9tb2RpZmllZCl9XG4gIH07XG59XG4iLCIvKipcbiAqIENodW5rcyBhbiBhcnJheSBpbnRvIG4gcGllY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtBcnJheX0gIGFycmF5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFydGl0aW9uKGFycmF5LCBuKSB7XG4gIGlmIChuIDw9IDApIHtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgcmV0dXJuIGFycmF5LnJlZHVjZSgoYWNjLCB4LCBpKSA9PiB7XG4gICAgaWYgKGkgPT09IDAgfHwgaSAlIG4gPT09IDApIHtcbiAgICAgIGFjYy5wdXNoKFt4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY1thY2MubGVuZ3RoIC0gMV0ucHVzaCh4KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xufVxuXG4vKipcbiAqIE1hcHMgYSBsaXN0IHRvIHByb21pc2VzIHVzaW5nIHRoZSBwcm92aWRlZCBtYXBwaW5nIGZ1bmN0aW9uLCBleGVjdXRlcyB0aGVtXG4gKiBzZXF1ZW50aWFsbHkgdGhlbiByZXR1cm5zIGEgUHJvbWlzZSByZXNvbHZpbmcgd2l0aCBvcmRlcmVkIHJlc3VsdHMgb2J0YWluZWQuXG4gKiBUaGluayBvZiB0aGlzIGFzIGEgc2VxdWVudGlhbCBQcm9taXNlLmFsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7QXJyYXl9ICAgIGxpc3QgVGhlIGxpc3QgdG8gbWFwLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgVGhlIG1hcHBpbmcgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcE1hcChsaXN0LCBmbikge1xuICBsZXQgcmVzdWx0cyA9IFtdO1xuICByZXR1cm4gbGlzdC5yZWR1Y2UoKHByb21pc2UsIGVudHJ5KSA9PiB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZuKGVudHJ5KSlcbiAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChyZXN1bHQpKTtcbiAgICB9KTtcbiAgfSwgUHJvbWlzZS5yZXNvbHZlKCkpLnRoZW4oKCkgPT4gcmVzdWx0cyk7XG59XG5cbi8qKlxuICogVGFrZXMgYW4gb2JqZWN0IGFuZCByZXR1cm5zIGEgY29weSBvZiBpdCB3aXRoIHRoZSBwcm92aWRlZCBrZXlzIG9taXR0ZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge09iamVjdH0gICAgb2JqICBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSAgey4uLlN0cmluZ30ga2V5cyBUaGUga2V5cyB0byBvbWl0LlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gb21pdChvYmosIC4uLmtleXMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIGFjY1trZXldID0gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJucyBhIHJlc291cmNlIGRhdGEgb2JqZWN0IGZyb20gdGhlIHByb3ZpZGVkIGFyZ3VtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtPYmplY3R8U3RyaW5nfSByZXNvdXJjZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EYXRhQm9keShyZXNvdXJjZSkge1xuICBpZiAoaXNPYmplY3QocmVzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHJlc291cmNlO1xuICB9XG4gIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ge2lkOiByZXNvdXJjZX07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudC5cIik7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBvYmplY3QgaW50byBhbiBVUkwgcXVlcnkgc3RyaW5nLCBzdHJpcHBpbmcgb3V0IGFueSB1bmRlZmluZWRcbiAqIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXNpZnkob2JqKSB7XG4gIGNvbnN0IHNlcCA9IFwiJlwiO1xuICBjb25zdCBlbmNvZGUgPSAodikgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIiA/IFN0cmluZyh2KSA6IHYpO1xuICBjb25zdCBzdHJpcFVuZGVmaW5lZCA9IChvKSA9PiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG8pKTtcbiAgY29uc3Qgc3RyaXBwZWQgPSBzdHJpcFVuZGVmaW5lZChvYmopO1xuICByZXR1cm4gT2JqZWN0LmtleXMoc3RyaXBwZWQpLm1hcCgoaykgPT4ge1xuICAgIGNvbnN0IGtzID0gZW5jb2RlKGspICsgXCI9XCI7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3RyaXBwZWRba10pKSB7XG4gICAgICByZXR1cm4gc3RyaXBwZWRba10ubWFwKCh2KSA9PiBrcyArIGVuY29kZSh2KSkuam9pbihzZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ga3MgKyBlbmNvZGUoc3RyaXBwZWRba10pO1xuICAgIH1cbiAgfSkuam9pbihzZXApO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHZlcnNpb24gaXMgd2l0aGluIHRoZSBwcm92aWRlZCByYW5nZS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHZlcnNpb24gICAgVGhlIHZlcnNpb24gdG8gY2hlY2suXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG1pblZlcnNpb24gVGhlIG1pbmltdW0gc3VwcG9ydGVkIHZlcnNpb24gKGluY2x1c2l2ZSkuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG1heFZlcnNpb24gVGhlIG1pbmltdW0gc3VwcG9ydGVkIHZlcnNpb24gKGV4Y2x1c2l2ZSkuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZlcnNpb24gaXMgb3V0c2lkZSBvZiB0aGUgcHJvdmlkZWQgcmFuZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1ZlcnNpb24odmVyc2lvbiwgbWluVmVyc2lvbiwgbWF4VmVyc2lvbikge1xuICBjb25zdCBleHRyYWN0ID0gKHN0cikgPT4gc3RyLnNwbGl0KFwiLlwiKS5tYXAoeCA9PiBwYXJzZUludCh4LCAxMCkpO1xuICBjb25zdCBbdmVyTWFqb3IsIHZlck1pbm9yXSA9IGV4dHJhY3QodmVyc2lvbik7XG4gIGNvbnN0IFttaW5NYWpvciwgbWluTWlub3JdID0gZXh0cmFjdChtaW5WZXJzaW9uKTtcbiAgY29uc3QgW21heE1ham9yLCBtYXhNaW5vcl0gPSBleHRyYWN0KG1heFZlcnNpb24pO1xuICBjb25zdCBjaGVja3MgPSBbXG4gICAgdmVyTWFqb3IgPCBtaW5NYWpvcixcbiAgICB2ZXJNYWpvciA9PT0gbWluTWFqb3IgJiYgdmVyTWlub3IgPCBtaW5NaW5vcixcbiAgICB2ZXJNYWpvciA+IG1heE1ham9yLFxuICAgIHZlck1ham9yID09PSBtYXhNYWpvciAmJiB2ZXJNaW5vciA+PSBtYXhNaW5vcixcbiAgXTtcbiAgaWYgKGNoZWNrcy5zb21lKHggPT4geCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFZlcnNpb24gJHt2ZXJzaW9ufSBkb2Vzbid0IHNhdGlzZnkgYCArXG4gICAgICAgICAgICAgICAgICAgIGAke21pblZlcnNpb259IDw9IHggPCAke21heFZlcnNpb259YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBkZWNvcmF0b3IgZnVuY3Rpb24gZW5zdXJpbmcgYSB2ZXJzaW9uIGNoZWNrIGlzIHBlcmZvcm1lZCBhZ2FpbnN0XG4gKiB0aGUgcHJvdmlkZWQgcmVxdWlyZW1lbnRzIGJlZm9yZSBleGVjdXRpbmcgaXQuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBtaW4gVGhlIHJlcXVpcmVkIG1pbiB2ZXJzaW9uIChpbmNsdXNpdmUpLlxuICogQHBhcmFtICB7U3RyaW5nfSBtYXggVGhlIHJlcXVpcmVkIG1heCB2ZXJzaW9uIChpbmNsdXNpdmUpLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0KG1pbiwgbWF4KSB7XG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGNvbnN0IGZuID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB3cmFwcGVkTWV0aG9kID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAvLyBcInRoaXNcIiBpcyB0aGUgY3VycmVudCBpbnN0YW5jZSB3aGljaCBpdHMgbWV0aG9kIGlzIGRlY29yYXRlZC5cbiAgICAgICAgICBjb25zdCBjbGllbnQgPSBcImNsaWVudFwiIGluIHRoaXMgPyB0aGlzLmNsaWVudCA6IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGNsaWVudC5mZXRjaEhUVFBBcGlWZXJzaW9uKClcbiAgICAgICAgICAgIC50aGVuKHZlcnNpb24gPT4gY2hlY2tWZXJzaW9uKHZlcnNpb24sIG1pbiwgbWF4KSlcbiAgICAgICAgICAgIC50aGVuKFByb21pc2UucmVzb2x2ZShmbi5hcHBseSh0aGlzLCBhcmdzKSkpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgdmFsdWU6IHdyYXBwZWRNZXRob2QsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd3JhcHBlZE1ldGhvZDtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGRlY29yYXRvciBmdW5jdGlvbiBlbnN1cmluZyBhbiBvcGVyYXRpb24gaXMgbm90IHBlcmZvcm1lZCBmcm9tXG4gKiB3aXRoaW4gYSBiYXRjaCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZSB0byB0aHJvdy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9iYXRjaChtZXNzYWdlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGNvbnN0IGZuID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB3cmFwcGVkTWV0aG9kID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAvLyBcInRoaXNcIiBpcyB0aGUgY3VycmVudCBpbnN0YW5jZSB3aGljaCBpdHMgbWV0aG9kIGlzIGRlY29yYXRlZC5cbiAgICAgICAgICBpZiAodGhpcy5faXNCYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICB2YWx1ZTogd3JhcHBlZE1ldGhvZCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3cmFwcGVkTWV0aG9kO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gb2JqZWN0IChpLmUuIG5vdCBhbiBhcnJheSBub3IgbnVsbCkuXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRoaW5nIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHRoaW5nKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IFwib2JqZWN0XCIgJiYgdGhpbmcgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodGhpbmcpO1xufVxuIl19
